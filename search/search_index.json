{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction result is a header only C++17 library for error handling. Prerequisites and installation Compiler/Toolchain Status clang >= 7.0.0 Testing on CircleCI; tested on each push to GitHub gcc >= 8.3.0 Testing on CircleCI; tested on each push to GitHub boost >= 1.67.0 Testing on CircleCI; tested on each push to GitHub More specifically, Mitama.result requires a compiler/standard library supporting the following C++17 features: constexpr if constexpr lambda inline variables fold expressions class template deduction and deduction guide All the C++17 type traits from the <type_traits> header std::{invoke, apply} from the <functional> header std::string_view from the <string_view> header std::monostate from the <variant> header Mitama.result requires a Boost supporting the following libraries: boost::optional from the <boost/optional.hpp> header boost::variant from the <boost/variant.hpp> header boost::format from the <boost/format.hpp> header boost::hana::{fix, overload, overload_linearly} from the <boost/hana/functional/{fix, overload, overload_linearly}.hpp> header Basic Usage Here is a bad code, see below. If this program fail to assert, you don't know the reason for the error. bool func ( int a ) { if ( first check ) return false ; if ( second check ) return false ; if ( third check ) return false ; // function body... return true ; } // ... assert ( func ( 42 )); Here is a code using result. Even if this program fail to assert, you can get the reason for the error. auto func ( int a ) -> mitama :: result < int , std :: string > { if ( first check ) return mitama :: failure ( \"first check failed\" ); // early return if ( second check ) return mitama :: failure ( \"second check failed\" ); // early return if ( third check ) return mitama :: failure ( \"third check failed\" ); // early return // function body... return mitama :: success ( 42 ); } // ... int value func ( 42 ). unwrap (); // even if fail to unwrap, // raise an exception // and you get reason for the error.","title":"Home"},{"location":"#introduction","text":"result is a header only C++17 library for error handling.","title":"Introduction"},{"location":"#prerequisites-and-installation","text":"Compiler/Toolchain Status clang >= 7.0.0 Testing on CircleCI; tested on each push to GitHub gcc >= 8.3.0 Testing on CircleCI; tested on each push to GitHub boost >= 1.67.0 Testing on CircleCI; tested on each push to GitHub More specifically, Mitama.result requires a compiler/standard library supporting the following C++17 features: constexpr if constexpr lambda inline variables fold expressions class template deduction and deduction guide All the C++17 type traits from the <type_traits> header std::{invoke, apply} from the <functional> header std::string_view from the <string_view> header std::monostate from the <variant> header Mitama.result requires a Boost supporting the following libraries: boost::optional from the <boost/optional.hpp> header boost::variant from the <boost/variant.hpp> header boost::format from the <boost/format.hpp> header boost::hana::{fix, overload, overload_linearly} from the <boost/hana/functional/{fix, overload, overload_linearly}.hpp> header","title":"Prerequisites and installation"},{"location":"#basic-usage","text":"Here is a bad code, see below. If this program fail to assert, you don't know the reason for the error. bool func ( int a ) { if ( first check ) return false ; if ( second check ) return false ; if ( third check ) return false ; // function body... return true ; } // ... assert ( func ( 42 )); Here is a code using result. Even if this program fail to assert, you can get the reason for the error. auto func ( int a ) -> mitama :: result < int , std :: string > { if ( first check ) return mitama :: failure ( \"first check failed\" ); // early return if ( second check ) return mitama :: failure ( \"second check failed\" ); // early return if ( third check ) return mitama :: failure ( \"third check failed\" ); // early return // function body... return mitama :: success ( 42 ); } // ... int value func ( 42 ). unwrap (); // even if fail to unwrap, // raise an exception // and you get reason for the error.","title":"Basic Usage"},{"location":"Result101/","text":"class result result <T, E> is a class template that has success value type of T and failure value type of E . Actually, it is a wrapper class of std::variant<success<T>, failure<E>> that has a useful API.","title":"Home"},{"location":"Result101/#class-result","text":"result <T, E> is a class template that has success value type of T and failure value type of E . Actually, it is a wrapper class of std::variant<success<T>, failure<E>> that has a useful API.","title":"class result"},{"location":"Result101/intro/","text":"Introduction Definition of class basic_result enum class mutability : bool { mut = false , immut = true , }; template < mutability Mut > inline constexpr bool is_mut_v = ! static_cast < bool > ( Mut ); template < mutability , class = std :: monostate , // success type class = std :: monostate , // failure type class = decltype ( nullptr ) // for detection idiom > class basic_result ; Concepts basic_result<_, T, E> is a class that holds either a success value type T or a failure value type E . basic_result<_, T, E> holds values like boost::variant<T, E> . Therefore, T and E must satisfy the following requirements for bounded types: CopyConstructible or MoveConstructible. Destructor upholds the no-throw exception-safety guarantee. Complete at the point of variant template instantiation. In more detail, see the document . result/mut_result the alias templates First (non-type) template parameter of basic_result is a value of enum class mutability for mutability control. The library provides two type synonyms of basic_result as follows: mut_result<T, E> stands for basic_result<mutability::mut, T, E> result<T, E> stands for basic_result<mutability::immut, T, E> You should use mut_result<T, E> if you want to resubstitute, result<T, E> do not provides assignment operators or mutable accessors. success/failure the in-place factory classes success and failure are in-place factory classes for basic_result . If you want to initialize result<T, E> with successful value of T , initialize with success<T> . result < int , std :: string > res = success ( 42 ); Similarly, if you want to initialize result<T, E> with unsuccessful value of E , initialize with failure<E> . result < int , std :: string > res = failure ( \"error\" s ); Result of reference types (In Progress...)","title":"Introduction"},{"location":"Result101/intro/#introduction","text":"","title":"Introduction"},{"location":"Result101/intro/#definition-of-class-basic_result","text":"enum class mutability : bool { mut = false , immut = true , }; template < mutability Mut > inline constexpr bool is_mut_v = ! static_cast < bool > ( Mut ); template < mutability , class = std :: monostate , // success type class = std :: monostate , // failure type class = decltype ( nullptr ) // for detection idiom > class basic_result ;","title":"Definition of class basic_result"},{"location":"Result101/intro/#concepts","text":"basic_result<_, T, E> is a class that holds either a success value type T or a failure value type E . basic_result<_, T, E> holds values like boost::variant<T, E> . Therefore, T and E must satisfy the following requirements for bounded types: CopyConstructible or MoveConstructible. Destructor upholds the no-throw exception-safety guarantee. Complete at the point of variant template instantiation. In more detail, see the document .","title":"Concepts"},{"location":"Result101/intro/#resultmut_result-the-alias-templates","text":"First (non-type) template parameter of basic_result is a value of enum class mutability for mutability control. The library provides two type synonyms of basic_result as follows: mut_result<T, E> stands for basic_result<mutability::mut, T, E> result<T, E> stands for basic_result<mutability::immut, T, E> You should use mut_result<T, E> if you want to resubstitute, result<T, E> do not provides assignment operators or mutable accessors.","title":"result/mut_result the alias templates"},{"location":"Result101/intro/#successfailure-the-in-place-factory-classes","text":"success and failure are in-place factory classes for basic_result . If you want to initialize result<T, E> with successful value of T , initialize with success<T> . result < int , std :: string > res = success ( 42 ); Similarly, if you want to initialize result<T, E> with unsuccessful value of E , initialize with failure<E> . result < int , std :: string > res = failure ( \"error\" s );","title":"success/failure the in-place factory classes"},{"location":"Result101/intro/#result-of-reference-types","text":"(In Progress...)","title":"Result of reference types"},{"location":"Result101/special_members/","text":"Constructors default constructor (deleted) [0/16] Default constructor is not permitted. explicit copy constructor for convertible basic_result [1/16] template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v<T, U> && is_nothrow_copy_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true and std::disjunction<std::negation<std::is_convertible<F, E>>, std::negation<std::is_convertible<U, T>>> is true. If is_trivially_copy_constructible_v<T, U> && is_trivially_copy_constructible_v<E, F> is true, this constructor shall be a constexpr constructor. non-explicit copy constructor for convertible basic_result [2/16] template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v<T, U> && is_nothrow_copy_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true, std::is_convertible<F, E> is true and, std::is_convertible<U, T>> is true. If is_trivially_copy_constructible_v<T, U> && is_trivially_copy_constructible_v<E, F> is true, this constructor shall be a constexpr constructor. explicit move constructor for convertible basic_result [3/16] template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v<T, U> && is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true and, std::disjunction<std::negation<std::is_convertible<F, E>>, std::negation<std::is_convertible<U, T>>> is true. If is_trivially_move_constructible_v<T, U> && is_trivially_move_constructible_v<E, F> is true, this constructor shall be a constexpr constructor. non-explicit copy constructor for convertible basic_result [4/16] template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v<T, U> && is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true, std::is_convertible<F, E> is true and, std::is_convertible<U, T>> is true. If is_trivially_move_constructible_v<T, U> && is_trivially_move_constructible_v<E, F> is true, this constructor shall be a constexpr constructor. non-explicit copy constructor from success [5/16] template < class U > basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true. explicit copy constructor from success [6/16] template < class U > explicit basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true. non-explicit move constructor from success [7/16] template < class U > basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true. explicit move constructor from success [8/16] template < class U > explicit basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true. non-explicit copy constructor from failure [9/16] template < class F > basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && is_convertible_v<F, E> is true. explicit copy constructor from failure [10/16] template < class F > explicit basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && !is_convertible_v<F, E> is true. non-explicit move constructor from failure [11/16] template < class F > basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && is_convertible_v<F, E> is true. explicit move constructor from failure [12/16] template < class F > explicit basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E>&& . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && !is_convertible_v<U, E> is true. emplace constructor for successful results [13/16] template < class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , Args && ... args ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (success<T>(std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, Args&&...> is true, this constructor shall be a nothrow constructor. Example using my_result = result < std :: tuple < int , int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , 1 , 1 ); // same as `my_result(success(std::tuple{1,1}))` emplace constructor for unsuccessful results [14/16] template < class ... Args > explicit basic_result :: basic_result ( in_place_err_t , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (failure<E>(std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, Args&&...> is true, this constructor shall be a nothrow constructor. Example using my_result = result < int , std :: string > ; auto res = my_result ( mitama :: in_place_err , 'a' , 5 ); // failure(\"aaaaa\") emplace constructor with initializer_list for successful results [15/16] template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (success<T>(il, std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of T. Example using my_result = result < std :: vector < int > , std :: string > ; auto res = my_result ( in_place_ok , { 1 , 2 , 3 , 4 }, std :: allocator < int > ()); // success([1,2,3,4]) emplace constructor with initializer_list for unsuccessful results [16/16] template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (failure<E>(il, std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = result < std :: string , std :: vector < int >> ; auto res = my_result ( in_place_err , { 1 , 2 , 3 , 4 }); // failure([1,2,3,4]) Assignment operators copy assignment operator [1/6] template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F > const & res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable. move assignment operator [2/6] template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F >&& res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable. copy assignment operator for success [3/6] template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U > const & _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable. move assignment operator for success [4/6] template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U >&& _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable. copy assignment operator for failure [5/6] template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F > const & _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable. move assignment operator for failure [6/6] template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F >&& _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"Special Members"},{"location":"Result101/special_members/#constructors","text":"","title":"Constructors"},{"location":"Result101/special_members/#default-constructor-deleted-016","text":"Default constructor is not permitted.","title":"default constructor (deleted) [0/16]"},{"location":"Result101/special_members/#explicit-copy-constructor-for-convertible-basic_result-116","text":"template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v<T, U> && is_nothrow_copy_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true and std::disjunction<std::negation<std::is_convertible<F, E>>, std::negation<std::is_convertible<U, T>>> is true. If is_trivially_copy_constructible_v<T, U> && is_trivially_copy_constructible_v<E, F> is true, this constructor shall be a constexpr constructor.","title":"explicit copy constructor for convertible basic_result [1/16]"},{"location":"Result101/special_members/#non-explicit-copy-constructor-for-convertible-basic_result-216","text":"template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v<T, U> && is_nothrow_copy_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true, std::is_convertible<F, E> is true and, std::is_convertible<U, T>> is true. If is_trivially_copy_constructible_v<T, U> && is_trivially_copy_constructible_v<E, F> is true, this constructor shall be a constexpr constructor.","title":"non-explicit copy constructor for convertible basic_result [2/16]"},{"location":"Result101/special_members/#explicit-move-constructor-for-convertible-basic_result-316","text":"template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v<T, U> && is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true and, std::disjunction<std::negation<std::is_convertible<F, E>>, std::negation<std::is_convertible<U, T>>> is true. If is_trivially_move_constructible_v<T, U> && is_trivially_move_constructible_v<E, F> is true, this constructor shall be a constexpr constructor.","title":"explicit move constructor for convertible basic_result [3/16]"},{"location":"Result101/special_members/#non-explicit-copy-constructor-for-convertible-basic_result-416","text":"template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v<T, U> && is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true, std::is_convertible<F, E> is true and, std::is_convertible<U, T>> is true. If is_trivially_move_constructible_v<T, U> && is_trivially_move_constructible_v<E, F> is true, this constructor shall be a constexpr constructor.","title":"non-explicit copy constructor for convertible basic_result [4/16]"},{"location":"Result101/special_members/#non-explicit-copy-constructor-from-success-516","text":"template < class U > basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true.","title":"non-explicit copy constructor from success [5/16]"},{"location":"Result101/special_members/#explicit-copy-constructor-from-success-616","text":"template < class U > explicit basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true.","title":"explicit copy constructor from success [6/16]"},{"location":"Result101/special_members/#non-explicit-move-constructor-from-success-716","text":"template < class U > basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true.","title":"non-explicit move constructor from success [7/16]"},{"location":"Result101/special_members/#explicit-move-constructor-from-success-816","text":"template < class U > explicit basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true.","title":"explicit move constructor from success [8/16]"},{"location":"Result101/special_members/#non-explicit-copy-constructor-from-failure-916","text":"template < class F > basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && is_convertible_v<F, E> is true.","title":"non-explicit copy constructor from failure [9/16]"},{"location":"Result101/special_members/#explicit-copy-constructor-from-failure-1016","text":"template < class F > explicit basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && !is_convertible_v<F, E> is true.","title":"explicit copy constructor from failure [10/16]"},{"location":"Result101/special_members/#non-explicit-move-constructor-from-failure-1116","text":"template < class F > basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && is_convertible_v<F, E> is true.","title":"non-explicit move constructor from failure [11/16]"},{"location":"Result101/special_members/#explicit-move-constructor-from-failure-1216","text":"template < class F > explicit basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E>&& . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && !is_convertible_v<U, E> is true.","title":"explicit move constructor from failure [12/16]"},{"location":"Result101/special_members/#emplace-constructor-for-successful-results-1316","text":"template < class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , Args && ... args ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (success<T>(std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, Args&&...> is true, this constructor shall be a nothrow constructor. Example using my_result = result < std :: tuple < int , int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , 1 , 1 ); // same as `my_result(success(std::tuple{1,1}))`","title":"emplace constructor for successful results [13/16]"},{"location":"Result101/special_members/#emplace-constructor-for-unsuccessful-results-1416","text":"template < class ... Args > explicit basic_result :: basic_result ( in_place_err_t , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (failure<E>(std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, Args&&...> is true, this constructor shall be a nothrow constructor. Example using my_result = result < int , std :: string > ; auto res = my_result ( mitama :: in_place_err , 'a' , 5 ); // failure(\"aaaaa\")","title":"emplace constructor for unsuccessful results [14/16]"},{"location":"Result101/special_members/#emplace-constructor-with-initializer_list-for-successful-results-1516","text":"template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (success<T>(il, std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of T. Example using my_result = result < std :: vector < int > , std :: string > ; auto res = my_result ( in_place_ok , { 1 , 2 , 3 , 4 }, std :: allocator < int > ()); // success([1,2,3,4])","title":"emplace constructor with initializer_list for successful results [15/16]"},{"location":"Result101/special_members/#emplace-constructor-with-initializer_list-for-unsuccessful-results-1616","text":"template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (failure<E>(il, std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = result < std :: string , std :: vector < int >> ; auto res = my_result ( in_place_err , { 1 , 2 , 3 , 4 }); // failure([1,2,3,4])","title":"emplace constructor with initializer_list for unsuccessful results [16/16]"},{"location":"Result101/special_members/#assignment-operators","text":"","title":"Assignment operators"},{"location":"Result101/special_members/#copy-assignment-operator-16","text":"template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F > const & res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator [1/6]"},{"location":"Result101/special_members/#move-assignment-operator-26","text":"template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F >&& res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator [2/6]"},{"location":"Result101/special_members/#copy-assignment-operator-for-success-36","text":"template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U > const & _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator for success [3/6]"},{"location":"Result101/special_members/#move-assignment-operator-for-success-46","text":"template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U >&& _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator for success [4/6]"},{"location":"Result101/special_members/#copy-assignment-operator-for-failure-56","text":"template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F > const & _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator for failure [5/6]"},{"location":"Result101/special_members/#move-assignment-operator-for-failure-66","text":"template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F >&& _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator for failure [6/6]"},{"location":"api/","text":"CHANGELOG v5.0.0 (breaking change!) Types basic_result { Result<T, E> => basic_result<mutability, T, E> } Enabled lvalue reference types for both of T and E . result<T, E> the alias template for immutable basic_result . mut_result<T, E> the alias template for mutable basic_result . success { Ok<T> => success<T> } Enabled lvalue reference types for T . failure { Err<E> => failure<E> } Enabled lvalue reference types for E . New APIs as_ref() as_mut() indirect() indirect_ok() indirect_err() v1.2.0 enhancement new API: transpose new API: map_or_else v1.1.2 bug fix Result ::and_then(O&& op) do not perticipate in overload resolution if unless op returns Result<U, E> . std::invoke_result_t<O&&, T> must be returns Result<U, E> . It means op must only maps T -> U , never changes E . Result ::or_else(O&& op) do not perticipate in overload resolution if unless op returns Result<T, F> . std::invoke_result_t<O&&, E> must be returns Result<T, F> . It means op must only maps E -> F , never changes T . v1.1.1 bug fix Result ::unwrap_or_default() is now explicitly deleted if and only if std::is_default_constructible_v<T> || std::is_aggregate_v<T> is false.","title":"CHANGELOG"},{"location":"api/#changelog","text":"","title":"CHANGELOG"},{"location":"api/#v500-breaking-change","text":"","title":"v5.0.0 (breaking change!)"},{"location":"api/#types","text":"basic_result { Result<T, E> => basic_result<mutability, T, E> } Enabled lvalue reference types for both of T and E . result<T, E> the alias template for immutable basic_result . mut_result<T, E> the alias template for mutable basic_result . success { Ok<T> => success<T> } Enabled lvalue reference types for T . failure { Err<E> => failure<E> } Enabled lvalue reference types for E .","title":"Types"},{"location":"api/#new-apis","text":"as_ref() as_mut() indirect() indirect_ok() indirect_err()","title":"New APIs"},{"location":"api/#v120","text":"","title":"v1.2.0"},{"location":"api/#enhancement","text":"new API: transpose new API: map_or_else","title":"enhancement"},{"location":"api/#v112","text":"","title":"v1.1.2"},{"location":"api/#bug-fix","text":"Result ::and_then(O&& op) do not perticipate in overload resolution if unless op returns Result<U, E> . std::invoke_result_t<O&&, T> must be returns Result<U, E> . It means op must only maps T -> U , never changes E . Result ::or_else(O&& op) do not perticipate in overload resolution if unless op returns Result<T, F> . std::invoke_result_t<O&&, E> must be returns Result<T, F> . It means op must only maps E -> F , never changes T .","title":"bug fix"},{"location":"api/#v111","text":"","title":"v1.1.1"},{"location":"api/#bug-fix_1","text":"Result ::unwrap_or_default() is now explicitly deleted if and only if std::is_default_constructible_v<T> || std::is_aggregate_v<T> is false.","title":"bug fix"},{"location":"api/and/","text":"operator && template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: operator && ( basic_result < _ , U , E > const & res ) const & -> result < U , E > ; Returns res if the result is success , otherwise returns the failure value of self. Example { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < std :: string , std :: string > y = success ( \"foo\" s ); assert (( x && y ) == failure ( \"early error\" s )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"not a 2\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = success ( \"different result type\" s ); assert (( x && y ) == success ( \"different result type\" s )); }","title":"and"},{"location":"api/and/#operator","text":"template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: operator && ( basic_result < _ , U , E > const & res ) const & -> result < U , E > ; Returns res if the result is success , otherwise returns the failure value of self. Example { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < std :: string , std :: string > y = success ( \"foo\" s ); assert (( x && y ) == failure ( \"early error\" s )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"not a 2\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = success ( \"different result type\" s ); assert (( x && y ) == success ( \"different result type\" s )); }","title":"operator &amp;&amp;"},{"location":"api/and_then/","text":"and_then() template < class O > constexpr auto basic_result < _ , T , E >:: and_then ( O && op ) -> std :: invoke_result < O && , T > ; Calls op if the result is success, otherwise returns the failure value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v<std::invoke_result_t<O, T>, failure<E>> is true. Example auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; assert ( success ( 2u ). and_then ( sq ). and_then ( sq ) == success ( 16u )); assert ( success ( 2u ). and_then ( sq ). and_then ( err ) == failure ( 4u )); assert ( success ( 2u ). and_then ( err ). and_then ( sq ) == failure ( 2u )); assert ( failure ( 3u ). and_then ( sq ). and_then ( sq ) == failure ( 3u ));","title":"and_then"},{"location":"api/and_then/#and_then","text":"template < class O > constexpr auto basic_result < _ , T , E >:: and_then ( O && op ) -> std :: invoke_result < O && , T > ; Calls op if the result is success, otherwise returns the failure value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v<std::invoke_result_t<O, T>, failure<E>> is true. Example auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; assert ( success ( 2u ). and_then ( sq ). and_then ( sq ) == success ( 16u )); assert ( success ( 2u ). and_then ( sq ). and_then ( err ) == failure ( 4u )); assert ( success ( 2u ). and_then ( err ). and_then ( sq ) == failure ( 2u )); assert ( failure ( 3u ). and_then ( sq ). and_then ( sq ) == failure ( 3u ));","title":"and_then()"},{"location":"api/equality/","text":"operator==() [1/3] template < mutability _ , class U , class F > bool basic_result < _ , T , E >:: operator == ( basic_result < _ , U , F > const & rhs ) const & ; Equality comparison for basic_result<_, T, E> and basic_result<_, U, F> . Remarks This operator shall not participate in overload resolution unless std::declval<T const&>() == std::declval<U const&>() is valid expression and std::declval<E const&>() == std::declval<F const&>() is valid expression. operator==() [2/3] template < class U > bool result :: operator == ( success < U > const & rhs ) const & Equality comparison for basic_result<_, T, E> and success<U> . Returns true if this has success value this->unwrap() equals rhs value, otherwise false . Remarks This operator shall not participate in overload resolution unless std::declval<T const&>() == std::declval<U const&>() is valid expression. operator==() [3/3] template < class F > bool basic_result :: operator == ( failure < F > const & rhs ) const & Equality comparison for basic_result<_, T, E> and failure<F> . Returns true if this has failure value this->unwrap_err() equals rhs value, otherwise false . Remarks This operator shall not participate in overload resolution unless std::declval<E const&>() == std::declval<F const&>() is valid expression.","title":"operator=="},{"location":"api/equality/#operator-13","text":"template < mutability _ , class U , class F > bool basic_result < _ , T , E >:: operator == ( basic_result < _ , U , F > const & rhs ) const & ; Equality comparison for basic_result<_, T, E> and basic_result<_, U, F> . Remarks This operator shall not participate in overload resolution unless std::declval<T const&>() == std::declval<U const&>() is valid expression and std::declval<E const&>() == std::declval<F const&>() is valid expression.","title":"operator==() [1/3]"},{"location":"api/equality/#operator-23","text":"template < class U > bool result :: operator == ( success < U > const & rhs ) const & Equality comparison for basic_result<_, T, E> and success<U> . Returns true if this has success value this->unwrap() equals rhs value, otherwise false . Remarks This operator shall not participate in overload resolution unless std::declval<T const&>() == std::declval<U const&>() is valid expression.","title":"operator==() [2/3]"},{"location":"api/equality/#operator-33","text":"template < class F > bool basic_result :: operator == ( failure < F > const & rhs ) const & Equality comparison for basic_result<_, T, E> and failure<F> . Returns true if this has failure value this->unwrap_err() equals rhs value, otherwise false . Remarks This operator shall not participate in overload resolution unless std::declval<E const&>() == std::declval<F const&>() is valid expression.","title":"operator==() [3/3]"},{"location":"api/err/","text":"err() constexpr auto result < T , E >:: err () & -> boost :: optional < const E > ; constexpr auto result < T , E >:: err () const & -> boost :: optional < const E > ; constexpr auto result < T , E >:: err () && -> boost :: optional < const E > ; constexpr auto mut_result < T , E >:: err () & -> boost :: optional < E > ; constexpr auto mut_result < T , E >:: err () const & -> boost :: optional < const E > ; constexpr auto mut_result < T , E >:: err () && -> boost :: optional < E > ; Converts from basic_result to boost::optional . Converts self into an boost::optional , and discarding the success value, if any. Note that these functions propagate mutability to optional element types. Example result < unsigned , std :: string > x = success ( 2 ); assert ( x . err () == None ); result < unsigned , std :: string > y = failure ( \"Nothing here\" ); assert ( y . err () == Some ( \"Nothing here\" )); Remarks If self is rvalue and E is a reference type, this function returns boost::optional<dangling<std::reference_wrapper<std::remove_reference_t<E>>>> .","title":"err"},{"location":"api/err/#err","text":"constexpr auto result < T , E >:: err () & -> boost :: optional < const E > ; constexpr auto result < T , E >:: err () const & -> boost :: optional < const E > ; constexpr auto result < T , E >:: err () && -> boost :: optional < const E > ; constexpr auto mut_result < T , E >:: err () & -> boost :: optional < E > ; constexpr auto mut_result < T , E >:: err () const & -> boost :: optional < const E > ; constexpr auto mut_result < T , E >:: err () && -> boost :: optional < E > ; Converts from basic_result to boost::optional . Converts self into an boost::optional , and discarding the success value, if any. Note that these functions propagate mutability to optional element types. Example result < unsigned , std :: string > x = success ( 2 ); assert ( x . err () == None ); result < unsigned , std :: string > y = failure ( \"Nothing here\" ); assert ( y . err () == Some ( \"Nothing here\" )); Remarks If self is rvalue and E is a reference type, this function returns boost::optional<dangling<std::reference_wrapper<std::remove_reference_t<E>>>> .","title":"err()"},{"location":"api/is_err/","text":"is_err() constexpr bool basic_result < _ , T , E >:: is_err () const noexcept ; Returns true if the result is failure. Example result < uint32_t , std :: string > x = success ( - 3 ); assert_eq ( x . is_err (), false ); result < uint32_t , std :: string > y = failure ( \"Some error message\" ); assert_eq ( y . is_err (), true );","title":"is_err"},{"location":"api/is_err/#is_err","text":"constexpr bool basic_result < _ , T , E >:: is_err () const noexcept ; Returns true if the result is failure. Example result < uint32_t , std :: string > x = success ( - 3 ); assert_eq ( x . is_err (), false ); result < uint32_t , std :: string > y = failure ( \"Some error message\" ); assert_eq ( y . is_err (), true );","title":"is_err()"},{"location":"api/is_ok/","text":"is_ok() constexpr bool basic_result < _ , T , E >:: is_ok () const noexcept ; Returns true if the result is success . Example result < uint32_t , std :: string > x = success ( - 3 ); assert ( x . is_ok (), true ); result < uint32_t , std :: string > y = failure ( \"Some error message\" ); assert ( y . is_ok (), false );","title":"is_ok"},{"location":"api/is_ok/#is_ok","text":"constexpr bool basic_result < _ , T , E >:: is_ok () const noexcept ; Returns true if the result is success . Example result < uint32_t , std :: string > x = success ( - 3 ); assert ( x . is_ok (), true ); result < uint32_t , std :: string > y = failure ( \"Some error message\" ); assert ( y . is_ok (), false );","title":"is_ok()"},{"location":"api/map/","text":"map() constexpr auto basic_result < _ , T , E >:: map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , result < std :: invoke_result_t < O , T > , E >> ; Maps a result<T, E> to result<U, E> by applying a function to a contained success value, leaving an failure value untouched. This function can be used to compose the results of two functions. Example std :: string line = \"1,3,5,7\" ; for ( auto num : split ( line , \",\" )) { if ( auto res = parse < int > ( num ). map ( _1 * 2 ); res . is_ok ()) { assert_true ( res . ok (). value () % 2 == 0 ); } }","title":"map"},{"location":"api/map/#map","text":"constexpr auto basic_result < _ , T , E >:: map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , result < std :: invoke_result_t < O , T > , E >> ; Maps a result<T, E> to result<U, E> by applying a function to a contained success value, leaving an failure value untouched. This function can be used to compose the results of two functions. Example std :: string line = \"1,3,5,7\" ; for ( auto num : split ( line , \",\" )) { if ( auto res = parse < int > ( num ). map ( _1 * 2 ); res . is_ok ()) { assert_true ( res . ok (). value () % 2 == 0 ); } }","title":"map()"},{"location":"api/map_err/","text":"map_err() template < class O > constexpr auto basic_result < _ , T , E >:: map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , result < T , std :: invoke_result_t < O , E >>> ; Maps a result<T, E> to result<T, F> by applying a function to a contained failure value, leaving an success value untouched. This function can be used to pass through a successful result while handling an error. Example auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; result < unsigned , unsigned > x = success ( 2 ); assert_eq ( x . map_err ( stringify ), success ( 2u )); result < unsigned , unsigned > y = failure ( 13 ); assert_eq ( y . map_err ( stringify ), failure ( \"error code: 13\" s ));","title":"map_err"},{"location":"api/map_err/#map_err","text":"template < class O > constexpr auto basic_result < _ , T , E >:: map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , result < T , std :: invoke_result_t < O , E >>> ; Maps a result<T, E> to result<T, F> by applying a function to a contained failure value, leaving an success value untouched. This function can be used to pass through a successful result while handling an error. Example auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; result < unsigned , unsigned > x = success ( 2 ); assert_eq ( x . map_err ( stringify ), success ( 2u )); result < unsigned , unsigned > y = failure ( 13 ); assert_eq ( y . map_err ( stringify ), failure ( \"error code: 13\" s ));","title":"map_err()"},{"location":"api/map_or_else/","text":"map_or_else() [since 1.2.0] template < class Map , class Fallback > constexpr auto basic_result < _ , T , E >:: map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; Maps a result<T, E> to U by applying a function to a contained success value, or a fallback function to a contained failure value. This function can be used to unpack a successful result while handling an error. Examples Basic usage: auto k = 21 ; { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); }","title":"map_or_else"},{"location":"api/map_or_else/#map_or_else-since-120","text":"template < class Map , class Fallback > constexpr auto basic_result < _ , T , E >:: map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; Maps a result<T, E> to U by applying a function to a contained success value, or a fallback function to a contained failure value. This function can be used to unpack a successful result while handling an error. Examples Basic usage: auto k = 21 ; { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); }","title":"map_or_else() [since 1.2.0]"},{"location":"api/ok/","text":"ok() constexpr auto result < T , E >:: ok () & -> boost :: optional < const T > ; constexpr auto result < T , E >:: ok () const & -> boost :: optional < const T > ; constexpr auto result < T , E >:: ok () && -> boost :: optional < const T > ; constexpr auto mut_result < T , E >:: ok () & -> boost :: optional < T > ; constexpr auto mut_result < T , E >:: ok () const & -> boost :: optional < const T > ; constexpr auto mut_result < T , E >:: ok () && -> boost :: optional < T > ; Converts from basic_result to boost::optional . Converts self into an boost::optional , and discarding the failure value, if any. Note that these functions propagate mutability to optional element types. Example result < unsigned , std :: string > x = success ( 2 ); assert ( x . ok () == Some ( 2 )); result < unsigned , std :: string > y = failure ( \"Nothing here\" ); assert ( y . ok () == None ); Remarks If self is rvalue and T is a reference type, this function returns boost::optional<dangling<std::reference_wrapper<std::remove_reference_t<T>>>> .","title":"ok"},{"location":"api/ok/#ok","text":"constexpr auto result < T , E >:: ok () & -> boost :: optional < const T > ; constexpr auto result < T , E >:: ok () const & -> boost :: optional < const T > ; constexpr auto result < T , E >:: ok () && -> boost :: optional < const T > ; constexpr auto mut_result < T , E >:: ok () & -> boost :: optional < T > ; constexpr auto mut_result < T , E >:: ok () const & -> boost :: optional < const T > ; constexpr auto mut_result < T , E >:: ok () && -> boost :: optional < T > ; Converts from basic_result to boost::optional . Converts self into an boost::optional , and discarding the failure value, if any. Note that these functions propagate mutability to optional element types. Example result < unsigned , std :: string > x = success ( 2 ); assert ( x . ok () == Some ( 2 )); result < unsigned , std :: string > y = failure ( \"Nothing here\" ); assert ( y . ok () == None ); Remarks If self is rvalue and T is a reference type, this function returns boost::optional<dangling<std::reference_wrapper<std::remove_reference_t<T>>>> .","title":"ok()"},{"location":"api/or/","text":"operator||() template < class F > constexpr auto basic_result < _ , T , E >:: operator || ( result < T , F > const & res ) const & -> result < T , F > ; Returns res if the result is failure , otherwise returns the success value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. Example { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert_eq ( x || y , success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < unsigned , std :: string > y = success ( 2 ); assert_eq ( x || y , success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert_eq ( x || y , failure ( \"late error\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = success ( 100 ); assert_eq ( x || y , success ( 2u )); }","title":"or"},{"location":"api/or/#operator","text":"template < class F > constexpr auto basic_result < _ , T , E >:: operator || ( result < T , F > const & res ) const & -> result < T , F > ; Returns res if the result is failure , otherwise returns the success value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. Example { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert_eq ( x || y , success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < unsigned , std :: string > y = success ( 2 ); assert_eq ( x || y , success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert_eq ( x || y , failure ( \"late error\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = success ( 100 ); assert_eq ( x || y , success ( 2u )); }","title":"operator||()"},{"location":"api/or_else/","text":"or_else() template < class O > constexpr auto basic_result < _ , T , E >:: or_else ( O && op ) const & -> std :: invoke_result < O && , E > ; Calls op if the result is failure , otherwise returns the success value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v<std::invoke_result_t<O, T>, success<T>> is true. Example auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; assert_eq ( success ( 2 ). or_else ( sq ). or_else ( sq ), success ( 2u )); assert_eq ( success ( 2 ). or_else ( err ). or_else ( sq ), success ( 2u )); assert_eq ( failure ( 3 ). or_else ( sq ). or_else ( err ), success ( 9u )); assert_eq ( failure ( 3 ). or_else ( err ). or_else ( err ), failure ( 3u ));","title":"or_else"},{"location":"api/or_else/#or_else","text":"template < class O > constexpr auto basic_result < _ , T , E >:: or_else ( O && op ) const & -> std :: invoke_result < O && , E > ; Calls op if the result is failure , otherwise returns the success value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v<std::invoke_result_t<O, T>, success<T>> is true. Example auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; assert_eq ( success ( 2 ). or_else ( sq ). or_else ( sq ), success ( 2u )); assert_eq ( success ( 2 ). or_else ( err ). or_else ( sq ), success ( 2u )); assert_eq ( failure ( 3 ). or_else ( sq ). or_else ( err ), success ( 9u )); assert_eq ( failure ( 3 ). or_else ( err ). or_else ( err ), failure ( 3u ));","title":"or_else()"},{"location":"api/transpose/","text":"transpose() [since 1.2.0] auto basic_result < _ , std :: optional < T > , E >:: transpose () -> std :: optional < basic_result < _ , T , E >> ; auto basic_result < _ , boost :: optional < T > , E >:: transpose () -> boost :: optional < basic_result < _ , T , E >> ; Transposes a result of an optional into an optional of a result . success(None) will be mapped to None . success(Some(v)) and failure(v) will be mapped to optional(success(v)) and optional(failure(v)) . Example struct SomeError {}; result < std :: optional < int > , SomeError > x = success ( std :: optional ( 5 )); std :: optional < result < int , SomeError >> y = std :: optional ( result < int , SomeError > ( success ( 5 ))); assert_eq ! ( x . transpose (), y );","title":"transpose"},{"location":"api/transpose/#transpose-since-120","text":"auto basic_result < _ , std :: optional < T > , E >:: transpose () -> std :: optional < basic_result < _ , T , E >> ; auto basic_result < _ , boost :: optional < T > , E >:: transpose () -> boost :: optional < basic_result < _ , T , E >> ; Transposes a result of an optional into an optional of a result . success(None) will be mapped to None . success(Some(v)) and failure(v) will be mapped to optional(success(v)) and optional(failure(v)) . Example struct SomeError {}; result < std :: optional < int > , SomeError > x = success ( std :: optional ( 5 )); std :: optional < result < int , SomeError >> y = std :: optional ( result < int , SomeError > ( success ( 5 ))); assert_eq ! ( x . transpose (), y );","title":"transpose() [since 1.2.0]"},{"location":"api/unwrap/","text":"unwrap() auto result < T , E >:: unwrap () & -> const T ; auto result < T , E >:: unwrap () const & -> const T ; auto result < T , E >:: unwrap () && -> const T ; auto mut_result < T , E >:: unwrap () & -> T ; auto mut_result < T , E >:: unwrap () const & -> const T ; auto mut_result < T , E >:: unwrap () && -> T ; Unwraps a result, yielding the content of an success . Exception Raise mitama::runtime_panic if a result is containing failure value. Example { result < unsigned , std :: string > x = success ( 2 ); assert_eq ( x . unwrap (), 2 ); } try { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic cosnt & panic ) { std :: err << panic . what () << std :: endl ; // `emergency failure` }","title":"unwrap"},{"location":"api/unwrap/#unwrap","text":"auto result < T , E >:: unwrap () & -> const T ; auto result < T , E >:: unwrap () const & -> const T ; auto result < T , E >:: unwrap () && -> const T ; auto mut_result < T , E >:: unwrap () & -> T ; auto mut_result < T , E >:: unwrap () const & -> const T ; auto mut_result < T , E >:: unwrap () && -> T ; Unwraps a result, yielding the content of an success . Exception Raise mitama::runtime_panic if a result is containing failure value. Example { result < unsigned , std :: string > x = success ( 2 ); assert_eq ( x . unwrap (), 2 ); } try { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic cosnt & panic ) { std :: err << panic . what () << std :: endl ; // `emergency failure` }","title":"unwrap()"},{"location":"api/unwrap_err/","text":"unwrap_err() auto result < T , E >:: unwrap_err () & -> const E ; auto result < T , E >:: unwrap_err () const & -> const E ; auto result < T , E >:: unwrap_err () && -> const E ; auto mut_result < T , E >:: unwrap_err () & -> E ; auto mut_result < T , E >:: unwrap_err () const & -> const E ; auto mut_result < T , E >:: unwrap_err () && -> E ; Unwraps a result, yielding the content of an failure . Exception Raise mitama::runtime_panic if a result is containing success value. Remarks If self is rvalue and E is a reference type, this function returns boost::optional<dangling<std::reference_wrapper<std::remove_reference_t<E>>>> . Example try { result < unsigned , std :: string > x = success ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: err << panic . what () << std :: endl ; // 2 } { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); assert_eq ( x . unwrap_err (), \"emergency failure\" s ); }","title":"unwrap_err"},{"location":"api/unwrap_err/#unwrap_err","text":"auto result < T , E >:: unwrap_err () & -> const E ; auto result < T , E >:: unwrap_err () const & -> const E ; auto result < T , E >:: unwrap_err () && -> const E ; auto mut_result < T , E >:: unwrap_err () & -> E ; auto mut_result < T , E >:: unwrap_err () const & -> const E ; auto mut_result < T , E >:: unwrap_err () && -> E ; Unwraps a result, yielding the content of an failure . Exception Raise mitama::runtime_panic if a result is containing success value. Remarks If self is rvalue and E is a reference type, this function returns boost::optional<dangling<std::reference_wrapper<std::remove_reference_t<E>>>> . Example try { result < unsigned , std :: string > x = success ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: err << panic . what () << std :: endl ; // 2 } { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); assert_eq ( x . unwrap_err (), \"emergency failure\" s ); }","title":"unwrap_err()"},{"location":"api/unwrap_or/","text":"unwrap_or() auto basic_result < _ , T , E >:: unwrap_or ( T const & optb ) const noexcept Unwraps a result, yielding the content of an success . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example result < unsigned , unsigned > err = failure ( 2 ); result < unsigned , unsigned > ok = success ( 2 ); assert_eq ( ok . unwrap_or ( 1u ), 2u ); assert_eq ( err . unwrap_or ( 1u ), 1u );","title":"unwrap_or"},{"location":"api/unwrap_or/#unwrap_or","text":"auto basic_result < _ , T , E >:: unwrap_or ( T const & optb ) const noexcept Unwraps a result, yielding the content of an success . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example result < unsigned , unsigned > err = failure ( 2 ); result < unsigned , unsigned > ok = success ( 2 ); assert_eq ( ok . unwrap_or ( 1u ), 2u ); assert_eq ( err . unwrap_or ( 1u ), 1u );","title":"unwrap_or()"},{"location":"api/unwrap_or_default/","text":"unwrap_or_default() auto basic_result < _ , T , E >:: unwrap_or_default () const & -> T ; Returns the contained value or a default. If success , returns the contained value, otherwise if failure , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v<T> is true. Example auto good_year_from_input = \"1909\" s ; auto bad_year_from_input = \"190blarg\" s ; auto good_year = parse < int > ( good_year_from_input ). unwrap_or_default (); auto bad_year = parse < int > ( bad_year_from_input ). unwrap_or_default (); assert_eq ( 1909 , good_year ); assert_eq ( 0 , bad_year ); *","title":"unwrap_or_default"},{"location":"api/unwrap_or_default/#unwrap_or_default","text":"auto basic_result < _ , T , E >:: unwrap_or_default () const & -> T ; Returns the contained value or a default. If success , returns the contained value, otherwise if failure , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v<T> is true. Example auto good_year_from_input = \"1909\" s ; auto bad_year_from_input = \"190blarg\" s ; auto good_year = parse < int > ( good_year_from_input ). unwrap_or_default (); auto bad_year = parse < int > ( bad_year_from_input ). unwrap_or_default (); assert_eq ( 1909 , good_year ); assert_eq ( 0 , bad_year ); *","title":"unwrap_or_default()"},{"location":"api/unwrap_or_else/","text":"unwrap_or_else() template < class O > auto basic_result < _ , T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > ; Unwraps a result, yielding the content of an success . If the value is an failure then it calls op with its value. Example auto count = []( std :: stringx ) -> size_t { return x . size (); }; assert_eq ( success ( 2 ). unwrap_or_else ( count ), 2 ); assert_eq ( failure ( \"foo\" s ). unwrap_or_else ( count ), 3 );","title":"unwrap_or_else"},{"location":"api/unwrap_or_else/#unwrap_or_else","text":"template < class O > auto basic_result < _ , T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > ; Unwraps a result, yielding the content of an success . If the value is an failure then it calls op with its value. Example auto count = []( std :: stringx ) -> size_t { return x . size (); }; assert_eq ( success ( 2 ). unwrap_or_else ( count ), 2 ); assert_eq ( failure ( \"foo\" s ). unwrap_or_else ( count ), 3 );","title":"unwrap_or_else()"},{"location":"meta/is_result/","text":"is_result template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":"is_result"},{"location":"meta/is_result/#is_result","text":"template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":"is_result"},{"location":"meta/is_result_with/","text":"is_result_with template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"is_result_with"},{"location":"meta/is_result_with/#is_result_with","text":"template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"is_result_with"}]}