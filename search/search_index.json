{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Mitama . Result is a header only C++17 library for error handling. Prerequisites and installation \u00b6 Prerequisites \u00b6 Compiler/Toolchain Status clang >= 7.0.0 Testing on CircleCI; tested on each push to GitHub gcc >= 8.3.0 Testing on CircleCI; tested on each push to GitHub boost >= 1.67.0 Testing on CircleCI; tested on each push to GitHub More specifically, Mitama . Result requires a compiler/standard library supporting the following C++17 features: constexpr if constexpr lambda inline variables fold expressions class template deduction and deduction guide All the C++17 type traits from the < type_traits > header std :: { invoke , apply } from the < functional > header std :: string_view from the < string_view > header std :: monostate from the < variant > header And requires a Boost supporting the following libraries: boost :: format from the < boost / format . hpp > header boost :: hana :: { fix , overload , overload_linearly } from the < boost / hana / functional / { fix , overload , overload_linearly } . hpp > header Installation \u00b6 First, cloning mitama-cpp-result repository. $ git clone https://github.com/LoliGothick/mitama-cpp-result.git Second, add path / to / mitama - cpp / include to include path. Basic Usage \u00b6 Here is a bad code. bool func ( int a ) { if ( first check ) return false ; if ( second check ) return false ; if ( third check ) return false ; // function body... return true ; } // ... assert ( func ( 42 )); If this program fail to assert, you don't know the reason for the error. Rewrite this code using result. auto func ( int a ) -> mitama :: result < int , std :: string > { if ( first check ) return mitama :: failure ( \"first check failed\" ); // early return if ( second check ) return mitama :: failure ( \"second check failed\" ); // early return if ( third check ) return mitama :: failure ( \"third check failed\" ); // early return // function body... return mitama :: success ( 42 ); } // ... int value = func ( 42 ). unwrap (); Even if this program fail to assert, you can get the reason for the error.","title":"Home"},{"location":"#introduction","text":"Mitama . Result is a header only C++17 library for error handling.","title":"Introduction"},{"location":"#prerequisites_and_installation","text":"","title":"Prerequisites and installation"},{"location":"#prerequisites","text":"Compiler/Toolchain Status clang >= 7.0.0 Testing on CircleCI; tested on each push to GitHub gcc >= 8.3.0 Testing on CircleCI; tested on each push to GitHub boost >= 1.67.0 Testing on CircleCI; tested on each push to GitHub More specifically, Mitama . Result requires a compiler/standard library supporting the following C++17 features: constexpr if constexpr lambda inline variables fold expressions class template deduction and deduction guide All the C++17 type traits from the < type_traits > header std :: { invoke , apply } from the < functional > header std :: string_view from the < string_view > header std :: monostate from the < variant > header And requires a Boost supporting the following libraries: boost :: format from the < boost / format . hpp > header boost :: hana :: { fix , overload , overload_linearly } from the < boost / hana / functional / { fix , overload , overload_linearly } . hpp > header","title":"Prerequisites"},{"location":"#installation","text":"First, cloning mitama-cpp-result repository. $ git clone https://github.com/LoliGothick/mitama-cpp-result.git Second, add path / to / mitama - cpp / include to include path.","title":"Installation"},{"location":"#basic_usage","text":"Here is a bad code. bool func ( int a ) { if ( first check ) return false ; if ( second check ) return false ; if ( third check ) return false ; // function body... return true ; } // ... assert ( func ( 42 )); If this program fail to assert, you don't know the reason for the error. Rewrite this code using result. auto func ( int a ) -> mitama :: result < int , std :: string > { if ( first check ) return mitama :: failure ( \"first check failed\" ); // early return if ( second check ) return mitama :: failure ( \"second check failed\" ); // early return if ( third check ) return mitama :: failure ( \"third check failed\" ); // early return // function body... return mitama :: success ( 42 ); } // ... int value = func ( 42 ). unwrap (); Even if this program fail to assert, you can get the reason for the error.","title":"Basic Usage"},{"location":"maybe/APIs/","text":"is_just \u00b6 maybe<T>::is_just() -> bool template < class T > class maybe { constexpr bool maybe < T >:: is_just () const noexcept ; }; Returns true if the maybe has some value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( x . is_just () ); maybe < int > y = nothing ; assert ( ! y . is_just () ); } // end example is_nothing \u00b6 maybe<T>::is_nothing() -> bool template < class T > class maybe { constexpr bool maybe < T >:: is_nothing () const noexcept ; }; Returns true if the maybe is a nothing value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( ! x . is_nothing () ); maybe < int > y = nothing ; assert ( y . is_nothing () ); } // end example as_ref \u00b6 maybe<T>::as_ref() -> maybe<T&> template < class T > class maybe { auto maybe < T >:: as_ref () & -> maybe < T &> ; auto maybe < T >:: as_ref () const & -> maybe < const T &> ; }; Converts from maybe < T >& to maybe < T &> . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> #include <iostream> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe text = just ( \"Hello, world!\" s ); // First, cast `maybe<T>` to `maybe<T&>` with `as_ref`, auto text_length = text . as_ref (). map ( & std :: string :: size ); std :: cout << \"still can print text: \" << text << \" \\n \" ; } // end example expect \u00b6 maybe<T>::expect(std::string_view msg) -> T& template < class T > class maybe { auto maybe < T >:: expect ( std :: string_view msg ) & -> T & ; auto maybe < T >:: expect ( std :: string_view msg ) const & -> T const & ; auto maybe < T >:: expect ( std :: string_view msg ) && -> T && ; }; Unwraps a maybe, yielding the content of a just . Exception Raise mitama :: runtime_panic if the value is a nothing with a custom panic message provided by msg . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"value\" s ); assert ( x . expect ( \"the world is ending\" ) == \"value\" s ); } try { maybe < int > x = nothing ; x . expect ( \"the world is ending\" ); // panics with `the world is ending` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'the world is ending' } } // end example unwrap \u00b6 maybe<T>::unwrap() -> T& template < class T > class maybe { auto maybe < T >:: unwrap () & -> T & ; auto maybe < T >:: unwrap () const & -> T const & ; auto maybe < T >:: unwrap () && -> T && ; }; Unwraps a maybe, yielding the content of a just . Exception Raise mitama :: runtime_panic if a maybe has not just value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"air\" s ); assert ( x . unwrap () == \"air\" s ); } try { maybe < int > x = nothing ; x . unwrap (); // raise an exception } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'called `maybe::unwrap()` on a `nothing` value' } } // end example unwrap_or \u00b6 maybe<T>::unwrap_or(T def) -> T template < class T > class maybe { template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T & , U &&>>:: value , std :: common_type_t < T & , U &&>> maybe < T >:: unwrap_or ( U && def ) & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T const & , U &&>>:: value , std :: common_type_t < T const & , U &&>> maybe < T >:: unwrap_or ( U && def ) const & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T && , U &&>>:: value , std :: common_type_t < T && , U &&>> maybe < T >:: unwrap_or ( U && def ) && ; }; Returns the contained value or a default. Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { assert ( maybe { just ( \"car\" s )}. unwrap_or ( \"bike\" s ) == \"car\" s ); assert ( maybe < std :: string > { nothing }. unwrap_or ( \"bike\" s ) == \"bike\" s ); } // end example unwrap_or_else \u00b6 maybe<T>::unwrap_or_else(F f) -> T where F: () -> T template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T const & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T const & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T && , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T && , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) && ; }; Returns the contained value or computes it from a invocable object op . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int k = 10 ; assert ( maybe { just ( 4 )}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 4 ); assert ( maybe < int > {}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 20 ); } // end example map \u00b6 maybe<T>::map(F f) -> maybe<T> where F: T -> U template < class T > class maybe { template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &> , bool > = false > auto maybe < T >:: map ( F && f ) & -> maybe < std :: invoke_result_t < F && , T &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T const &> , bool > = false > auto maybe < T >:: map ( F && f ) const & -> maybe < std :: invoke_result_t < F && , T const &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &&> , bool > = false > auto maybe < T >:: map ( F && f ) && -> maybe < std :: invoke_result_t < F && , T &&>> ; }; Maps a maybe < T > to maybe < U > by applying a function to a contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe maybe_some_string = just ( \"Hello, World!\" s ); // `maybe::map` takes self *by ref*, // *not* consuming `maybe_some_string` maybe maybe_some_len = maybe_some_string . map ( & std :: string :: size ); assert ( maybe_some_len == just ( 13u )); } // end example map_or \u00b6 maybe<T>::map_or(T def, F f) -> T template < class T > class maybe { template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &>>> map_or ( U && def , F && f ) & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T const &>>> map_or ( U && def , F && f ) const & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &&>>> map_or ( U && def , F && f ) && ; }; Applies a function to the contained value (if any), or returns the provided default (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . map_or ( 42 , & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or ( 42 , & std :: string :: size ) == 42 ); } // end example map_or_else \u00b6 maybe<T>::map_or_else(D def, F f) -> U where D: () -> U, F: T -> U, template < class T > class maybe { template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>> map_or_else ( D && def , F && f ) & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>> map_or_else ( D && def , F && f ) const & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>> map_or_else ( D && def , F && f ) && ; }; Applies a function to the contained value (if any), or computes a default (if not). Examples // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { int k = 21 ; maybe x = just ( \"foo\" s ); assert ( x . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 42 ); } // end example ok_or \u00b6 maybe<T>::ok_or(E err) -> result template < class T > class maybe { template < class E > auto maybe < T >:: ok_or ( E && err ) const & -> result < T , E > ; template < class E > auto maybe < T >:: ok_or ( E && err ) && -> result < std :: remove_reference_t < T > , E > ; auto maybe < T >:: ok_or () const & -> result < T , std :: monostate > ; auto maybe < T >:: ok_or () && -> result < std :: remove_reference_t < T > , std :: monostate > ; }; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ) . Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or ( 0 ) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or ( 0 ) == failure ( 0 )); assert ( y . ok_or () == failure <> ()); } // end example ok_or_else \u00b6 maybe<T>::ok_or_else(F f) -> result<T, E> where F: () -> E template < class T > class maybe { template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < T , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) const & ; template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < std :: remove_reference_t < T > , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) && ; }; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ()) . Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or_else ([]{ return 0 ; }) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or_else ([]{ return 0 ; }) == failure ( 0 )); } // end example conj \u00b6 maybe<T>::conj(maybe<U>) -> maybe>U> template < class T > class maybe { template < class U > auto maybe < T >:: conj ( maybe < U > const & rhs ) -> maybe < U > ; }; Returns nothing if the lhs is nothing , otherwise returns rhs . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } { maybe < int > x = nothing ; maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == nothing ); } { maybe x = just ( 2 ); maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == just ( \"foo\" s )); } { maybe < int > x = nothing ; maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } } // end example and_then \u00b6 maybe<T>::and_then(F f) -> maybe<U> where F: T -> maybe<U> template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T const &>>>> , std :: invoke_result_t < F && , T const &> > and_then ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &&>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) && ; }; Returns nothing if the option is nothing , otherwise invokes f with the wrapped value and returns the result. Some languages call this operation flatmap. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto sq = []( int x ) -> maybe < int > { return just ( x * x ); }; auto nope = [](...) -> maybe < int > { return nothing ; }; assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( sq ) == just ( 16 )); assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( nope ) == nothing ); assert ( maybe { just ( 2 )}. and_then ( nope ). and_then ( sq ) == nothing ); assert ( nope (). and_then ( sq ). and_then ( sq ) == nothing ); } // end example filter \u00b6 maybe<T>::filter(Pred predicate) -> maybe<T> template < class T > class maybe { template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T const &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) const & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &&> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) && ; }; Returns nothing if the option is nothing , otherwise invokes predicate with the wrapped value and returns: just ( t ) if predicate returns true (where t is the wrapped value), and nothing if predicate returns false. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto is_even = []( int n ) -> bool { return n % 2 == 0 ; }; assert ( maybe < int > {}. filter ( is_even ) == nothing ); assert ( maybe { just ( 3 )}. filter ( is_even ) == nothing ); assert ( maybe { just ( 4 )}. filter ( is_even ) == just ( 4 )); } // end example disj \u00b6 maybe<T>::disj(maybe<T>) -> maybe>T> template < class T > class maybe { auto maybe < T >:: disj ( maybe < T > const & rhs ) -> maybe < T > ; }; Returns the maybe if it contains a value, otherwise returns rhs. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); maybe < int > y = nothing ; assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 100 )); } { maybe x = just ( 2 ); maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe < int > y = nothing ; assert ( x . disj ( y ) == nothing ); } } // end example or_else \u00b6 maybe<T>::or_else(F f) -> maybe<T> where F: () -> maybe<T> template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) && ; }; Returns the maybe if it contains a value, otherwise invokes f and returns the result. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto nobody = []() -> maybe < std :: string > { return nothing ; }; auto vikings = []() -> maybe < std :: string > { return just ( \"vikings\" s ); }; assert ( maybe { just ( \"barbarians\" s )}. or_else ( vikings ) == just ( \"barbarians\" s )); assert ( maybe < std :: string > {}. or_else ( vikings ) == just ( \"vikings\" s )); assert ( maybe < std :: string > {}. or_else ( nobody ) == nothing ); } // end example get_or_emplace \u00b6 maybe<T>::get_or_emplace(Args... args) -> T& template < class T > class maybe { template < class ... Args > std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , T &> get_or_emplace ( Args && ... args ) & ; }; Emplace constructs T into the maybe with expression std :: forward < Args > ( args )... if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; struct noncopyable { noncopyable () = default ; noncopyable ( noncopyable const & ) = delete ; noncopyable & operator = ( noncopyable const & ) = delete ; noncopyable ( noncopyable && ) = default ; noncopyable & operator = ( noncopyable && ) = default ; bool operator == ( noncopyable && ) & { return true ; } bool operator == ( noncopyable && ) const & { return true ; } bool operator == ( noncopyable const & ) & { return true ; } bool operator == ( noncopyable const & ) const & { return true ; } }; int main () { maybe < noncopyable > x = nothing ; auto & y = x . get_or_emplace ( noncopyable {}); assert ( y == noncopyable {}); } // end example get_or_emplace_with \u00b6 maybe<T>::get_or_emplace_with(F f,Args... args) -> T& template < class T > class maybe { template < class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , Args && ... > , std :: is_constructible < T , std :: invoke_result_t < F && , Args && ... >>> , T &> get_or_emplace_with ( F && f , Args && ... args ) & ; }; Emplace constructs T into the maybe with expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < int > x = nothing ; std :: ignore = x . get_or_emplace_with ([]{ return 5 ; }); std :: ignore = x . get_or_emplace_with ([]( auto x ){ return x ; }, 5 ); auto & y = x . get_or_emplace_with ( & std :: string :: size , \"12345\" s ); assert ( y == 5 ); y = 7 ; assert ( x == just ( 7 )); } // end example replace \u00b6 maybe<T>::replace(Args... args) -> maybe<T> where T is constructible from (Args...) template < class T > class maybe { maybe < T > replace ( Args && ... args ) & ; }; Replaces the actual value in the maybe by expression std :: forward < Args > ( args )... , returning the old value if present, leaving a just value in its place without deinitializing either one. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); auto old = x . replace ( 5 ); assert ( x == just ( 5 )); assert ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace ( 3 ); assert ( x == just ( 3 )); assert ( old == nothing ); } } // end example replace_with \u00b6 maybe<T>::replace_with(F f, Args... args) -> maybe<T> where T is constructible from F(Args...) template < class T > class maybe { template < class F , class ... Args > maybe < T > replace_with ( F && f , Args && ... args ) & ; }; Replaces the actual value in the maybe by expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) , returning the old value if present, leaving a just value in its place without deinitializing either one. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); auto old = x . replace_with ([]{ return 5 ; }); assert ( x == just ( 5 )); assert ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace_with ( & std :: string :: size , \"foo\" s ); assert ( x == just ( 3 )); assert ( old == nothing ); } } // end example cloned \u00b6 maybe<T&>::cloned() -> maybe<T> where T is copyable template < class T > class maybe { auto maybe < T &>:: cloned () & -> maybe < T > ; }; Maps a maybe < T &> to a maybe < T > by deep copying the contents of the maybe. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int x = 12 ; maybe < int &> opt_x = x ; assert ( opt_x == just ( 12 )); assert ( & ( opt_x . unwrap ()) == & x ); auto shallow_copied = opt_x ; assert ( & ( shallow_copied . unwrap ()) == & x ); auto cloned = opt_x . cloned (); assert ( cloned == just ( 12 )); assert ( & ( cloned . unwrap ()) != & x ); } // end example unwrap_or_default \u00b6 maybe<T>::unwrap_or_default() -> T template < class T > class maybe { auto maybe < T >:: unwrap_or_default () const & -> std :: remove_reference_t < T > ; }; Returns the contained value or a default. If just , returns the contained value, otherwise if nothing , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < std :: string > x = nothing ; assert ( x . unwrap_or_default () == \"\" s ); } // end example transpose \u00b6 maybe<basic_result<_, T, E>>::transpose() -> basic_result<_, maybe<T>, E> template < class T > class maybe { maybe < basic_result < _ , T , E >>:: transpose () const & -> basic_result < _ , maybe < T > , E > ; }; Transposes a maybe of a result into a result of a maybe . nothing will be mapped to success ( nothing ) . just ( success ( _ )) and just ( failure ( _ )) will be mapped to success ( just ( _ )) and failure ( _ ) \u3000(_ is a placeholder). Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); assert ( x == y . transpose ()); } // end example flatten \u00b6 maybe<maybe<T>>::flatten() -> maybe<T> template < class T > class maybe { auto maybe < maybe < T >>:: transpose () -> maybe < T > ; }; Converts from maybe < maybe < T >> to maybe < T > . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < maybe < int >> x = just ( just ( 6 )); assert ( just ( 6 ) == x . flatten ()); maybe < maybe < int >> y = just ( nothing ); assert ( nothing == y . flatten ()); maybe < maybe < int >> z = nothing ; assert ( nothing == z . flatten ()); // Flattening once only removes one level of nesting: maybe < maybe < maybe < int >>> nest = just ( just ( just ( 6 ))); assert ( just ( 6 ) == nest . flatten (). flatten ()); } // end example and_finally \u00b6 maybe<T>::and_finally(F f) -> void where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >>> and_finally ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >>> and_finally ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >>> and_finally ( F && f ) && ; }; Invokes the provided function with the contained value (if any), or doing nothing (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example or_finally \u00b6 maybe<T>::or_finally(F f) -> void where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) && ; }; Invokes the provided function (if nothing), or doing nothing (if any). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example and_peek \u00b6 maybe<T>::and_peek(F f) -> maybe<T> where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , maybe &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , maybe const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , maybe &&> and_peek ( F && f ) && ; }; Peeks the contained value if self is just , then returns self. Invokes the provided function with the contained value and then returns self (if any), or returns self without doing anything (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example or_peek \u00b6 maybe<T>::or_peek(F f) -> maybe<T> where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &> or_peek ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe const &> or_peek ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &&> or_peek ( F && f ) && ; }; Invokes the provided function and then returns self (if nothing), or returns self without doing anything (if any). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example range_to_maybe \u00b6 range_to_maybe(Range range) -> maybe<Range::Item> In header < mitama / maybe / range_to_maybe . hpp > . template < class Range > auto range_to_maybe ( Range && range ) -> maybe < decltype ( * begin ( range )) > ; The range_to_maybe function returns nothing on an empty range or just ( v ) where v is the first element of the range . Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/maybe/range_to_maybe.hpp> #include <cassert> using namespace mitama ; int main () { std :: vector v { 1 , 2 , 3 }; maybe x = range_to_maybe ( v ); assert ( x == just ( 1 )); maybe y = range_to_maybe ( std :: vector < int > {}); assert ( y == nothing ); int a [] = { 1 }; maybe z = range_to_maybe ( a ); assert ( z == 1 ); } // end example","title":"API Reference"},{"location":"maybe/APIs/#is_just","text":"maybe<T>::is_just() -> bool template < class T > class maybe { constexpr bool maybe < T >:: is_just () const noexcept ; }; Returns true if the maybe has some value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( x . is_just () ); maybe < int > y = nothing ; assert ( ! y . is_just () ); } // end example","title":"is_just"},{"location":"maybe/APIs/#is_nothing","text":"maybe<T>::is_nothing() -> bool template < class T > class maybe { constexpr bool maybe < T >:: is_nothing () const noexcept ; }; Returns true if the maybe is a nothing value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( ! x . is_nothing () ); maybe < int > y = nothing ; assert ( y . is_nothing () ); } // end example","title":"is_nothing"},{"location":"maybe/APIs/#as_ref","text":"maybe<T>::as_ref() -> maybe<T&> template < class T > class maybe { auto maybe < T >:: as_ref () & -> maybe < T &> ; auto maybe < T >:: as_ref () const & -> maybe < const T &> ; }; Converts from maybe < T >& to maybe < T &> . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> #include <iostream> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe text = just ( \"Hello, world!\" s ); // First, cast `maybe<T>` to `maybe<T&>` with `as_ref`, auto text_length = text . as_ref (). map ( & std :: string :: size ); std :: cout << \"still can print text: \" << text << \" \\n \" ; } // end example","title":"as_ref"},{"location":"maybe/APIs/#expect","text":"maybe<T>::expect(std::string_view msg) -> T& template < class T > class maybe { auto maybe < T >:: expect ( std :: string_view msg ) & -> T & ; auto maybe < T >:: expect ( std :: string_view msg ) const & -> T const & ; auto maybe < T >:: expect ( std :: string_view msg ) && -> T && ; }; Unwraps a maybe, yielding the content of a just . Exception Raise mitama :: runtime_panic if the value is a nothing with a custom panic message provided by msg . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"value\" s ); assert ( x . expect ( \"the world is ending\" ) == \"value\" s ); } try { maybe < int > x = nothing ; x . expect ( \"the world is ending\" ); // panics with `the world is ending` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'the world is ending' } } // end example","title":"expect"},{"location":"maybe/APIs/#unwrap","text":"maybe<T>::unwrap() -> T& template < class T > class maybe { auto maybe < T >:: unwrap () & -> T & ; auto maybe < T >:: unwrap () const & -> T const & ; auto maybe < T >:: unwrap () && -> T && ; }; Unwraps a maybe, yielding the content of a just . Exception Raise mitama :: runtime_panic if a maybe has not just value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"air\" s ); assert ( x . unwrap () == \"air\" s ); } try { maybe < int > x = nothing ; x . unwrap (); // raise an exception } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'called `maybe::unwrap()` on a `nothing` value' } } // end example","title":"unwrap"},{"location":"maybe/APIs/#unwrap_or","text":"maybe<T>::unwrap_or(T def) -> T template < class T > class maybe { template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T & , U &&>>:: value , std :: common_type_t < T & , U &&>> maybe < T >:: unwrap_or ( U && def ) & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T const & , U &&>>:: value , std :: common_type_t < T const & , U &&>> maybe < T >:: unwrap_or ( U && def ) const & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T && , U &&>>:: value , std :: common_type_t < T && , U &&>> maybe < T >:: unwrap_or ( U && def ) && ; }; Returns the contained value or a default. Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { assert ( maybe { just ( \"car\" s )}. unwrap_or ( \"bike\" s ) == \"car\" s ); assert ( maybe < std :: string > { nothing }. unwrap_or ( \"bike\" s ) == \"bike\" s ); } // end example","title":"unwrap_or"},{"location":"maybe/APIs/#unwrap_or_else","text":"maybe<T>::unwrap_or_else(F f) -> T where F: () -> T template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T const & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T const & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T && , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T && , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) && ; }; Returns the contained value or computes it from a invocable object op . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int k = 10 ; assert ( maybe { just ( 4 )}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 4 ); assert ( maybe < int > {}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 20 ); } // end example","title":"unwrap_or_else"},{"location":"maybe/APIs/#map","text":"maybe<T>::map(F f) -> maybe<T> where F: T -> U template < class T > class maybe { template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &> , bool > = false > auto maybe < T >:: map ( F && f ) & -> maybe < std :: invoke_result_t < F && , T &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T const &> , bool > = false > auto maybe < T >:: map ( F && f ) const & -> maybe < std :: invoke_result_t < F && , T const &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &&> , bool > = false > auto maybe < T >:: map ( F && f ) && -> maybe < std :: invoke_result_t < F && , T &&>> ; }; Maps a maybe < T > to maybe < U > by applying a function to a contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe maybe_some_string = just ( \"Hello, World!\" s ); // `maybe::map` takes self *by ref*, // *not* consuming `maybe_some_string` maybe maybe_some_len = maybe_some_string . map ( & std :: string :: size ); assert ( maybe_some_len == just ( 13u )); } // end example","title":"map"},{"location":"maybe/APIs/#map_or","text":"maybe<T>::map_or(T def, F f) -> T template < class T > class maybe { template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &>>> map_or ( U && def , F && f ) & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T const &>>> map_or ( U && def , F && f ) const & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &&>>> map_or ( U && def , F && f ) && ; }; Applies a function to the contained value (if any), or returns the provided default (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . map_or ( 42 , & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or ( 42 , & std :: string :: size ) == 42 ); } // end example","title":"map_or"},{"location":"maybe/APIs/#map_or_else","text":"maybe<T>::map_or_else(D def, F f) -> U where D: () -> U, F: T -> U, template < class T > class maybe { template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>> map_or_else ( D && def , F && f ) & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>> map_or_else ( D && def , F && f ) const & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>> map_or_else ( D && def , F && f ) && ; }; Applies a function to the contained value (if any), or computes a default (if not). Examples // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { int k = 21 ; maybe x = just ( \"foo\" s ); assert ( x . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 42 ); } // end example","title":"map_or_else"},{"location":"maybe/APIs/#ok_or","text":"maybe<T>::ok_or(E err) -> result template < class T > class maybe { template < class E > auto maybe < T >:: ok_or ( E && err ) const & -> result < T , E > ; template < class E > auto maybe < T >:: ok_or ( E && err ) && -> result < std :: remove_reference_t < T > , E > ; auto maybe < T >:: ok_or () const & -> result < T , std :: monostate > ; auto maybe < T >:: ok_or () && -> result < std :: remove_reference_t < T > , std :: monostate > ; }; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ) . Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or ( 0 ) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or ( 0 ) == failure ( 0 )); assert ( y . ok_or () == failure <> ()); } // end example","title":"ok_or"},{"location":"maybe/APIs/#ok_or_else","text":"maybe<T>::ok_or_else(F f) -> result<T, E> where F: () -> E template < class T > class maybe { template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < T , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) const & ; template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < std :: remove_reference_t < T > , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) && ; }; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ()) . Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or_else ([]{ return 0 ; }) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or_else ([]{ return 0 ; }) == failure ( 0 )); } // end example","title":"ok_or_else"},{"location":"maybe/APIs/#conj","text":"maybe<T>::conj(maybe<U>) -> maybe>U> template < class T > class maybe { template < class U > auto maybe < T >:: conj ( maybe < U > const & rhs ) -> maybe < U > ; }; Returns nothing if the lhs is nothing , otherwise returns rhs . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } { maybe < int > x = nothing ; maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == nothing ); } { maybe x = just ( 2 ); maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == just ( \"foo\" s )); } { maybe < int > x = nothing ; maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } } // end example","title":"conj"},{"location":"maybe/APIs/#and_then","text":"maybe<T>::and_then(F f) -> maybe<U> where F: T -> maybe<U> template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T const &>>>> , std :: invoke_result_t < F && , T const &> > and_then ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &&>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) && ; }; Returns nothing if the option is nothing , otherwise invokes f with the wrapped value and returns the result. Some languages call this operation flatmap. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto sq = []( int x ) -> maybe < int > { return just ( x * x ); }; auto nope = [](...) -> maybe < int > { return nothing ; }; assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( sq ) == just ( 16 )); assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( nope ) == nothing ); assert ( maybe { just ( 2 )}. and_then ( nope ). and_then ( sq ) == nothing ); assert ( nope (). and_then ( sq ). and_then ( sq ) == nothing ); } // end example","title":"and_then"},{"location":"maybe/APIs/#filter","text":"maybe<T>::filter(Pred predicate) -> maybe<T> template < class T > class maybe { template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T const &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) const & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &&> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) && ; }; Returns nothing if the option is nothing , otherwise invokes predicate with the wrapped value and returns: just ( t ) if predicate returns true (where t is the wrapped value), and nothing if predicate returns false. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto is_even = []( int n ) -> bool { return n % 2 == 0 ; }; assert ( maybe < int > {}. filter ( is_even ) == nothing ); assert ( maybe { just ( 3 )}. filter ( is_even ) == nothing ); assert ( maybe { just ( 4 )}. filter ( is_even ) == just ( 4 )); } // end example","title":"filter"},{"location":"maybe/APIs/#disj","text":"maybe<T>::disj(maybe<T>) -> maybe>T> template < class T > class maybe { auto maybe < T >:: disj ( maybe < T > const & rhs ) -> maybe < T > ; }; Returns the maybe if it contains a value, otherwise returns rhs. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); maybe < int > y = nothing ; assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 100 )); } { maybe x = just ( 2 ); maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe < int > y = nothing ; assert ( x . disj ( y ) == nothing ); } } // end example","title":"disj"},{"location":"maybe/APIs/#or_else","text":"maybe<T>::or_else(F f) -> maybe<T> where F: () -> maybe<T> template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) && ; }; Returns the maybe if it contains a value, otherwise invokes f and returns the result. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto nobody = []() -> maybe < std :: string > { return nothing ; }; auto vikings = []() -> maybe < std :: string > { return just ( \"vikings\" s ); }; assert ( maybe { just ( \"barbarians\" s )}. or_else ( vikings ) == just ( \"barbarians\" s )); assert ( maybe < std :: string > {}. or_else ( vikings ) == just ( \"vikings\" s )); assert ( maybe < std :: string > {}. or_else ( nobody ) == nothing ); } // end example","title":"or_else"},{"location":"maybe/APIs/#get_or_emplace","text":"maybe<T>::get_or_emplace(Args... args) -> T& template < class T > class maybe { template < class ... Args > std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , T &> get_or_emplace ( Args && ... args ) & ; }; Emplace constructs T into the maybe with expression std :: forward < Args > ( args )... if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; struct noncopyable { noncopyable () = default ; noncopyable ( noncopyable const & ) = delete ; noncopyable & operator = ( noncopyable const & ) = delete ; noncopyable ( noncopyable && ) = default ; noncopyable & operator = ( noncopyable && ) = default ; bool operator == ( noncopyable && ) & { return true ; } bool operator == ( noncopyable && ) const & { return true ; } bool operator == ( noncopyable const & ) & { return true ; } bool operator == ( noncopyable const & ) const & { return true ; } }; int main () { maybe < noncopyable > x = nothing ; auto & y = x . get_or_emplace ( noncopyable {}); assert ( y == noncopyable {}); } // end example","title":"get_or_emplace"},{"location":"maybe/APIs/#get_or_emplace_with","text":"maybe<T>::get_or_emplace_with(F f,Args... args) -> T& template < class T > class maybe { template < class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , Args && ... > , std :: is_constructible < T , std :: invoke_result_t < F && , Args && ... >>> , T &> get_or_emplace_with ( F && f , Args && ... args ) & ; }; Emplace constructs T into the maybe with expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < int > x = nothing ; std :: ignore = x . get_or_emplace_with ([]{ return 5 ; }); std :: ignore = x . get_or_emplace_with ([]( auto x ){ return x ; }, 5 ); auto & y = x . get_or_emplace_with ( & std :: string :: size , \"12345\" s ); assert ( y == 5 ); y = 7 ; assert ( x == just ( 7 )); } // end example","title":"get_or_emplace_with"},{"location":"maybe/APIs/#replace","text":"maybe<T>::replace(Args... args) -> maybe<T> where T is constructible from (Args...) template < class T > class maybe { maybe < T > replace ( Args && ... args ) & ; }; Replaces the actual value in the maybe by expression std :: forward < Args > ( args )... , returning the old value if present, leaving a just value in its place without deinitializing either one. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); auto old = x . replace ( 5 ); assert ( x == just ( 5 )); assert ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace ( 3 ); assert ( x == just ( 3 )); assert ( old == nothing ); } } // end example","title":"replace"},{"location":"maybe/APIs/#replace_with","text":"maybe<T>::replace_with(F f, Args... args) -> maybe<T> where T is constructible from F(Args...) template < class T > class maybe { template < class F , class ... Args > maybe < T > replace_with ( F && f , Args && ... args ) & ; }; Replaces the actual value in the maybe by expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) , returning the old value if present, leaving a just value in its place without deinitializing either one. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); auto old = x . replace_with ([]{ return 5 ; }); assert ( x == just ( 5 )); assert ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace_with ( & std :: string :: size , \"foo\" s ); assert ( x == just ( 3 )); assert ( old == nothing ); } } // end example","title":"replace_with"},{"location":"maybe/APIs/#cloned","text":"maybe<T&>::cloned() -> maybe<T> where T is copyable template < class T > class maybe { auto maybe < T &>:: cloned () & -> maybe < T > ; }; Maps a maybe < T &> to a maybe < T > by deep copying the contents of the maybe. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int x = 12 ; maybe < int &> opt_x = x ; assert ( opt_x == just ( 12 )); assert ( & ( opt_x . unwrap ()) == & x ); auto shallow_copied = opt_x ; assert ( & ( shallow_copied . unwrap ()) == & x ); auto cloned = opt_x . cloned (); assert ( cloned == just ( 12 )); assert ( & ( cloned . unwrap ()) != & x ); } // end example","title":"cloned"},{"location":"maybe/APIs/#unwrap_or_default","text":"maybe<T>::unwrap_or_default() -> T template < class T > class maybe { auto maybe < T >:: unwrap_or_default () const & -> std :: remove_reference_t < T > ; }; Returns the contained value or a default. If just , returns the contained value, otherwise if nothing , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < std :: string > x = nothing ; assert ( x . unwrap_or_default () == \"\" s ); } // end example","title":"unwrap_or_default"},{"location":"maybe/APIs/#transpose","text":"maybe<basic_result<_, T, E>>::transpose() -> basic_result<_, maybe<T>, E> template < class T > class maybe { maybe < basic_result < _ , T , E >>:: transpose () const & -> basic_result < _ , maybe < T > , E > ; }; Transposes a maybe of a result into a result of a maybe . nothing will be mapped to success ( nothing ) . just ( success ( _ )) and just ( failure ( _ )) will be mapped to success ( just ( _ )) and failure ( _ ) \u3000(_ is a placeholder). Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); assert ( x == y . transpose ()); } // end example","title":"transpose"},{"location":"maybe/APIs/#flatten","text":"maybe<maybe<T>>::flatten() -> maybe<T> template < class T > class maybe { auto maybe < maybe < T >>:: transpose () -> maybe < T > ; }; Converts from maybe < maybe < T >> to maybe < T > . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < maybe < int >> x = just ( just ( 6 )); assert ( just ( 6 ) == x . flatten ()); maybe < maybe < int >> y = just ( nothing ); assert ( nothing == y . flatten ()); maybe < maybe < int >> z = nothing ; assert ( nothing == z . flatten ()); // Flattening once only removes one level of nesting: maybe < maybe < maybe < int >>> nest = just ( just ( just ( 6 ))); assert ( just ( 6 ) == nest . flatten (). flatten ()); } // end example","title":"flatten"},{"location":"maybe/APIs/#and_finally","text":"maybe<T>::and_finally(F f) -> void where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >>> and_finally ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >>> and_finally ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >>> and_finally ( F && f ) && ; }; Invokes the provided function with the contained value (if any), or doing nothing (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example","title":"and_finally"},{"location":"maybe/APIs/#or_finally","text":"maybe<T>::or_finally(F f) -> void where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) && ; }; Invokes the provided function (if nothing), or doing nothing (if any). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":"or_finally"},{"location":"maybe/APIs/#and_peek","text":"maybe<T>::and_peek(F f) -> maybe<T> where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , maybe &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , maybe const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , maybe &&> and_peek ( F && f ) && ; }; Peeks the contained value if self is just , then returns self. Invokes the provided function with the contained value and then returns self (if any), or returns self without doing anything (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example","title":"and_peek"},{"location":"maybe/APIs/#or_peek","text":"maybe<T>::or_peek(F f) -> maybe<T> where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &> or_peek ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe const &> or_peek ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &&> or_peek ( F && f ) && ; }; Invokes the provided function and then returns self (if nothing), or returns self without doing anything (if any). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":"or_peek"},{"location":"maybe/APIs/#range_to_maybe","text":"range_to_maybe(Range range) -> maybe<Range::Item> In header < mitama / maybe / range_to_maybe . hpp > . template < class Range > auto range_to_maybe ( Range && range ) -> maybe < decltype ( * begin ( range )) > ; The range_to_maybe function returns nothing on an empty range or just ( v ) where v is the first element of the range . Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/maybe/range_to_maybe.hpp> #include <cassert> using namespace mitama ; int main () { std :: vector v { 1 , 2 , 3 }; maybe x = range_to_maybe ( v ); assert ( x == just ( 1 )); maybe y = range_to_maybe ( std :: vector < int > {}); assert ( y == nothing ); int a [] = { 1 }; maybe z = range_to_maybe ( a ); assert ( z == 1 ); } // end example","title":"range_to_maybe"},{"location":"maybe/comparisons/","text":"operator==, !=, <, <=, >, >=(maybe) \u00b6 namespace mitama { // Compare two maybe objects template < class T , class U > constexpr bool operator == ( const maybe < T >& lhs , const maybe < U >& rhs ); // (1) template < class T , class U > constexpr bool operator != ( const maybe < T >& lhs , const maybe < U >& rhs ); // (2) template < class T , class U > constexpr bool operator < ( const maybe < T >& lhs , const maybe < U >& rhs ); // (3) template < class T , class U > constexpr bool operator <= ( const maybe < T >& lhs , const maybe < U >& rhs ); // (4) template < class T , class U > constexpr bool operator > ( const maybe < T >& lhs , const maybe < U >& rhs ); // (5) template < class T , class U > constexpr bool operator >= ( const maybe < T >& lhs , const maybe < U >& rhs ); // (6) // Compare a maybe object with a nothing template < class T > constexpr bool operator == ( const maybe < T >& opt , nothing_t ) noexcept ; // (7) template < class T > constexpr bool operator == ( nothing_t , const maybe < T >& opt ) noexcept ; // (8) template < class T > constexpr bool operator != ( const maybe < T >& opt , nothing_t ) noexcept ; // (9) template < class T > constexpr bool operator != ( nothing_t , const maybe < T >& opt ) noexcept ; // (10) template < class T > constexpr bool operator < ( const maybe < T >& opt , nothing_t ) noexcept ; // (11) template < class T > constexpr bool operator < ( nothing_t , const maybe < T >& opt ) noexcept ; // (12) template < class T > constexpr bool operator <= ( const maybe < T >& opt , nothing_t ) noexcept ; // (13) template < class T > constexpr bool operator <= ( nothing_t , const maybe < T >& opt ) noexcept ; // (14) template < class T > constexpr bool operator > ( const maybe < T >& opt , nothing_t ) noexcept ; // (15) template < class T > constexpr bool operator > ( nothing_t , const maybe < T >& opt ) noexcept ; // (16) template < class T > constexpr bool operator >= ( const maybe < T >& opt , nothing_t ) noexcept ; // (17) template < class T > constexpr bool operator >= ( nothing_t , const maybe < T >& opt ) noexcept ; // (18) // Compare a maybe object with a just(value) template < class T , class U > constexpr bool operator == ( const maybe < T >& opt , just_t < U > const & some ); // (19) template < class T , class U > constexpr bool operator == ( just_t < T > const & some , const maybe < U >& opt ); // (20) template < class T , class U > constexpr bool operator != ( const maybe < T >& opt , just_t < U > const & some ); // (21) template < class T , class U > constexpr bool operator != ( just_t < T > const & some , const maybe < U >& opt ); // (22) template < class T , class U > constexpr bool operator < ( const maybe < T >& opt , just_t < U > const & some ); // (23) template < class T , class U > constexpr bool operator < ( just_t < T > const & some , const maybe < U >& opt ); // (24) template < class T , class U > constexpr bool operator <= ( const maybe < T >& opt , just_t < U > const & some ); // (25) template < class T , class U > constexpr bool operator <= ( just_t < T > const & some , const maybe < U >& opt ); // (26) template < class T , class U > constexpr bool operator > ( const maybe < T >& opt , just_t < U > const & some ); // (27) template < class T , class U > constexpr bool operator > ( just_t < T > const & some , const maybe < U >& opt ); // (28) template < class T , class U > constexpr bool operator >= ( const maybe < T >& opt , just_t < U > const & some ); // (29) template < class T , class U > constexpr bool operator >= ( just_t < T > const & some , const maybe < U >& opt ); // (30) // Compare a maybe object with a T template < class T , class U > constexpr bool operator == ( const maybe < T >& opt , const U & value ); // (31) template < class T , class U > constexpr bool operator == ( const T & value , const maybe < U >& opt ); // (32) template < class T , class U > constexpr bool operator != ( const maybe < T >& opt , const U & value ); // (33) template < class T , class U > constexpr bool operator != ( const T & value , const maybe < U >& opt ); // (34) template < class T , class U > constexpr bool operator < ( const maybe < T >& opt , const U & value ); // (35) template < class T , class U > constexpr bool operator < ( const T & value , const maybe < U >& opt ); // (36) template < class T , class U > constexpr bool operator <= ( const maybe < T >& opt , const U & value ); // (37) template < class T , class U > constexpr bool operator <= ( const T & value , const maybe < U >& opt ); // (38) template < class T , class U > constexpr bool operator > ( const maybe < T >& opt , const U & value ); // (39) template < class T , class U > constexpr bool operator > ( const T & value , const maybe < U >& opt ); // (40) template < class T , class U > constexpr bool operator >= ( const maybe < T >& opt , const U & value ); // (41) template < class T , class U > constexpr bool operator >= ( const T & value , const maybe < U >& opt ); // (42) } Performs comparison operations on maybe objects. 1-6) Compares two maybe objects, lhs and rhs . The contained values are compared (using the corresponding operator of T and U ) only if both lhs and rhs contain values. Otherwise, lhs is considered equal to rhs if, and only if, both lhs and rhs do not contain a value. lhs is considered less than rhs if, and only if, rhs contains a value and lhs does not. 7-18) Compares opt with a nothing . Equivalent to (1-6) when comparing to a maybe that does not contain a value. 19-30) Compares opt with a some : = just_t ( value ) . The values are compared (using the corresponding operator of T ) only if opt contains a value. Otherwise, opt is considered less than some . If the corresponding comparison expression between opt . unwrap () and value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 31-42) Compares opt with a value . Equivalent to (19-30) expression opt ~ just ( value ) . Parameters lhs , rhs , opt - a maybe object to compare some - a just_t object to compare value - value to compare to the contained value Return value If bool ( lhs ) != bool ( rhs ) , returns false Otherwise, if bool ( lhs ) == false (and so bool ( rhs ) == false as well), returns true Otherwise, returns lhs . unwrap () == rhs . unwrap () . If bool ( lhs ) != bool ( rhs ) , returns true Otherwise, if bool ( lhs ) == false (and so bool ( rhs ) == false as well), returns false Otherwise, returns lhs . unwrap () != rhs . unwrap () . If bool ( rhs ) == false returns false Otherwise, if bool ( lhs ) == false , returns true Otherwise returns lhs . unwrap () < rhs . unwrap () . If bool ( lhs ) == false returns true Otherwise, if bool ( rhs ) == false , returns false Otherwise returns lhs . unwrap () <= rhs . unwrap () . If bool ( lhs ) == false returns false Otherwise, if bool ( rhs ) == false , returns true Otherwise returns lhs . unwrap () > rhs . unwrap () . If bool ( rhs ) == false returns true Otherwise, if bool ( lhs ) == false , returns false Otherwise returns lhs . unwrap () >= rhs . unwrap () . Returns opt . is_nothing () . Returns opt . is_nothing () . Returns opt . is_just () . Returns opt . is_just () . Returns false . Returns opt . is_just () . Returns opt . is_nothing () . Returns true . Returns opt . is_just () . Returns false . Returns true . Returns opt . is_nothing () . Returns opt . is_just () ? opt . unwrap () == some . value : false . Returns opt . is_just () ? some . value == opt . unwrap () : false . Returns opt . is_just () ? opt . unwrap () != some . value : true . Returns opt . is_just () ? some . value != opt . unwrap () : true . Returns opt . is_just () ? opt . unwrap () < some . value : true . Returns opt . is_just () ? some . value < opt . unwrap () : false . Returns opt . is_just () ? opt . unwrap () <= some . value : true . Returns opt . is_just () ? some . value <= opt . unwrap () : false . Returns opt . is_just () ? opt . unwrap () > some . value : false . Returns opt . is_just () ? some . value > opt . unwrap () : true . Returns opt . is_just () ? opt . unwrap () >= some . value : false . Returns opt . is_just () ? some . value >= opt . unwrap () : true . Returns opt == just ( value ) . Returns just ( value ) == opt . Returns opt != just ( value ) . Returns just ( value ) != opt . Returns opt < just ( value ) . Returns just ( value ) < opt . Returns opt <= just ( value ) . Returns just ( value ) <= opt . Returns opt > just ( value ) . Returns just ( value ) > opt . Returns opt >= just ( value ) . Returns just ( value ) >= opt . Note some . value : value is a private member of just_t (actually, cannot access to it).","title":"Comparisons"},{"location":"maybe/comparisons/#operator_maybe","text":"namespace mitama { // Compare two maybe objects template < class T , class U > constexpr bool operator == ( const maybe < T >& lhs , const maybe < U >& rhs ); // (1) template < class T , class U > constexpr bool operator != ( const maybe < T >& lhs , const maybe < U >& rhs ); // (2) template < class T , class U > constexpr bool operator < ( const maybe < T >& lhs , const maybe < U >& rhs ); // (3) template < class T , class U > constexpr bool operator <= ( const maybe < T >& lhs , const maybe < U >& rhs ); // (4) template < class T , class U > constexpr bool operator > ( const maybe < T >& lhs , const maybe < U >& rhs ); // (5) template < class T , class U > constexpr bool operator >= ( const maybe < T >& lhs , const maybe < U >& rhs ); // (6) // Compare a maybe object with a nothing template < class T > constexpr bool operator == ( const maybe < T >& opt , nothing_t ) noexcept ; // (7) template < class T > constexpr bool operator == ( nothing_t , const maybe < T >& opt ) noexcept ; // (8) template < class T > constexpr bool operator != ( const maybe < T >& opt , nothing_t ) noexcept ; // (9) template < class T > constexpr bool operator != ( nothing_t , const maybe < T >& opt ) noexcept ; // (10) template < class T > constexpr bool operator < ( const maybe < T >& opt , nothing_t ) noexcept ; // (11) template < class T > constexpr bool operator < ( nothing_t , const maybe < T >& opt ) noexcept ; // (12) template < class T > constexpr bool operator <= ( const maybe < T >& opt , nothing_t ) noexcept ; // (13) template < class T > constexpr bool operator <= ( nothing_t , const maybe < T >& opt ) noexcept ; // (14) template < class T > constexpr bool operator > ( const maybe < T >& opt , nothing_t ) noexcept ; // (15) template < class T > constexpr bool operator > ( nothing_t , const maybe < T >& opt ) noexcept ; // (16) template < class T > constexpr bool operator >= ( const maybe < T >& opt , nothing_t ) noexcept ; // (17) template < class T > constexpr bool operator >= ( nothing_t , const maybe < T >& opt ) noexcept ; // (18) // Compare a maybe object with a just(value) template < class T , class U > constexpr bool operator == ( const maybe < T >& opt , just_t < U > const & some ); // (19) template < class T , class U > constexpr bool operator == ( just_t < T > const & some , const maybe < U >& opt ); // (20) template < class T , class U > constexpr bool operator != ( const maybe < T >& opt , just_t < U > const & some ); // (21) template < class T , class U > constexpr bool operator != ( just_t < T > const & some , const maybe < U >& opt ); // (22) template < class T , class U > constexpr bool operator < ( const maybe < T >& opt , just_t < U > const & some ); // (23) template < class T , class U > constexpr bool operator < ( just_t < T > const & some , const maybe < U >& opt ); // (24) template < class T , class U > constexpr bool operator <= ( const maybe < T >& opt , just_t < U > const & some ); // (25) template < class T , class U > constexpr bool operator <= ( just_t < T > const & some , const maybe < U >& opt ); // (26) template < class T , class U > constexpr bool operator > ( const maybe < T >& opt , just_t < U > const & some ); // (27) template < class T , class U > constexpr bool operator > ( just_t < T > const & some , const maybe < U >& opt ); // (28) template < class T , class U > constexpr bool operator >= ( const maybe < T >& opt , just_t < U > const & some ); // (29) template < class T , class U > constexpr bool operator >= ( just_t < T > const & some , const maybe < U >& opt ); // (30) // Compare a maybe object with a T template < class T , class U > constexpr bool operator == ( const maybe < T >& opt , const U & value ); // (31) template < class T , class U > constexpr bool operator == ( const T & value , const maybe < U >& opt ); // (32) template < class T , class U > constexpr bool operator != ( const maybe < T >& opt , const U & value ); // (33) template < class T , class U > constexpr bool operator != ( const T & value , const maybe < U >& opt ); // (34) template < class T , class U > constexpr bool operator < ( const maybe < T >& opt , const U & value ); // (35) template < class T , class U > constexpr bool operator < ( const T & value , const maybe < U >& opt ); // (36) template < class T , class U > constexpr bool operator <= ( const maybe < T >& opt , const U & value ); // (37) template < class T , class U > constexpr bool operator <= ( const T & value , const maybe < U >& opt ); // (38) template < class T , class U > constexpr bool operator > ( const maybe < T >& opt , const U & value ); // (39) template < class T , class U > constexpr bool operator > ( const T & value , const maybe < U >& opt ); // (40) template < class T , class U > constexpr bool operator >= ( const maybe < T >& opt , const U & value ); // (41) template < class T , class U > constexpr bool operator >= ( const T & value , const maybe < U >& opt ); // (42) } Performs comparison operations on maybe objects. 1-6) Compares two maybe objects, lhs and rhs . The contained values are compared (using the corresponding operator of T and U ) only if both lhs and rhs contain values. Otherwise, lhs is considered equal to rhs if, and only if, both lhs and rhs do not contain a value. lhs is considered less than rhs if, and only if, rhs contains a value and lhs does not. 7-18) Compares opt with a nothing . Equivalent to (1-6) when comparing to a maybe that does not contain a value. 19-30) Compares opt with a some : = just_t ( value ) . The values are compared (using the corresponding operator of T ) only if opt contains a value. Otherwise, opt is considered less than some . If the corresponding comparison expression between opt . unwrap () and value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 31-42) Compares opt with a value . Equivalent to (19-30) expression opt ~ just ( value ) . Parameters lhs , rhs , opt - a maybe object to compare some - a just_t object to compare value - value to compare to the contained value Return value If bool ( lhs ) != bool ( rhs ) , returns false Otherwise, if bool ( lhs ) == false (and so bool ( rhs ) == false as well), returns true Otherwise, returns lhs . unwrap () == rhs . unwrap () . If bool ( lhs ) != bool ( rhs ) , returns true Otherwise, if bool ( lhs ) == false (and so bool ( rhs ) == false as well), returns false Otherwise, returns lhs . unwrap () != rhs . unwrap () . If bool ( rhs ) == false returns false Otherwise, if bool ( lhs ) == false , returns true Otherwise returns lhs . unwrap () < rhs . unwrap () . If bool ( lhs ) == false returns true Otherwise, if bool ( rhs ) == false , returns false Otherwise returns lhs . unwrap () <= rhs . unwrap () . If bool ( lhs ) == false returns false Otherwise, if bool ( rhs ) == false , returns true Otherwise returns lhs . unwrap () > rhs . unwrap () . If bool ( rhs ) == false returns true Otherwise, if bool ( lhs ) == false , returns false Otherwise returns lhs . unwrap () >= rhs . unwrap () . Returns opt . is_nothing () . Returns opt . is_nothing () . Returns opt . is_just () . Returns opt . is_just () . Returns false . Returns opt . is_just () . Returns opt . is_nothing () . Returns true . Returns opt . is_just () . Returns false . Returns true . Returns opt . is_nothing () . Returns opt . is_just () ? opt . unwrap () == some . value : false . Returns opt . is_just () ? some . value == opt . unwrap () : false . Returns opt . is_just () ? opt . unwrap () != some . value : true . Returns opt . is_just () ? some . value != opt . unwrap () : true . Returns opt . is_just () ? opt . unwrap () < some . value : true . Returns opt . is_just () ? some . value < opt . unwrap () : false . Returns opt . is_just () ? opt . unwrap () <= some . value : true . Returns opt . is_just () ? some . value <= opt . unwrap () : false . Returns opt . is_just () ? opt . unwrap () > some . value : false . Returns opt . is_just () ? some . value > opt . unwrap () : true . Returns opt . is_just () ? opt . unwrap () >= some . value : false . Returns opt . is_just () ? some . value >= opt . unwrap () : true . Returns opt == just ( value ) . Returns just ( value ) == opt . Returns opt != just ( value ) . Returns just ( value ) != opt . Returns opt < just ( value ) . Returns just ( value ) < opt . Returns opt <= just ( value ) . Returns just ( value ) <= opt . Returns opt > just ( value ) . Returns just ( value ) > opt . Returns opt >= just ( value ) . Returns just ( value ) >= opt . Note some . value : value is a private member of just_t (actually, cannot access to it).","title":"operator==, !=, &lt;, &lt;=, &gt;, &gt;=(maybe)"},{"location":"maybe/intro/","text":"Introduction \u00b6 Definition of class maybe \u00b6 namespace mitama { template < class T , class = void // for detection idiom > class maybe ; } Concepts \u00b6 T must satisfy the following requirements: Complete type Destructible just/nothing \u00b6 just and nothing are in-place factory for maybe < T > . If you want to initialize maybe < T > with some value, initialize with just ( value ) . mitama :: maybe < int > some_int = mitama :: just ( 42 ); Similarly, if you want to initialize maybe < T > with none value, initialize with nothing . mitama :: maybe < int > nope_int = mitama :: nothing ;","title":"Maybe 101"},{"location":"maybe/intro/#introduction","text":"","title":"Introduction"},{"location":"maybe/intro/#definition_of_class_maybe","text":"namespace mitama { template < class T , class = void // for detection idiom > class maybe ; }","title":"Definition of class maybe"},{"location":"maybe/intro/#concepts","text":"T must satisfy the following requirements: Complete type Destructible","title":"Concepts"},{"location":"maybe/intro/#justnothing","text":"just and nothing are in-place factory for maybe < T > . If you want to initialize maybe < T > with some value, initialize with just ( value ) . mitama :: maybe < int > some_int = mitama :: just ( 42 ); Similarly, if you want to initialize maybe < T > with none value, initialize with nothing . mitama :: maybe < int > nope_int = mitama :: nothing ;","title":"just/nothing"},{"location":"maybe/metafunctions/","text":"is_maybe \u00b6 template < class > struct is_maybe : std :: false_type { }; template < class T > struct is_maybe < maybe < T >> : std :: true_type { }; template < class T > inline constexpr bool is_maybe_v = is_maybe < T >:: value ; is_just \u00b6 template < class > struct is_just : std :: false_type { }; template < class T > struct is_just < just_t < T >> : std :: true_type { }; template < class T > inline constexpr bool is_just_v = is_just < T >:: value ;","title":"Meta Functions"},{"location":"maybe/metafunctions/#is_maybe","text":"template < class > struct is_maybe : std :: false_type { }; template < class T > struct is_maybe < maybe < T >> : std :: true_type { }; template < class T > inline constexpr bool is_maybe_v = is_maybe < T >:: value ;","title":"is_maybe"},{"location":"maybe/metafunctions/#is_just","text":"template < class > struct is_just : std :: false_type { }; template < class T > struct is_just < just_t < T >> : std :: true_type { }; template < class T > inline constexpr bool is_just_v = is_just < T >:: value ;","title":"is_just"},{"location":"maybe/special_members/","text":"Constructors \u00b6 default constructor [1/7] \u00b6 maybe () = default ; copy constructor [2/7] \u00b6 maybe ( maybe const & ) = default ; constructor [3/7] \u00b6 maybe ( maybe && ) = default ; constructor for nothing [4/7] \u00b6 Delegates to default constructor. maybe ( const nothing_t ) : maybe () {} constructor for maybe<U>, where constructible T from U [5/7] \u00b6 template < typename U , std :: enable_if_t < std :: disjunction_v < mitamagic :: is_pointer_like < std :: remove_reference_t < U >> , std :: is_pointer < std :: remove_reference_t < U >>> , bool > = false > maybe ( U && u ) : storage_ () { if ( u ) storage_ . emplace ( * std :: forward < U > ( u )); } in-place constructor [6/7] \u00b6 template < class ... Args , std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , Args && ... args ) : storage_ ( etude :: in_place ( std :: forward < Args > ( args )...)) {} in-place constructor with initializer_list [7/7] \u00b6 template < class U , class ... Args , std :: enable_if_t < std :: is_constructible_v < T , std :: initializer_list < U > , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , std :: initializer_list < U > il , Args && ... args ) : storage_ ( etude :: in_place ( il , std :: forward < Args > ( args )...)) {} Assignment operators \u00b6 copy assignment [1/2] \u00b6 maybe & operator = ( maybe const & ) = default ; move assignment [1/2] \u00b6 maybe & operator = ( maybe && ) = default ;","title":"Special Members"},{"location":"maybe/special_members/#constructors","text":"","title":"Constructors"},{"location":"maybe/special_members/#default_constructor_17","text":"maybe () = default ;","title":"default constructor [1/7]"},{"location":"maybe/special_members/#copy_constructor_27","text":"maybe ( maybe const & ) = default ;","title":"copy constructor [2/7]"},{"location":"maybe/special_members/#constructor_37","text":"maybe ( maybe && ) = default ;","title":"constructor [3/7]"},{"location":"maybe/special_members/#constructor_for_nothing_47","text":"Delegates to default constructor. maybe ( const nothing_t ) : maybe () {}","title":"constructor for nothing [4/7]"},{"location":"maybe/special_members/#constructor_for_maybeu_where_constructible_t_from_u_57","text":"template < typename U , std :: enable_if_t < std :: disjunction_v < mitamagic :: is_pointer_like < std :: remove_reference_t < U >> , std :: is_pointer < std :: remove_reference_t < U >>> , bool > = false > maybe ( U && u ) : storage_ () { if ( u ) storage_ . emplace ( * std :: forward < U > ( u )); }","title":"constructor for maybe&lt;U&gt;, where constructible T from U  [5/7]"},{"location":"maybe/special_members/#in-place_constructor_67","text":"template < class ... Args , std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , Args && ... args ) : storage_ ( etude :: in_place ( std :: forward < Args > ( args )...)) {}","title":"in-place constructor [6/7]"},{"location":"maybe/special_members/#in-place_constructor_with_initializer_list_77","text":"template < class U , class ... Args , std :: enable_if_t < std :: is_constructible_v < T , std :: initializer_list < U > , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , std :: initializer_list < U > il , Args && ... args ) : storage_ ( etude :: in_place ( il , std :: forward < Args > ( args )...)) {}","title":"in-place constructor with initializer_list [7/7]"},{"location":"maybe/special_members/#assignment_operators","text":"","title":"Assignment operators"},{"location":"maybe/special_members/#copy_assignment_12","text":"maybe & operator = ( maybe const & ) = default ;","title":"copy assignment [1/2]"},{"location":"maybe/special_members/#move_assignment_12","text":"maybe & operator = ( maybe && ) = default ;","title":"move assignment [1/2]"},{"location":"maybe/_APIs/and_finally/","text":"maybe<T>::and_finally(F f) -> void where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >>> and_finally ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >>> and_finally ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >>> and_finally ( F && f ) && ; }; Invokes the provided function with the contained value (if any), or doing nothing (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example","title":""},{"location":"maybe/_APIs/and_peek/","text":"maybe<T>::and_peek(F f) -> maybe<T> where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , maybe &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , maybe const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , maybe &&> and_peek ( F && f ) && ; }; Peeks the contained value if self is just , then returns self. Invokes the provided function with the contained value and then returns self (if any), or returns self without doing anything (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example","title":""},{"location":"maybe/_APIs/and_then/","text":"maybe<T>::and_then(F f) -> maybe<U> where F: T -> maybe<U> template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T const &>>>> , std :: invoke_result_t < F && , T const &> > and_then ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &&>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) && ; }; Returns nothing if the option is nothing , otherwise invokes f with the wrapped value and returns the result. Some languages call this operation flatmap. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto sq = []( int x ) -> maybe < int > { return just ( x * x ); }; auto nope = [](...) -> maybe < int > { return nothing ; }; assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( sq ) == just ( 16 )); assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( nope ) == nothing ); assert ( maybe { just ( 2 )}. and_then ( nope ). and_then ( sq ) == nothing ); assert ( nope (). and_then ( sq ). and_then ( sq ) == nothing ); } // end example","title":""},{"location":"maybe/_APIs/as_ref/","text":"maybe<T>::as_ref() -> maybe<T&> template < class T > class maybe { auto maybe < T >:: as_ref () & -> maybe < T &> ; auto maybe < T >:: as_ref () const & -> maybe < const T &> ; }; Converts from maybe < T >& to maybe < T &> . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> #include <iostream> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe text = just ( \"Hello, world!\" s ); // First, cast `maybe<T>` to `maybe<T&>` with `as_ref`, auto text_length = text . as_ref (). map ( & std :: string :: size ); std :: cout << \"still can print text: \" << text << \" \\n \" ; } // end example","title":""},{"location":"maybe/_APIs/cloned/","text":"maybe<T&>::cloned() -> maybe<T> where T is copyable template < class T > class maybe { auto maybe < T &>:: cloned () & -> maybe < T > ; }; Maps a maybe < T &> to a maybe < T > by deep copying the contents of the maybe. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int x = 12 ; maybe < int &> opt_x = x ; assert ( opt_x == just ( 12 )); assert ( & ( opt_x . unwrap ()) == & x ); auto shallow_copied = opt_x ; assert ( & ( shallow_copied . unwrap ()) == & x ); auto cloned = opt_x . cloned (); assert ( cloned == just ( 12 )); assert ( & ( cloned . unwrap ()) != & x ); } // end example","title":""},{"location":"maybe/_APIs/conj/","text":"maybe<T>::conj(maybe<U>) -> maybe>U> template < class T > class maybe { template < class U > auto maybe < T >:: conj ( maybe < U > const & rhs ) -> maybe < U > ; }; Returns nothing if the lhs is nothing , otherwise returns rhs . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } { maybe < int > x = nothing ; maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == nothing ); } { maybe x = just ( 2 ); maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == just ( \"foo\" s )); } { maybe < int > x = nothing ; maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } } // end example","title":""},{"location":"maybe/_APIs/disj/","text":"maybe<T>::disj(maybe<T>) -> maybe>T> template < class T > class maybe { auto maybe < T >:: disj ( maybe < T > const & rhs ) -> maybe < T > ; }; Returns the maybe if it contains a value, otherwise returns rhs. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); maybe < int > y = nothing ; assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 100 )); } { maybe x = just ( 2 ); maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe < int > y = nothing ; assert ( x . disj ( y ) == nothing ); } } // end example","title":""},{"location":"maybe/_APIs/expect/","text":"maybe<T>::expect(std::string_view msg) -> T& template < class T > class maybe { auto maybe < T >:: expect ( std :: string_view msg ) & -> T & ; auto maybe < T >:: expect ( std :: string_view msg ) const & -> T const & ; auto maybe < T >:: expect ( std :: string_view msg ) && -> T && ; }; Unwraps a maybe, yielding the content of a just . Exception Raise mitama :: runtime_panic if the value is a nothing with a custom panic message provided by msg . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"value\" s ); assert ( x . expect ( \"the world is ending\" ) == \"value\" s ); } try { maybe < int > x = nothing ; x . expect ( \"the world is ending\" ); // panics with `the world is ending` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'the world is ending' } } // end example","title":""},{"location":"maybe/_APIs/filter/","text":"maybe<T>::filter(Pred predicate) -> maybe<T> template < class T > class maybe { template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T const &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) const & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &&> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) && ; }; Returns nothing if the option is nothing , otherwise invokes predicate with the wrapped value and returns: just ( t ) if predicate returns true (where t is the wrapped value), and nothing if predicate returns false. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto is_even = []( int n ) -> bool { return n % 2 == 0 ; }; assert ( maybe < int > {}. filter ( is_even ) == nothing ); assert ( maybe { just ( 3 )}. filter ( is_even ) == nothing ); assert ( maybe { just ( 4 )}. filter ( is_even ) == just ( 4 )); } // end example","title":""},{"location":"maybe/_APIs/flatten/","text":"maybe<maybe<T>>::flatten() -> maybe<T> template < class T > class maybe { auto maybe < maybe < T >>:: transpose () -> maybe < T > ; }; Converts from maybe < maybe < T >> to maybe < T > . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < maybe < int >> x = just ( just ( 6 )); assert ( just ( 6 ) == x . flatten ()); maybe < maybe < int >> y = just ( nothing ); assert ( nothing == y . flatten ()); maybe < maybe < int >> z = nothing ; assert ( nothing == z . flatten ()); // Flattening once only removes one level of nesting: maybe < maybe < maybe < int >>> nest = just ( just ( just ( 6 ))); assert ( just ( 6 ) == nest . flatten (). flatten ()); } // end example","title":""},{"location":"maybe/_APIs/get_or_emplace/","text":"maybe<T>::get_or_emplace(Args... args) -> T& template < class T > class maybe { template < class ... Args > std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , T &> get_or_emplace ( Args && ... args ) & ; }; Emplace constructs T into the maybe with expression std :: forward < Args > ( args )... if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; struct noncopyable { noncopyable () = default ; noncopyable ( noncopyable const & ) = delete ; noncopyable & operator = ( noncopyable const & ) = delete ; noncopyable ( noncopyable && ) = default ; noncopyable & operator = ( noncopyable && ) = default ; bool operator == ( noncopyable && ) & { return true ; } bool operator == ( noncopyable && ) const & { return true ; } bool operator == ( noncopyable const & ) & { return true ; } bool operator == ( noncopyable const & ) const & { return true ; } }; int main () { maybe < noncopyable > x = nothing ; auto & y = x . get_or_emplace ( noncopyable {}); assert ( y == noncopyable {}); } // end example","title":""},{"location":"maybe/_APIs/get_or_emplace_with/","text":"maybe<T>::get_or_emplace_with(F f,Args... args) -> T& template < class T > class maybe { template < class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , Args && ... > , std :: is_constructible < T , std :: invoke_result_t < F && , Args && ... >>> , T &> get_or_emplace_with ( F && f , Args && ... args ) & ; }; Emplace constructs T into the maybe with expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < int > x = nothing ; std :: ignore = x . get_or_emplace_with ([]{ return 5 ; }); std :: ignore = x . get_or_emplace_with ([]( auto x ){ return x ; }, 5 ); auto & y = x . get_or_emplace_with ( & std :: string :: size , \"12345\" s ); assert ( y == 5 ); y = 7 ; assert ( x == just ( 7 )); } // end example","title":""},{"location":"maybe/_APIs/is_just/","text":"maybe<T>::is_just() -> bool template < class T > class maybe { constexpr bool maybe < T >:: is_just () const noexcept ; }; Returns true if the maybe has some value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( x . is_just () ); maybe < int > y = nothing ; assert ( ! y . is_just () ); } // end example","title":""},{"location":"maybe/_APIs/is_nothing/","text":"maybe<T>::is_nothing() -> bool template < class T > class maybe { constexpr bool maybe < T >:: is_nothing () const noexcept ; }; Returns true if the maybe is a nothing value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( ! x . is_nothing () ); maybe < int > y = nothing ; assert ( y . is_nothing () ); } // end example","title":""},{"location":"maybe/_APIs/map/","text":"maybe<T>::map(F f) -> maybe<T> where F: T -> U template < class T > class maybe { template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &> , bool > = false > auto maybe < T >:: map ( F && f ) & -> maybe < std :: invoke_result_t < F && , T &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T const &> , bool > = false > auto maybe < T >:: map ( F && f ) const & -> maybe < std :: invoke_result_t < F && , T const &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &&> , bool > = false > auto maybe < T >:: map ( F && f ) && -> maybe < std :: invoke_result_t < F && , T &&>> ; }; Maps a maybe < T > to maybe < U > by applying a function to a contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe maybe_some_string = just ( \"Hello, World!\" s ); // `maybe::map` takes self *by ref*, // *not* consuming `maybe_some_string` maybe maybe_some_len = maybe_some_string . map ( & std :: string :: size ); assert ( maybe_some_len == just ( 13u )); } // end example","title":""},{"location":"maybe/_APIs/map_or/","text":"maybe<T>::map_or(T def, F f) -> T template < class T > class maybe { template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &>>> map_or ( U && def , F && f ) & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T const &>>> map_or ( U && def , F && f ) const & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &&>>> map_or ( U && def , F && f ) && ; }; Applies a function to the contained value (if any), or returns the provided default (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . map_or ( 42 , & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or ( 42 , & std :: string :: size ) == 42 ); } // end example","title":""},{"location":"maybe/_APIs/map_or_else/","text":"maybe<T>::map_or_else(D def, F f) -> U where D: () -> U, F: T -> U, template < class T > class maybe { template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>> map_or_else ( D && def , F && f ) & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>> map_or_else ( D && def , F && f ) const & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>> map_or_else ( D && def , F && f ) && ; }; Applies a function to the contained value (if any), or computes a default (if not). Examples // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { int k = 21 ; maybe x = just ( \"foo\" s ); assert ( x . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 42 ); } // end example","title":""},{"location":"maybe/_APIs/ok_or/","text":"maybe<T>::ok_or(E err) -> result template < class T > class maybe { template < class E > auto maybe < T >:: ok_or ( E && err ) const & -> result < T , E > ; template < class E > auto maybe < T >:: ok_or ( E && err ) && -> result < std :: remove_reference_t < T > , E > ; auto maybe < T >:: ok_or () const & -> result < T , std :: monostate > ; auto maybe < T >:: ok_or () && -> result < std :: remove_reference_t < T > , std :: monostate > ; }; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ) . Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or ( 0 ) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or ( 0 ) == failure ( 0 )); assert ( y . ok_or () == failure <> ()); } // end example","title":""},{"location":"maybe/_APIs/ok_or_else/","text":"maybe<T>::ok_or_else(F f) -> result<T, E> where F: () -> E template < class T > class maybe { template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < T , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) const & ; template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < std :: remove_reference_t < T > , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) && ; }; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ()) . Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or_else ([]{ return 0 ; }) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or_else ([]{ return 0 ; }) == failure ( 0 )); } // end example","title":""},{"location":"maybe/_APIs/or_else/","text":"maybe<T>::or_else(F f) -> maybe<T> where F: () -> maybe<T> template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) && ; }; Returns the maybe if it contains a value, otherwise invokes f and returns the result. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto nobody = []() -> maybe < std :: string > { return nothing ; }; auto vikings = []() -> maybe < std :: string > { return just ( \"vikings\" s ); }; assert ( maybe { just ( \"barbarians\" s )}. or_else ( vikings ) == just ( \"barbarians\" s )); assert ( maybe < std :: string > {}. or_else ( vikings ) == just ( \"vikings\" s )); assert ( maybe < std :: string > {}. or_else ( nobody ) == nothing ); } // end example","title":""},{"location":"maybe/_APIs/or_finally/","text":"maybe<T>::or_finally(F f) -> void where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) && ; }; Invokes the provided function (if nothing), or doing nothing (if any). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":""},{"location":"maybe/_APIs/or_peek/","text":"maybe<T>::or_peek(F f) -> maybe<T> where F: T -> void template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &> or_peek ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe const &> or_peek ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &&> or_peek ( F && f ) && ; }; Invokes the provided function and then returns self (if nothing), or returns self without doing anything (if any). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":""},{"location":"maybe/_APIs/range_to_maybe/","text":"range_to_maybe(Range range) -> maybe<Range::Item> In header < mitama / maybe / range_to_maybe . hpp > . template < class Range > auto range_to_maybe ( Range && range ) -> maybe < decltype ( * begin ( range )) > ; The range_to_maybe function returns nothing on an empty range or just ( v ) where v is the first element of the range . Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/maybe/range_to_maybe.hpp> #include <cassert> using namespace mitama ; int main () { std :: vector v { 1 , 2 , 3 }; maybe x = range_to_maybe ( v ); assert ( x == just ( 1 )); maybe y = range_to_maybe ( std :: vector < int > {}); assert ( y == nothing ); int a [] = { 1 }; maybe z = range_to_maybe ( a ); assert ( z == 1 ); } // end example","title":"Range to maybe"},{"location":"maybe/_APIs/replace/","text":"maybe<T>::replace(Args... args) -> maybe<T> where T is constructible from (Args...) template < class T > class maybe { maybe < T > replace ( Args && ... args ) & ; }; Replaces the actual value in the maybe by expression std :: forward < Args > ( args )... , returning the old value if present, leaving a just value in its place without deinitializing either one. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); auto old = x . replace ( 5 ); assert ( x == just ( 5 )); assert ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace ( 3 ); assert ( x == just ( 3 )); assert ( old == nothing ); } } // end example","title":""},{"location":"maybe/_APIs/replace_with/","text":"maybe<T>::replace_with(F f, Args... args) -> maybe<T> where T is constructible from F(Args...) template < class T > class maybe { template < class F , class ... Args > maybe < T > replace_with ( F && f , Args && ... args ) & ; }; Replaces the actual value in the maybe by expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) , returning the old value if present, leaving a just value in its place without deinitializing either one. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); auto old = x . replace_with ([]{ return 5 ; }); assert ( x == just ( 5 )); assert ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace_with ( & std :: string :: size , \"foo\" s ); assert ( x == just ( 3 )); assert ( old == nothing ); } } // end example","title":""},{"location":"maybe/_APIs/transpose/","text":"maybe<basic_result<_, T, E>>::transpose() -> basic_result<_, maybe<T>, E> template < class T > class maybe { maybe < basic_result < _ , T , E >>:: transpose () const & -> basic_result < _ , maybe < T > , E > ; }; Transposes a maybe of a result into a result of a maybe . nothing will be mapped to success ( nothing ) . just ( success ( _ )) and just ( failure ( _ )) will be mapped to success ( just ( _ )) and failure ( _ ) \u3000(_ is a placeholder). Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); assert ( x == y . transpose ()); } // end example","title":""},{"location":"maybe/_APIs/unwrap/","text":"maybe<T>::unwrap() -> T& template < class T > class maybe { auto maybe < T >:: unwrap () & -> T & ; auto maybe < T >:: unwrap () const & -> T const & ; auto maybe < T >:: unwrap () && -> T && ; }; Unwraps a maybe, yielding the content of a just . Exception Raise mitama :: runtime_panic if a maybe has not just value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"air\" s ); assert ( x . unwrap () == \"air\" s ); } try { maybe < int > x = nothing ; x . unwrap (); // raise an exception } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'called `maybe::unwrap()` on a `nothing` value' } } // end example","title":""},{"location":"maybe/_APIs/unwrap_or/","text":"maybe<T>::unwrap_or(T def) -> T template < class T > class maybe { template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T & , U &&>>:: value , std :: common_type_t < T & , U &&>> maybe < T >:: unwrap_or ( U && def ) & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T const & , U &&>>:: value , std :: common_type_t < T const & , U &&>> maybe < T >:: unwrap_or ( U && def ) const & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T && , U &&>>:: value , std :: common_type_t < T && , U &&>> maybe < T >:: unwrap_or ( U && def ) && ; }; Returns the contained value or a default. Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { assert ( maybe { just ( \"car\" s )}. unwrap_or ( \"bike\" s ) == \"car\" s ); assert ( maybe < std :: string > { nothing }. unwrap_or ( \"bike\" s ) == \"bike\" s ); } // end example","title":""},{"location":"maybe/_APIs/unwrap_or_default/","text":"maybe<T>::unwrap_or_default() -> T template < class T > class maybe { auto maybe < T >:: unwrap_or_default () const & -> std :: remove_reference_t < T > ; }; Returns the contained value or a default. If just , returns the contained value, otherwise if nothing , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < std :: string > x = nothing ; assert ( x . unwrap_or_default () == \"\" s ); } // end example","title":""},{"location":"maybe/_APIs/unwrap_or_else/","text":"maybe<T>::unwrap_or_else(F f) -> T where F: () -> T template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T const & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T const & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T && , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T && , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) && ; }; Returns the contained value or computes it from a invocable object op . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int k = 10 ; assert ( maybe { just ( 4 )}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 4 ); assert ( maybe < int > {}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 20 ); } // end example","title":""},{"location":"maybe/_Internal/comparisons/","text":"// Compare two just_t objects template < class T , class U > constexpr bool operator == ( const just_t < T >& lhs , const just_t < U >& rhs ); // (43) template < class T , class U > constexpr bool operator != ( const just_t < T >& lhs , const just_t < U >& rhs ); // (44) template < class T , class U > constexpr bool operator < ( const just_t < T >& lhs , const just_t < U >& rhs ); // (45) template < class T , class U > constexpr bool operator <= ( const just_t < T >& lhs , const just_t < U >& rhs ); // (46) template < class T , class U > constexpr bool operator > ( const just_t < T >& lhs , const just_t < U >& rhs ); // (47) template < class T , class U > constexpr bool operator >= ( const just_t < T >& lhs , const just_t < U >& rhs ); // (48) // Compare a just_t object with a nothing template < class T > constexpr bool operator == ( const just_t < T >& opt , nothing_t ) noexcept ; // (49) template < class T > constexpr bool operator == ( nothing_t , const just_t < T >& opt ) noexcept ; // (50) template < class T > constexpr bool operator != ( const just_t < T >& opt , nothing_t ) noexcept ; // (51) template < class T > constexpr bool operator != ( nothing_t , const just_t < T >& opt ) noexcept ; // (52) template < class T > constexpr bool operator < ( const just_t < T >& opt , nothing_t ) noexcept ; // (53) template < class T > constexpr bool operator < ( nothing_t , const just_t < T >& opt ) noexcept ; // (54) template < class T > constexpr bool operator <= ( const just_t < T >& opt , nothing_t ) noexcept ; // (55) template < class T > constexpr bool operator <= ( nothing_t , const just_t < T >& opt ) noexcept ; // (56) template < class T > constexpr bool operator > ( const just_t < T >& opt , nothing_t ) noexcept ; // (57) template < class T > constexpr bool operator > ( nothing_t , const just_t < T >& opt ) noexcept ; // (58) template < class T > constexpr bool operator >= ( const just_t < T >& opt , nothing_t ) noexcept ; // (59) template < class T > constexpr bool operator >= ( nothing_t , const just_t < T >& opt ) noexcept ; // (60) // Compare two nothing objects constexpr bool operator == ( nothing_t , nothing_t ) noexcept ; // (61) constexpr bool operator != ( nothing_t , nothing_t ) noexcept ; // (62) constexpr bool operator < ( nothing_t , nothing_t ) noexcept ; // (63) constexpr bool operator <= ( nothing_t , nothing_t ) noexcept ; // (64) constexpr bool operator > ( nothing_t , nothing_t ) noexcept ; // (65) constexpr bool operator >= ( nothing_t , nothing_t ) noexcept ; // (66)","title":""},{"location":"maybe/_metafunctions/is_just/","text":"is_just \u00b6 template < class > struct is_just : std :: false_type { }; template < class T > struct is_just < just_t < T >> : std :: true_type { }; template < class T > inline constexpr bool is_just_v = is_just < T >:: value ;","title":"Is just"},{"location":"maybe/_metafunctions/is_just/#is_just","text":"template < class > struct is_just : std :: false_type { }; template < class T > struct is_just < just_t < T >> : std :: true_type { }; template < class T > inline constexpr bool is_just_v = is_just < T >:: value ;","title":"is_just"},{"location":"maybe/_metafunctions/is_maybe/","text":"is_maybe \u00b6 template < class > struct is_maybe : std :: false_type { }; template < class T > struct is_maybe < maybe < T >> : std :: true_type { }; template < class T > inline constexpr bool is_maybe_v = is_maybe < T >:: value ;","title":"Is maybe"},{"location":"maybe/_metafunctions/is_maybe/#is_maybe","text":"template < class > struct is_maybe : std :: false_type { }; template < class T > struct is_maybe < maybe < T >> : std :: true_type { }; template < class T > inline constexpr bool is_maybe_v = is_maybe < T >:: value ;","title":"is_maybe"},{"location":"result/APIs/","text":"is_ok \u00b6 basic_result<_, T, E>:::is_ok() -> bool template < mutability _mu , class T , class E > class basic_result { constexpr bool is_ok () const noexcept ; }; Returns true if the result is success . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 3 ); assert ( x . is_ok () == true ); result < unsigned , std :: string > y = failure ( \"Some error message\" s ); assert ( y . is_ok () == false ); } // end example is_err \u00b6 basic_result<_, T, E>::is_err() -> bool template < mutability _mu , class T , class E > class basic_result { constexpr bool is_err () const noexcept ; }; Returns true if the result is failure. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 3 ); assert ( x . is_err () == false ); result < unsigned , std :: string > y = failure ( \"Some error message\" s ); assert ( y . is_err () == true ); } // end example ok \u00b6 basic_result<_, T, E>::ok() -> maybe<T> template < class T , class E > class basic_result < mutability :: immut , T , E > { constexpr auto result < T , E >:: ok () & -> maybe < const T > ; constexpr auto result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto result < T , E >:: ok () && -> maybe < const T > ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { constexpr auto mut_result < T , E >:: ok () & -> maybe < T > ; constexpr auto mut_result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () && -> maybe < T > ; }; Converts from basic_result to maybe . Converts self into a maybe , and discarding the failure value, if any. Note that these functions propagate mutability to element type of maybe . Remarks If self is rvalue and T is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < T >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 2 ); assert ( x . ok () == just ( 2 )); result < unsigned , std :: string > y = failure ( \"Nothing here\" s ); assert ( y . ok () == nothing ); } // end example err \u00b6 basic_result<_, T, E>::err() -> maybe<E> template < class T , class E > class basic_result < mutability :: immut , T , E > { constexpr auto result < T , E >:: err () & -> maybe < const E > ; constexpr auto result < T , E >:: err () const & -> maybe < const E > ; constexpr auto result < T , E >:: err () && -> maybe < const E > ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { constexpr auto mut_result < T , E >:: err () & -> maybe < E > ; constexpr auto mut_result < T , E >:: err () const & -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () && -> maybe < E > ; }; Converts from basic_result to maybe . Converts self into a maybe , and discarding the success value, if any. Note that these functions propagate mutability to element type of maybe . Remarks If self is rvalue and E is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 2 ); assert ( x . err () == nothing ); result < unsigned , std :: string > y = failure ( \"Nothing here\" s ); assert ( y . err () == just ( \"Nothing here\" s )); } // end example map \u00b6 basic_result< , T, E>::map(O op) -> basic_result< , U, E> where O: T -> U template < mutability _mu , class T , class E > class basic_result { constexpr auto map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , result < std :: invoke_result_t < O , T > , E >> ; }; Maps a result < T , E > to result < U , E > by applying a function to a contained success value, leaving an failure value untouched. This function can be used to compose the results of two functions. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> #include <boost/lambda/lambda.hpp> using namespace mitama ; using namespace std :: string_literals ; using boost :: lambda :: _1 ; int main () { result < int , int > ok = success ( 2 ); assert ( ok . map ( _1 * 2 ) == success ( 4 )); result < int , int > err = failure ( 2 ); assert ( err . map ( _1 * 2 ) == failure ( 2 )); } // end example map_or_else \u00b6 basic_result<_, T, E>::map_or_else(Fallback _fallback, Map _map) -> U where Fallback: E -> U, Map: T -> U, template < mutability _mu , class T , class E > class basic_result { template < class Map , class Fallback > constexpr auto map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; }; Maps a result < T , E > to U by applying a function to a contained success value, or a fallback function to a contained failure value. This function can be used to unpack a successful result while handling an error. Examples Basic usage: // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto k = 21 ; { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); } } // end example map_err \u00b6 basic_result< , T, E>::map_err(O op) -> basic_result< , T, F> where O: E -> F template < mutability _mu , class T , class E > class basic_result { template < class O > constexpr auto map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , result < T , std :: invoke_result_t < O , E >>> ; }; Maps a result < T , E > to result < T , F > by applying a function to a contained failure value, leaving an success value untouched. This function can be used to pass through a successful result while handling an error. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; result < unsigned , unsigned > x = success ( 2 ); assert ( x . map_err ( stringify ) == success ( 2u )); result < unsigned , unsigned > y = failure ( 13 ); assert ( y . map_err ( stringify ) == failure ( \"error code: 13\" s )); } // end example conj \u00b6 basic_result< , T, E>::conj(basic_result< , U, E> res) -> basic_result<_, U, E> template < mutability _mu , class T , class E > class basic_result { template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: conj ( basic_result < _ , U , E > const & res ) const & -> basic_result < U , E > ; template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: operator && ( basic_result < _ , U , E > const & res ) const & -> basic_result < U , E > ; }; Returns res if the result is success , otherwise returns the failure value of self. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < std :: string , std :: string > y = success ( \"foo\" s ); assert (( x && y ) == failure ( \"early error\" s )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"not a 2\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = success ( \"different result type\" s ); assert (( x && y ) == success ( \"different result type\" s )); } } // end example and_then \u00b6 basic_result< , T, E>::and_then(O op) -> basic_result< , U, E> where O: T -> basic_result<_, U, E> template < mutability _mu , class T , class E > class basic_result { template < class O , std :: enable_of > constexpr auto and_then ( O && op ) & -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T &> , failure < E >> , std :: invoke_result_t < O , T >> ; template < class O > constexpr auto and_then ( O && op ) const & -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T const &> , failure < E >> , std :: invoke_result_t < O , T >> ; template < class O > constexpr auto and_then ( O && op ) && -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T &&> , failure < E >> , std :: invoke_result_t < O , T >> ; }; Calls op if the result is success, otherwise returns the failure value of self. This function can be used for control flow based on result values. Remarks and_then ( O && ) qualifier shall not participate in overload resolution unless is_convertible_result_with_v < std :: invoke_result_t < O && , T qualifier > , failure < E >> is true. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; result < int , int > x = success ( 2u ); result < int , int > y = failure ( 3u ); assert ( x . and_then ( sq ). and_then ( sq ) == success ( 16u )); assert ( x . and_then ( sq ). and_then ( err ) == failure ( 4u )); assert ( x . and_then ( err ). and_then ( sq ) == failure ( 2u )); assert ( y . and_then ( sq ). and_then ( sq ) == failure ( 3u )); } // end example disj \u00b6 basic_result< , T, E>::disj(basic_result< , T, F> res) -> basic_result<_, T, F> template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr auto basic_result < _ , T , E >:: disj ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; template < class F > constexpr auto basic_result < _ , T , E >:: operator || ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; }; Returns res if the result is failure , otherwise returns the success value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < unsigned , std :: string > y = success ( 2 ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert ( x . disj ( y ) == failure ( \"late error\" s )); assert (( x || y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = success ( 100 ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } } // end example or_else \u00b6 basic_result< , T, E>or_else(O op) -> basic_result< , T, F> where O: E -> basic_result<_, T, F> template < mutability _mu , class T , class E > class basic_result { template < class O > constexpr auto basic_result < _ , T , E >:: or_else ( O && op ) const & -> std :: invoke_result < O && , E > ; }; Calls op if the result is failure , otherwise returns the success value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v < std :: invoke_result_t < O , T > , success < T >> is true. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; result < int , int > x = success ( 2u ); result < int , int > y = failure ( 3u ); assert ( x . or_else ( sq ). or_else ( sq ) == success ( 2u )); assert ( x . or_else ( err ). or_else ( sq ) == success ( 2u )); assert ( y . or_else ( sq ). or_else ( err ) == success ( 9u )); assert ( y . or_else ( err ). or_else ( err ) == failure ( 3u )); } // end example unwrap_or \u00b6 basic_result<_, T, E>::unwrap_or(T const& optb) -> T template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , T , E >:: unwrap_or ( T const & optb ) const noexcept }; Unwraps a result, yielding the content of an success . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , unsigned > ok = success ( 2 ); result < unsigned , unsigned > err = failure ( 2 ); assert ( ok . unwrap_or ( 1u ) == 2u ); assert ( err . unwrap_or ( 1u ) == 1u ); } // end example unwrap_or_else \u00b6 basic_result<_, T, E>::unwrap_or_else() -> T template < mutability _mu , class T , class E > class basic_result { template < class O > auto basic_result < _ , T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > ; }; Unwraps a result, yielding the content of an success . If the value is an failure then it invokes op with its value. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < int , std :: string > ok = success ( 2 ); result < int , std :: string > err = failure ( \"foo\" s ); assert ( ok . unwrap_or_else ( & std :: string :: size ) == 2 ); assert ( err . unwrap_or_else ( & std :: string :: size ) == 3 ); } // end example unwrap \u00b6 basic_result<_, T, E>::unwrap() -> E& template < class T , class E > class basic_result < mutability :: immut , T , E > { auto unwrap () & -> const T ; auto unwrap () const & -> const T ; auto unwrap () && -> const T ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { auto unwrap () & -> T ; auto unwrap () const & -> const T ; auto unwrap () && -> T ; }; Unwraps a result, yielding the content of an success . Exception Raise mitama :: runtime_panic if a result is containing failure value. Remarks If self is rvalue and T is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < T >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); assert ( x . unwrap () == 2 ); } try { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; } } // end example unwrap_err \u00b6 basic_result<_, T, E>::unwrap_err() -> E& template < class T , class E > class basic_result < mutability :: immut , T , E > { auto unwrap_err () & -> const E ; auto unwrap_err () const & -> const E ; auto unwrap_err () && -> const E ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { auto mut_unwrap_err () & -> E ; auto mut_unwrap_err () const & -> const E ; auto mut_unwrap_err () && -> E ; }; Unwraps a result, yielding the content of an failure . Exception Raise mitama :: runtime_panic if a result is containing success value. Remarks If self is rvalue and E is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { try { result < unsigned , std :: string > x = success ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; } { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); assert ( x . unwrap_err () == \"emergency failure\" s ); } } // end example unwrap_or_default \u00b6 basic_result<_, T, E>::unwrap_or_default() -> T where T is default constructible template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , T , E >:: unwrap_or_default () const & -> T ; }; Returns the contained value or a default. If success , returns the contained value, otherwise if failure , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < int > good = success ( 1909 ); result < int > bad = failure <> (); auto good_year = good . unwrap_or_default (); auto bad_year = bad . unwrap_or_default (); assert ( 1909 == good_year ); assert ( 0 == bad_year ); } // end example transpose \u00b6 basic_result< , maybe&ltT>, E>::transpose() -> maybe<basic_result< , T, E>> template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; }; Transposes a result of a maybe into a maybe of a result . success ( nothing ) will be mapped to nothing . success ( just ( v )) and failure ( v ) will be mapped to just ( success ( v )) and just ( failure ( v )) . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; int main () { result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); assert ( x . transpose () == y ); } // end example and_finally \u00b6 basic_result::and_finally(F f) -> void template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &&>> and_finally ( F && f ) const & ; }; Invokes the provided function with the contained success value (if success), or doing nothing (if failure). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { result < int , std :: string > x = success ( 42 ); int hook = 0 ; x . and_finally ([ & ]( int const & v ){ hook = v ; }); assert ( hook == 42 ); } // end example or_finally \u00b6 basic_result::or_finally(F f) -> void template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &&>> and_finally ( F && f ) const & ; }; Invokes the provided function with contained failure value (if failure), or doing nothing (if success). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example and_peek \u00b6 basic_result::and_peek(F f) -> basic_result template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> and_peek ( F && f ) && ; }; Peeks the contained success value and then returns self. Invokes the provided function with the contained value and then return self (if success), or return self without doing anything (if failure). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { result < int , std :: string > x = success ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == success ( 42 )); assert ( hook == 42 ); } // end example or_peek \u00b6 basic_result::or_peek(F f) -> basic_result template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> or_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> or_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> or_peek ( F && f ) && ; }; Peeks the contained failure value and then returns self. Invokes the provided function and then return self (if failure), or return self without doing anything (if success). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":"APIs"},{"location":"result/APIs/#is_ok","text":"basic_result<_, T, E>:::is_ok() -> bool template < mutability _mu , class T , class E > class basic_result { constexpr bool is_ok () const noexcept ; }; Returns true if the result is success . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 3 ); assert ( x . is_ok () == true ); result < unsigned , std :: string > y = failure ( \"Some error message\" s ); assert ( y . is_ok () == false ); } // end example","title":"is_ok"},{"location":"result/APIs/#is_err","text":"basic_result<_, T, E>::is_err() -> bool template < mutability _mu , class T , class E > class basic_result { constexpr bool is_err () const noexcept ; }; Returns true if the result is failure. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 3 ); assert ( x . is_err () == false ); result < unsigned , std :: string > y = failure ( \"Some error message\" s ); assert ( y . is_err () == true ); } // end example","title":"is_err"},{"location":"result/APIs/#ok","text":"basic_result<_, T, E>::ok() -> maybe<T> template < class T , class E > class basic_result < mutability :: immut , T , E > { constexpr auto result < T , E >:: ok () & -> maybe < const T > ; constexpr auto result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto result < T , E >:: ok () && -> maybe < const T > ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { constexpr auto mut_result < T , E >:: ok () & -> maybe < T > ; constexpr auto mut_result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () && -> maybe < T > ; }; Converts from basic_result to maybe . Converts self into a maybe , and discarding the failure value, if any. Note that these functions propagate mutability to element type of maybe . Remarks If self is rvalue and T is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < T >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 2 ); assert ( x . ok () == just ( 2 )); result < unsigned , std :: string > y = failure ( \"Nothing here\" s ); assert ( y . ok () == nothing ); } // end example","title":"ok"},{"location":"result/APIs/#err","text":"basic_result<_, T, E>::err() -> maybe<E> template < class T , class E > class basic_result < mutability :: immut , T , E > { constexpr auto result < T , E >:: err () & -> maybe < const E > ; constexpr auto result < T , E >:: err () const & -> maybe < const E > ; constexpr auto result < T , E >:: err () && -> maybe < const E > ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { constexpr auto mut_result < T , E >:: err () & -> maybe < E > ; constexpr auto mut_result < T , E >:: err () const & -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () && -> maybe < E > ; }; Converts from basic_result to maybe . Converts self into a maybe , and discarding the success value, if any. Note that these functions propagate mutability to element type of maybe . Remarks If self is rvalue and E is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 2 ); assert ( x . err () == nothing ); result < unsigned , std :: string > y = failure ( \"Nothing here\" s ); assert ( y . err () == just ( \"Nothing here\" s )); } // end example","title":"err"},{"location":"result/APIs/#map","text":"basic_result< , T, E>::map(O op) -> basic_result< , U, E> where O: T -> U template < mutability _mu , class T , class E > class basic_result { constexpr auto map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , result < std :: invoke_result_t < O , T > , E >> ; }; Maps a result < T , E > to result < U , E > by applying a function to a contained success value, leaving an failure value untouched. This function can be used to compose the results of two functions. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> #include <boost/lambda/lambda.hpp> using namespace mitama ; using namespace std :: string_literals ; using boost :: lambda :: _1 ; int main () { result < int , int > ok = success ( 2 ); assert ( ok . map ( _1 * 2 ) == success ( 4 )); result < int , int > err = failure ( 2 ); assert ( err . map ( _1 * 2 ) == failure ( 2 )); } // end example","title":"map"},{"location":"result/APIs/#map_or_else","text":"basic_result<_, T, E>::map_or_else(Fallback _fallback, Map _map) -> U where Fallback: E -> U, Map: T -> U, template < mutability _mu , class T , class E > class basic_result { template < class Map , class Fallback > constexpr auto map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; }; Maps a result < T , E > to U by applying a function to a contained success value, or a fallback function to a contained failure value. This function can be used to unpack a successful result while handling an error. Examples Basic usage: // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto k = 21 ; { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); } } // end example","title":"map_or_else"},{"location":"result/APIs/#map_err","text":"basic_result< , T, E>::map_err(O op) -> basic_result< , T, F> where O: E -> F template < mutability _mu , class T , class E > class basic_result { template < class O > constexpr auto map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , result < T , std :: invoke_result_t < O , E >>> ; }; Maps a result < T , E > to result < T , F > by applying a function to a contained failure value, leaving an success value untouched. This function can be used to pass through a successful result while handling an error. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; result < unsigned , unsigned > x = success ( 2 ); assert ( x . map_err ( stringify ) == success ( 2u )); result < unsigned , unsigned > y = failure ( 13 ); assert ( y . map_err ( stringify ) == failure ( \"error code: 13\" s )); } // end example","title":"map_err"},{"location":"result/APIs/#conj","text":"basic_result< , T, E>::conj(basic_result< , U, E> res) -> basic_result<_, U, E> template < mutability _mu , class T , class E > class basic_result { template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: conj ( basic_result < _ , U , E > const & res ) const & -> basic_result < U , E > ; template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: operator && ( basic_result < _ , U , E > const & res ) const & -> basic_result < U , E > ; }; Returns res if the result is success , otherwise returns the failure value of self. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < std :: string , std :: string > y = success ( \"foo\" s ); assert (( x && y ) == failure ( \"early error\" s )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"not a 2\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = success ( \"different result type\" s ); assert (( x && y ) == success ( \"different result type\" s )); } } // end example","title":"conj"},{"location":"result/APIs/#and_then","text":"basic_result< , T, E>::and_then(O op) -> basic_result< , U, E> where O: T -> basic_result<_, U, E> template < mutability _mu , class T , class E > class basic_result { template < class O , std :: enable_of > constexpr auto and_then ( O && op ) & -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T &> , failure < E >> , std :: invoke_result_t < O , T >> ; template < class O > constexpr auto and_then ( O && op ) const & -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T const &> , failure < E >> , std :: invoke_result_t < O , T >> ; template < class O > constexpr auto and_then ( O && op ) && -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T &&> , failure < E >> , std :: invoke_result_t < O , T >> ; }; Calls op if the result is success, otherwise returns the failure value of self. This function can be used for control flow based on result values. Remarks and_then ( O && ) qualifier shall not participate in overload resolution unless is_convertible_result_with_v < std :: invoke_result_t < O && , T qualifier > , failure < E >> is true. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; result < int , int > x = success ( 2u ); result < int , int > y = failure ( 3u ); assert ( x . and_then ( sq ). and_then ( sq ) == success ( 16u )); assert ( x . and_then ( sq ). and_then ( err ) == failure ( 4u )); assert ( x . and_then ( err ). and_then ( sq ) == failure ( 2u )); assert ( y . and_then ( sq ). and_then ( sq ) == failure ( 3u )); } // end example","title":"and_then"},{"location":"result/APIs/#disj","text":"basic_result< , T, E>::disj(basic_result< , T, F> res) -> basic_result<_, T, F> template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr auto basic_result < _ , T , E >:: disj ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; template < class F > constexpr auto basic_result < _ , T , E >:: operator || ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; }; Returns res if the result is failure , otherwise returns the success value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < unsigned , std :: string > y = success ( 2 ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert ( x . disj ( y ) == failure ( \"late error\" s )); assert (( x || y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = success ( 100 ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } } // end example","title":"disj"},{"location":"result/APIs/#or_else","text":"basic_result< , T, E>or_else(O op) -> basic_result< , T, F> where O: E -> basic_result<_, T, F> template < mutability _mu , class T , class E > class basic_result { template < class O > constexpr auto basic_result < _ , T , E >:: or_else ( O && op ) const & -> std :: invoke_result < O && , E > ; }; Calls op if the result is failure , otherwise returns the success value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v < std :: invoke_result_t < O , T > , success < T >> is true. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; result < int , int > x = success ( 2u ); result < int , int > y = failure ( 3u ); assert ( x . or_else ( sq ). or_else ( sq ) == success ( 2u )); assert ( x . or_else ( err ). or_else ( sq ) == success ( 2u )); assert ( y . or_else ( sq ). or_else ( err ) == success ( 9u )); assert ( y . or_else ( err ). or_else ( err ) == failure ( 3u )); } // end example","title":"or_else"},{"location":"result/APIs/#unwrap_or","text":"basic_result<_, T, E>::unwrap_or(T const& optb) -> T template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , T , E >:: unwrap_or ( T const & optb ) const noexcept }; Unwraps a result, yielding the content of an success . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , unsigned > ok = success ( 2 ); result < unsigned , unsigned > err = failure ( 2 ); assert ( ok . unwrap_or ( 1u ) == 2u ); assert ( err . unwrap_or ( 1u ) == 1u ); } // end example","title":"unwrap_or"},{"location":"result/APIs/#unwrap_or_else","text":"basic_result<_, T, E>::unwrap_or_else() -> T template < mutability _mu , class T , class E > class basic_result { template < class O > auto basic_result < _ , T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > ; }; Unwraps a result, yielding the content of an success . If the value is an failure then it invokes op with its value. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < int , std :: string > ok = success ( 2 ); result < int , std :: string > err = failure ( \"foo\" s ); assert ( ok . unwrap_or_else ( & std :: string :: size ) == 2 ); assert ( err . unwrap_or_else ( & std :: string :: size ) == 3 ); } // end example","title":"unwrap_or_else"},{"location":"result/APIs/#unwrap","text":"basic_result<_, T, E>::unwrap() -> E& template < class T , class E > class basic_result < mutability :: immut , T , E > { auto unwrap () & -> const T ; auto unwrap () const & -> const T ; auto unwrap () && -> const T ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { auto unwrap () & -> T ; auto unwrap () const & -> const T ; auto unwrap () && -> T ; }; Unwraps a result, yielding the content of an success . Exception Raise mitama :: runtime_panic if a result is containing failure value. Remarks If self is rvalue and T is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < T >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); assert ( x . unwrap () == 2 ); } try { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; } } // end example","title":"unwrap"},{"location":"result/APIs/#unwrap_err","text":"basic_result<_, T, E>::unwrap_err() -> E& template < class T , class E > class basic_result < mutability :: immut , T , E > { auto unwrap_err () & -> const E ; auto unwrap_err () const & -> const E ; auto unwrap_err () && -> const E ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { auto mut_unwrap_err () & -> E ; auto mut_unwrap_err () const & -> const E ; auto mut_unwrap_err () && -> E ; }; Unwraps a result, yielding the content of an failure . Exception Raise mitama :: runtime_panic if a result is containing success value. Remarks If self is rvalue and E is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { try { result < unsigned , std :: string > x = success ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; } { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); assert ( x . unwrap_err () == \"emergency failure\" s ); } } // end example","title":"unwrap_err"},{"location":"result/APIs/#unwrap_or_default","text":"basic_result<_, T, E>::unwrap_or_default() -> T where T is default constructible template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , T , E >:: unwrap_or_default () const & -> T ; }; Returns the contained value or a default. If success , returns the contained value, otherwise if failure , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < int > good = success ( 1909 ); result < int > bad = failure <> (); auto good_year = good . unwrap_or_default (); auto bad_year = bad . unwrap_or_default (); assert ( 1909 == good_year ); assert ( 0 == bad_year ); } // end example","title":"unwrap_or_default"},{"location":"result/APIs/#transpose","text":"basic_result< , maybe&ltT>, E>::transpose() -> maybe<basic_result< , T, E>> template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; }; Transposes a result of a maybe into a maybe of a result . success ( nothing ) will be mapped to nothing . success ( just ( v )) and failure ( v ) will be mapped to just ( success ( v )) and just ( failure ( v )) . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; int main () { result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); assert ( x . transpose () == y ); } // end example","title":"transpose"},{"location":"result/APIs/#and_finally","text":"basic_result::and_finally(F f) -> void template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &&>> and_finally ( F && f ) const & ; }; Invokes the provided function with the contained success value (if success), or doing nothing (if failure). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { result < int , std :: string > x = success ( 42 ); int hook = 0 ; x . and_finally ([ & ]( int const & v ){ hook = v ; }); assert ( hook == 42 ); } // end example","title":"and_finally"},{"location":"result/APIs/#or_finally","text":"basic_result::or_finally(F f) -> void template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &&>> and_finally ( F && f ) const & ; }; Invokes the provided function with contained failure value (if failure), or doing nothing (if success). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":"or_finally"},{"location":"result/APIs/#and_peek","text":"basic_result::and_peek(F f) -> basic_result template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> and_peek ( F && f ) && ; }; Peeks the contained success value and then returns self. Invokes the provided function with the contained value and then return self (if success), or return self without doing anything (if failure). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { result < int , std :: string > x = success ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == success ( 42 )); assert ( hook == 42 ); } // end example","title":"and_peek"},{"location":"result/APIs/#or_peek","text":"basic_result::or_peek(F f) -> basic_result template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> or_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> or_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> or_peek ( F && f ) && ; }; Peeks the contained failure value and then returns self. Invokes the provided function and then return self (if failure), or return self without doing anything (if success). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":"or_peek"},{"location":"result/comparisons/","text":"operator==, !=, <, <=, >, >=(basic_result) \u00b6 namespace mitama { // Compare two basic_result objects template < class T , class E , class U , class F > constexpr bool operator == ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (1) template < class T , class E , class U , class F > constexpr bool operator != ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (2) template < class T , class E , class U , class F > constexpr bool operator < ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (3) template < class T , class E , class U , class F > constexpr bool operator <= ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (4) template < class T , class E , class U , class F > constexpr bool operator > ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (5) template < class T , class E , class U , class F > constexpr bool operator >= ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (6) // Compare a basic_result object with a success(value) template < class T , class E , class U > constexpr bool operator == ( const basic_result < T , E >& res , success < U > const & ok ); // (7) template < class T , class E , class U > constexpr bool operator == ( success < T > const & ok , const basic_result < U , E >& res ); // (8) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , success < U > const & ok ); // (9) template < class T , class E , class U > constexpr bool operator != ( success < T > const & ok , const basic_result < U , E >& res ); // (10) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , success < U > const & ok ); // (11) template < class T , class E , class U > constexpr bool operator < ( success < T > const & ok , const basic_result < U , E >& res ); // (12) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , success < U > const & ok ); // (13) template < class T , class E , class U > constexpr bool operator <= ( success < T > const & ok , const basic_result < U , E >& res ); // (14) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , success < U > const & ok ); // (15) template < class T , class E , class U > constexpr bool operator > ( success < T > const & ok , const basic_result < U , E >& res ); // (16) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , success < U > const & ok ); // (17) template < class T , class E , class U > constexpr bool operator >= ( success < T > const & ok , const basic_result < U , E >& res ); // (18) // Compare a basic_result object with a failure(value) template < class T , class E , class F > constexpr bool operator == ( const basic_result < T , E >& res , failure < F > const & err ); // (19) template < class T , class E , class U > constexpr bool operator == ( failure < E > const & err , const basic_result < T , F >& res ); // (20) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , failure < F > const & err ); // (21) template < class T , class E , class U > constexpr bool operator != ( failure < E > const & err , const basic_result < T , F >& res ); // (22) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , failure < F > const & err ); // (23) template < class T , class E , class U > constexpr bool operator < ( failure < E > const & err , const basic_result < T , F >& res ); // (24) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , failure < F > const & err ); // (25) template < class T , class E , class U > constexpr bool operator <= ( failure < E > const & err , const basic_result < T , F >& res ); // (26) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , failure < F > const & err ); // (27) template < class T , class E , class U > constexpr bool operator > ( failure < E > const & err , const basic_result < T , F >& res ); // (28) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , failure < F > const & err ); // (29) template < class T , class E , class U > constexpr bool operator >= ( failure < E > const & err , const basic_result < T , F >& res ); // (30) // Compare a basic_result object with a T template < class T , class E , class U > constexpr bool operator == ( const basic_result < T , E >& res , const U & value ); // (31) template < class T , class E , class U > constexpr bool operator == ( const T & value , const basic_result < U , E >& res ); // (32) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , const U & value ); // (33) template < class T , class E , class U > constexpr bool operator != ( const T & value , const basic_result < U , E >& res ); // (34) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , const U & value ); // (35) template < class T , class E , class U > constexpr bool operator < ( const T & value , const basic_result < U , E >& res ); // (36) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , const U & value ); // (37) template < class T , class E , class U > constexpr bool operator <= ( const T & value , const basic_result < U , E >& res ); // (38) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , const U & value ); // (39) template < class T , class E , class U > constexpr bool operator > ( const T & value , const basic_result < U , E >& res ); // (40) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , const U & value ); // (41) template < class T , class E , class U > constexpr bool operator >= ( const T & value , const basic_result < U , E >& res ); // (42) } Performs comparison operations on basic_result objects. 1-6) Compares two basic_result objects, lhs and rhs . The contained values are compared (using the corresponding operator of T and U or E and F ) only if the contents of lhs and rhs are either both success values or are both failure values. Otherwise, lhs is considered less than rhs if, and only if, rhs contains a success value and lhs does failure value. lhs is considered less than rhs if, and only if, rhs contains a failure value and lhs does success value. 7-18) Compares res with a ok . The values are compared (using the corresponding operator of E and F ) only if res contains a success value. Otherwise, res is considered less than ok . If the corresponding comparison expression between res . unwrap () and success value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 19-30) Compares res with a err . The values are compared (using the corresponding operator of T and U ) only if res contains a success value. Otherwise, res is considered greater than err . If the corresponding comparison expression between res . unwrap () and failure value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 31-42) Compares res with a value . Equivalent to (7-18) expression res ~ success ( value ) or success ( value ) ~ res . Parameters lhs , rhs , res - basic_result object to compare ok - a success object to compare err - a failure object to compare value - value to compare to the contained value Return value If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () == rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () == rhs . unwrap_err () Otherwise, if returns false . If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () != rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () != rhs . unwrap_err () Otherwise, if returns true . If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () < rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () < rhs . unwrap_err () Otherwise, if lhs . is_err () && rhs . is_ok () , returns true Otherwise, returns false . If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () <= rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () <= rhs . unwrap_err () Otherwise, if lhs . is_err () && rhs . is_ok () , returns true Otherwise, returns false . If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () > rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () > rhs . unwrap_err () Otherwise, if lhs . is_ok () && rhs . is_err () , returns true Otherwise, returns false . If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () >= rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () >= rhs . unwrap_err () Otherwise, if lhs . is_ok () && rhs . is_err () , returns true Otherwise, returns false . Returns res . is_ok () ? res . unwrap () == ok . value : false . Returns res . is_ok () ? ok . value == res . unwrap () : false . Returns res . is_ok () ? res . unwrap () != ok . value : true . Returns res . is_ok () ? ok . value != res . unwrap () : true . Returns res . is_ok () ? res . unwrap () < ok . value : true . Returns res . is_ok () ? ok . value < res . unwrap () : false . Returns res . is_ok () ? res . unwrap () <= ok . value : true . Returns res . is_ok () ? ok . value <= res . unwrap () : false . Returns res . is_ok () ? res . unwrap () > ok . value : false . Returns res . is_ok () ? ok . value > res . unwrap () : true . Returns res . is_ok () ? res . unwrap () >= ok . value : false . Returns res . is_ok () ? ok . value >= res . unwrap () : true . Returns res . is_err () ? res . unwrap_err () == err . value : false . Returns res . is_err () ? err . value == res . unwrap_err () : false . Returns res . is_err () ? res . unwrap_err () != err . value : true . Returns res . is_err () ? err . value != res . unwrap_err () : true . Returns res . is_err () ? res . unwrap_err () < err . value : false . Returns res . is_err () ? err . value < res . unwrap_err () : true . Returns res . is_err () ? res . unwrap_err () <= err . value : false . Returns res . is_err () ? err . value <= res . unwrap_err () : true . Returns res . is_err () ? res . unwrap_err () > err . value : true . Returns res . is_err () ? err . value > res . unwrap_err () : false . Returns res . is_err () ? res . unwrap_err () >= err . value : false . Returns res . is_err () ? err . value >= res . unwrap_err () : true . Returns res == success ( value ) . Returns success ( value ) == res . Returns res != success ( value ) . Returns success ( value ) != res . Returns res < success ( value ) . Returns success ( value ) < res . Returns res <= success ( value ) . Returns success ( value ) <= res . Returns res > success ( value ) . Returns success ( value ) > res . Returns res >= success ( value ) . Returns success ( value ) >= res . Note err . value , ok . value : value is a private member of success or failure (actually, cannot access to it).","title":"Comparisons"},{"location":"result/comparisons/#operator_basic_result","text":"namespace mitama { // Compare two basic_result objects template < class T , class E , class U , class F > constexpr bool operator == ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (1) template < class T , class E , class U , class F > constexpr bool operator != ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (2) template < class T , class E , class U , class F > constexpr bool operator < ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (3) template < class T , class E , class U , class F > constexpr bool operator <= ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (4) template < class T , class E , class U , class F > constexpr bool operator > ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (5) template < class T , class E , class U , class F > constexpr bool operator >= ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (6) // Compare a basic_result object with a success(value) template < class T , class E , class U > constexpr bool operator == ( const basic_result < T , E >& res , success < U > const & ok ); // (7) template < class T , class E , class U > constexpr bool operator == ( success < T > const & ok , const basic_result < U , E >& res ); // (8) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , success < U > const & ok ); // (9) template < class T , class E , class U > constexpr bool operator != ( success < T > const & ok , const basic_result < U , E >& res ); // (10) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , success < U > const & ok ); // (11) template < class T , class E , class U > constexpr bool operator < ( success < T > const & ok , const basic_result < U , E >& res ); // (12) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , success < U > const & ok ); // (13) template < class T , class E , class U > constexpr bool operator <= ( success < T > const & ok , const basic_result < U , E >& res ); // (14) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , success < U > const & ok ); // (15) template < class T , class E , class U > constexpr bool operator > ( success < T > const & ok , const basic_result < U , E >& res ); // (16) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , success < U > const & ok ); // (17) template < class T , class E , class U > constexpr bool operator >= ( success < T > const & ok , const basic_result < U , E >& res ); // (18) // Compare a basic_result object with a failure(value) template < class T , class E , class F > constexpr bool operator == ( const basic_result < T , E >& res , failure < F > const & err ); // (19) template < class T , class E , class U > constexpr bool operator == ( failure < E > const & err , const basic_result < T , F >& res ); // (20) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , failure < F > const & err ); // (21) template < class T , class E , class U > constexpr bool operator != ( failure < E > const & err , const basic_result < T , F >& res ); // (22) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , failure < F > const & err ); // (23) template < class T , class E , class U > constexpr bool operator < ( failure < E > const & err , const basic_result < T , F >& res ); // (24) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , failure < F > const & err ); // (25) template < class T , class E , class U > constexpr bool operator <= ( failure < E > const & err , const basic_result < T , F >& res ); // (26) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , failure < F > const & err ); // (27) template < class T , class E , class U > constexpr bool operator > ( failure < E > const & err , const basic_result < T , F >& res ); // (28) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , failure < F > const & err ); // (29) template < class T , class E , class U > constexpr bool operator >= ( failure < E > const & err , const basic_result < T , F >& res ); // (30) // Compare a basic_result object with a T template < class T , class E , class U > constexpr bool operator == ( const basic_result < T , E >& res , const U & value ); // (31) template < class T , class E , class U > constexpr bool operator == ( const T & value , const basic_result < U , E >& res ); // (32) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , const U & value ); // (33) template < class T , class E , class U > constexpr bool operator != ( const T & value , const basic_result < U , E >& res ); // (34) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , const U & value ); // (35) template < class T , class E , class U > constexpr bool operator < ( const T & value , const basic_result < U , E >& res ); // (36) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , const U & value ); // (37) template < class T , class E , class U > constexpr bool operator <= ( const T & value , const basic_result < U , E >& res ); // (38) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , const U & value ); // (39) template < class T , class E , class U > constexpr bool operator > ( const T & value , const basic_result < U , E >& res ); // (40) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , const U & value ); // (41) template < class T , class E , class U > constexpr bool operator >= ( const T & value , const basic_result < U , E >& res ); // (42) } Performs comparison operations on basic_result objects. 1-6) Compares two basic_result objects, lhs and rhs . The contained values are compared (using the corresponding operator of T and U or E and F ) only if the contents of lhs and rhs are either both success values or are both failure values. Otherwise, lhs is considered less than rhs if, and only if, rhs contains a success value and lhs does failure value. lhs is considered less than rhs if, and only if, rhs contains a failure value and lhs does success value. 7-18) Compares res with a ok . The values are compared (using the corresponding operator of E and F ) only if res contains a success value. Otherwise, res is considered less than ok . If the corresponding comparison expression between res . unwrap () and success value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 19-30) Compares res with a err . The values are compared (using the corresponding operator of T and U ) only if res contains a success value. Otherwise, res is considered greater than err . If the corresponding comparison expression between res . unwrap () and failure value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 31-42) Compares res with a value . Equivalent to (7-18) expression res ~ success ( value ) or success ( value ) ~ res . Parameters lhs , rhs , res - basic_result object to compare ok - a success object to compare err - a failure object to compare value - value to compare to the contained value Return value If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () == rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () == rhs . unwrap_err () Otherwise, if returns false . If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () != rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () != rhs . unwrap_err () Otherwise, if returns true . If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () < rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () < rhs . unwrap_err () Otherwise, if lhs . is_err () && rhs . is_ok () , returns true Otherwise, returns false . If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () <= rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () <= rhs . unwrap_err () Otherwise, if lhs . is_err () && rhs . is_ok () , returns true Otherwise, returns false . If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () > rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () > rhs . unwrap_err () Otherwise, if lhs . is_ok () && rhs . is_err () , returns true Otherwise, returns false . If lhs . is_ok () && rhs . is_ok () , returns lhs . unwrap () >= rhs . unwrap () . Otherwise, if lhs . is_err () && rhs . is_err () , returns lhs . unwrap_err () >= rhs . unwrap_err () Otherwise, if lhs . is_ok () && rhs . is_err () , returns true Otherwise, returns false . Returns res . is_ok () ? res . unwrap () == ok . value : false . Returns res . is_ok () ? ok . value == res . unwrap () : false . Returns res . is_ok () ? res . unwrap () != ok . value : true . Returns res . is_ok () ? ok . value != res . unwrap () : true . Returns res . is_ok () ? res . unwrap () < ok . value : true . Returns res . is_ok () ? ok . value < res . unwrap () : false . Returns res . is_ok () ? res . unwrap () <= ok . value : true . Returns res . is_ok () ? ok . value <= res . unwrap () : false . Returns res . is_ok () ? res . unwrap () > ok . value : false . Returns res . is_ok () ? ok . value > res . unwrap () : true . Returns res . is_ok () ? res . unwrap () >= ok . value : false . Returns res . is_ok () ? ok . value >= res . unwrap () : true . Returns res . is_err () ? res . unwrap_err () == err . value : false . Returns res . is_err () ? err . value == res . unwrap_err () : false . Returns res . is_err () ? res . unwrap_err () != err . value : true . Returns res . is_err () ? err . value != res . unwrap_err () : true . Returns res . is_err () ? res . unwrap_err () < err . value : false . Returns res . is_err () ? err . value < res . unwrap_err () : true . Returns res . is_err () ? res . unwrap_err () <= err . value : false . Returns res . is_err () ? err . value <= res . unwrap_err () : true . Returns res . is_err () ? res . unwrap_err () > err . value : true . Returns res . is_err () ? err . value > res . unwrap_err () : false . Returns res . is_err () ? res . unwrap_err () >= err . value : false . Returns res . is_err () ? err . value >= res . unwrap_err () : true . Returns res == success ( value ) . Returns success ( value ) == res . Returns res != success ( value ) . Returns success ( value ) != res . Returns res < success ( value ) . Returns success ( value ) < res . Returns res <= success ( value ) . Returns success ( value ) <= res . Returns res > success ( value ) . Returns success ( value ) > res . Returns res >= success ( value ) . Returns success ( value ) >= res . Note err . value , ok . value : value is a private member of success or failure (actually, cannot access to it).","title":"operator==, !=, &lt;, &lt;=, &gt;, &gt;=(basic_result)"},{"location":"result/intro/","text":"Introduction \u00b6 Definition of class basic_result \u00b6 enum class mutability : bool { mut = false , immut = true , }; template < mutability Mut > inline constexpr bool is_mut_v = ! static_cast < bool > ( Mut ); template < mutability , class = std :: monostate , // success type class = std :: monostate , // failure type class = decltype ( nullptr ) // for detection idiom > class basic_result ; Concepts \u00b6 basic_result < _ , T , E > is a class that holds either a success value type T or a failure value type E . basic_result < _ , T , E > holds values like boost :: variant < T , E > . Therefore, T and E must satisfy the following requirements for bounded types: CopyConstructible or MoveConstructible. Destructor upholds the no-throw exception-safety guarantee. Complete at the point of variant template instantiation. In more detail, see the document . result/mut_result the alias templates \u00b6 First (non-type) template parameter of basic_result is a value of enum class mutability for mutability control. The library provides two type synonyms of basic_result as follows: mut_result < T , E > stands for basic_result < mutability :: mut , T , E > result < T , E > stands for basic_result < mutability :: immut , T , E > You should use mut_result < T , E > if you want to resubstitute, result < T , E > do not provides assignment operators or mutable accessors. success/failure the in-place factory classes \u00b6 success and failure are in-place factory classes for basic_result . If you want to initialize result < T , E > with successful value of T , initialize with success < T > . result < int , std :: string > res = success ( 42 ); Similarly, if you want to initialize result < T , E > with unsuccessful value of E , initialize with failure < E > . result < int , std :: string > res = failure ( \"error\" s ); Result of reference types \u00b6 (In Progress...)","title":"Result 101"},{"location":"result/intro/#introduction","text":"","title":"Introduction"},{"location":"result/intro/#definition_of_class_basic_result","text":"enum class mutability : bool { mut = false , immut = true , }; template < mutability Mut > inline constexpr bool is_mut_v = ! static_cast < bool > ( Mut ); template < mutability , class = std :: monostate , // success type class = std :: monostate , // failure type class = decltype ( nullptr ) // for detection idiom > class basic_result ;","title":"Definition of class basic_result"},{"location":"result/intro/#concepts","text":"basic_result < _ , T , E > is a class that holds either a success value type T or a failure value type E . basic_result < _ , T , E > holds values like boost :: variant < T , E > . Therefore, T and E must satisfy the following requirements for bounded types: CopyConstructible or MoveConstructible. Destructor upholds the no-throw exception-safety guarantee. Complete at the point of variant template instantiation. In more detail, see the document .","title":"Concepts"},{"location":"result/intro/#resultmut_result_the_alias_templates","text":"First (non-type) template parameter of basic_result is a value of enum class mutability for mutability control. The library provides two type synonyms of basic_result as follows: mut_result < T , E > stands for basic_result < mutability :: mut , T , E > result < T , E > stands for basic_result < mutability :: immut , T , E > You should use mut_result < T , E > if you want to resubstitute, result < T , E > do not provides assignment operators or mutable accessors.","title":"result/mut_result the alias templates"},{"location":"result/intro/#successfailure_the_in-place_factory_classes","text":"success and failure are in-place factory classes for basic_result . If you want to initialize result < T , E > with successful value of T , initialize with success < T > . result < int , std :: string > res = success ( 42 ); Similarly, if you want to initialize result < T , E > with unsuccessful value of E , initialize with failure < E > . result < int , std :: string > res = failure ( \"error\" s );","title":"success/failure the in-place factory classes"},{"location":"result/intro/#result_of_reference_types","text":"(In Progress...)","title":"Result of reference types"},{"location":"result/metafunctions/","text":"is_result \u00b6 template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ; is_result_with \u00b6 template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"Meta Functions"},{"location":"result/metafunctions/#is_result","text":"template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":"is_result"},{"location":"result/metafunctions/#is_result_with","text":"template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"is_result_with"},{"location":"result/special_members/","text":"Constructors \u00b6 default constructor (deleted) [0/16] \u00b6 Default constructor is not permitted. explicit copy constructor for convertible basic_result [1/16] \u00b6 template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v < T , U > && is_nothrow_copy_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true and std :: disjunction < std :: negation < std :: is_convertible < F , E >> , std :: negation < std :: is_convertible < U , T >>> is true. If is_trivially_copy_constructible_v < T , U > && is_trivially_copy_constructible_v < E , F > is true, this constructor shall be a constexpr constructor. non-explicit copy constructor for convertible basic_result [2/16] \u00b6 template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v < T , U > && is_nothrow_copy_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true, std :: is_convertible < F , E > is true and, std :: is_convertible < U , T >> is true. If is_trivially_copy_constructible_v < T , U > && is_trivially_copy_constructible_v < E , F > is true, this constructor shall be a constexpr constructor. explicit move constructor for convertible basic_result [3/16] \u00b6 template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v < T , U > && is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true and, std :: disjunction < std :: negation < std :: is_convertible < F , E >> , std :: negation < std :: is_convertible < U , T >>> is true. If is_trivially_move_constructible_v < T , U > && is_trivially_move_constructible_v < E , F > is true, this constructor shall be a constexpr constructor. non-explicit copy constructor for convertible basic_result [4/16] \u00b6 template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v < T , U > && is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true, std :: is_convertible < F , E > is true and, std :: is_convertible < U , T >> is true. If is_trivially_move_constructible_v < T , U > && is_trivially_move_constructible_v < E , F > is true, this constructor shall be a constexpr constructor. non-explicit copy constructor from success [5/16] \u00b6 template < class U > basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && is_convertible_v < U , T > is true. explicit copy constructor from success [6/16] \u00b6 template < class U > explicit basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && ! is_convertible_v < U , T > is true. non-explicit move constructor from success [7/16] \u00b6 template < class U > basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && is_convertible_v < U , T > is true. explicit move constructor from success [8/16] \u00b6 template < class U > explicit basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && ! is_convertible_v < U , T > is true. non-explicit copy constructor from failure [9/16] \u00b6 template < class F > basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && is_convertible_v < F , E > is true. explicit copy constructor from failure [10/16] \u00b6 template < class F > explicit basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && ! is_convertible_v < F , E > is true. non-explicit move constructor from failure [11/16] \u00b6 template < class F > basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && is_convertible_v < F , E > is true. explicit move constructor from failure [12/16] \u00b6 template < class F > explicit basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E >&& . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , U > && ! is_convertible_v < U , E > is true. emplace constructor for successful results [13/16] \u00b6 template < class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , Args && ... args ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( success < T > ( std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , Args && ... > is true, this constructor shall be a nothrow constructor. Example using my_result = result < std :: tuple < int , int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , 1 , 1 ); // same as `my_result(success(std::tuple{1,1}))` emplace constructor for unsuccessful results [14/16] \u00b6 template < class ... Args > explicit basic_result :: basic_result ( in_place_err_t , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( failure < E > ( std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , Args && ... > is true, this constructor shall be a nothrow constructor. Example using my_result = result < int , std :: string > ; auto res = my_result ( mitama :: in_place_err , 'a' , 5 ); // failure(\"aaaaa\") emplace constructor with initializer_list for successful results [15/16] \u00b6 template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( success < T > ( il , std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of T. Example using my_result = result < std :: vector < int > , std :: string > ; auto res = my_result ( in_place_ok , { 1 , 2 , 3 , 4 }, std :: allocator < int > ()); // success([1,2,3,4]) emplace constructor with initializer_list for unsuccessful results [16/16] \u00b6 template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( failure < E > ( il , std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = result < std :: string , std :: vector < int >> ; auto res = my_result ( in_place_err , { 1 , 2 , 3 , 4 }); // failure([1,2,3,4]) Assignment operators \u00b6 copy assignment operator [1/6] \u00b6 template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F > const & res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable. move assignment operator [2/6] \u00b6 template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F >&& res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable. copy assignment operator for success [3/6] \u00b6 template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U > const & _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable. move assignment operator for success [4/6] \u00b6 template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U >&& _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable. copy assignment operator for failure [5/6] \u00b6 template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F > const & _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable. move assignment operator for failure [6/6] \u00b6 template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F >&& _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"Special Members"},{"location":"result/special_members/#constructors","text":"","title":"Constructors"},{"location":"result/special_members/#default_constructor_deleted_016","text":"Default constructor is not permitted.","title":"default constructor (deleted) [0/16]"},{"location":"result/special_members/#explicit_copy_constructor_for_convertible_basic_result_116","text":"template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v < T , U > && is_nothrow_copy_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true and std :: disjunction < std :: negation < std :: is_convertible < F , E >> , std :: negation < std :: is_convertible < U , T >>> is true. If is_trivially_copy_constructible_v < T , U > && is_trivially_copy_constructible_v < E , F > is true, this constructor shall be a constexpr constructor.","title":"explicit copy constructor for convertible basic_result [1/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_for_convertible_basic_result_216","text":"template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v < T , U > && is_nothrow_copy_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true, std :: is_convertible < F , E > is true and, std :: is_convertible < U , T >> is true. If is_trivially_copy_constructible_v < T , U > && is_trivially_copy_constructible_v < E , F > is true, this constructor shall be a constexpr constructor.","title":"non-explicit copy constructor for convertible basic_result [2/16]"},{"location":"result/special_members/#explicit_move_constructor_for_convertible_basic_result_316","text":"template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v < T , U > && is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true and, std :: disjunction < std :: negation < std :: is_convertible < F , E >> , std :: negation < std :: is_convertible < U , T >>> is true. If is_trivially_move_constructible_v < T , U > && is_trivially_move_constructible_v < E , F > is true, this constructor shall be a constexpr constructor.","title":"explicit move constructor for convertible basic_result [3/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_for_convertible_basic_result_416","text":"template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v < T , U > && is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true, std :: is_convertible < F , E > is true and, std :: is_convertible < U , T >> is true. If is_trivially_move_constructible_v < T , U > && is_trivially_move_constructible_v < E , F > is true, this constructor shall be a constexpr constructor.","title":"non-explicit copy constructor for convertible basic_result [4/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_from_success_516","text":"template < class U > basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && is_convertible_v < U , T > is true.","title":"non-explicit copy constructor from success [5/16]"},{"location":"result/special_members/#explicit_copy_constructor_from_success_616","text":"template < class U > explicit basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && ! is_convertible_v < U , T > is true.","title":"explicit copy constructor from success [6/16]"},{"location":"result/special_members/#non-explicit_move_constructor_from_success_716","text":"template < class U > basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && is_convertible_v < U , T > is true.","title":"non-explicit move constructor from success [7/16]"},{"location":"result/special_members/#explicit_move_constructor_from_success_816","text":"template < class U > explicit basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && ! is_convertible_v < U , T > is true.","title":"explicit move constructor from success [8/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_from_failure_916","text":"template < class F > basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && is_convertible_v < F , E > is true.","title":"non-explicit copy constructor from failure [9/16]"},{"location":"result/special_members/#explicit_copy_constructor_from_failure_1016","text":"template < class F > explicit basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && ! is_convertible_v < F , E > is true.","title":"explicit copy constructor from failure [10/16]"},{"location":"result/special_members/#non-explicit_move_constructor_from_failure_1116","text":"template < class F > basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && is_convertible_v < F , E > is true.","title":"non-explicit move constructor from failure [11/16]"},{"location":"result/special_members/#explicit_move_constructor_from_failure_1216","text":"template < class F > explicit basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E >&& . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , U > && ! is_convertible_v < U , E > is true.","title":"explicit move constructor from failure [12/16]"},{"location":"result/special_members/#emplace_constructor_for_successful_results_1316","text":"template < class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , Args && ... args ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( success < T > ( std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , Args && ... > is true, this constructor shall be a nothrow constructor. Example using my_result = result < std :: tuple < int , int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , 1 , 1 ); // same as `my_result(success(std::tuple{1,1}))`","title":"emplace constructor for successful results [13/16]"},{"location":"result/special_members/#emplace_constructor_for_unsuccessful_results_1416","text":"template < class ... Args > explicit basic_result :: basic_result ( in_place_err_t , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( failure < E > ( std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , Args && ... > is true, this constructor shall be a nothrow constructor. Example using my_result = result < int , std :: string > ; auto res = my_result ( mitama :: in_place_err , 'a' , 5 ); // failure(\"aaaaa\")","title":"emplace constructor for unsuccessful results [14/16]"},{"location":"result/special_members/#emplace_constructor_with_initializer_list_for_successful_results_1516","text":"template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( success < T > ( il , std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of T. Example using my_result = result < std :: vector < int > , std :: string > ; auto res = my_result ( in_place_ok , { 1 , 2 , 3 , 4 }, std :: allocator < int > ()); // success([1,2,3,4])","title":"emplace constructor with initializer_list for successful results [15/16]"},{"location":"result/special_members/#emplace_constructor_with_initializer_list_for_unsuccessful_results_1616","text":"template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( failure < E > ( il , std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = result < std :: string , std :: vector < int >> ; auto res = my_result ( in_place_err , { 1 , 2 , 3 , 4 }); // failure([1,2,3,4])","title":"emplace constructor with initializer_list for unsuccessful results [16/16]"},{"location":"result/special_members/#assignment_operators","text":"","title":"Assignment operators"},{"location":"result/special_members/#copy_assignment_operator_16","text":"template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F > const & res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator [1/6]"},{"location":"result/special_members/#move_assignment_operator_26","text":"template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F >&& res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator [2/6]"},{"location":"result/special_members/#copy_assignment_operator_for_success_36","text":"template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U > const & _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator for success [3/6]"},{"location":"result/special_members/#move_assignment_operator_for_success_46","text":"template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U >&& _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator for success [4/6]"},{"location":"result/special_members/#copy_assignment_operator_for_failure_56","text":"template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F > const & _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator for failure [5/6]"},{"location":"result/special_members/#move_assignment_operator_for_failure_66","text":"template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F >&& _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator for failure [6/6]"},{"location":"result/_APIs/","text":"CHANGELOG \u00b6 v5.0.0 (breaking change!) Types \u00b6 basic_result { Result < T , E > => basic_result < mutability , T , E > } Enabled lvalue reference types for both of T and E result < T , E > the alias template for immutable basic_result mut_result < T , E > the alias template for mutable basic_result success { Ok < T > => success < T > } Enabled lvalue reference types for T . failure { Err < E > => failure < E > } Enabled lvalue reference types for E . New APIs \u00b6 as_ref () as_mut () indirect () indirect_ok () indirect_err () v1.2.0 enhancement \u00b6 new API: transpose new API: map_or_else v1.1.2 bug fix \u00b6 Result ::and_then(O&& op) do not perticipate in overload resolution if unless op returns Result < U , E > . std :: invoke_result_t < O && , T > must be returns Result < U , E > . It means op must only maps T -> U , never changes E . Result ::or_else(O&& op) do not perticipate in overload resolution if unless op returns Result < T , F > . std :: invoke_result_t < O && , E > must be returns Result < T , F > . It means op must only maps E -> F , never changes T . v1.1.1 bug fix \u00b6 Result ::unwrap_or_default() is now explicitly deleted if and only if std :: is_default_constructible_v < T > || std :: is_aggregate_v < T > is false.","title":"CHANGELOG"},{"location":"result/_APIs/#changelog","text":"v5.0.0 (breaking change!)","title":"CHANGELOG"},{"location":"result/_APIs/#types","text":"basic_result { Result < T , E > => basic_result < mutability , T , E > } Enabled lvalue reference types for both of T and E result < T , E > the alias template for immutable basic_result mut_result < T , E > the alias template for mutable basic_result success { Ok < T > => success < T > } Enabled lvalue reference types for T . failure { Err < E > => failure < E > } Enabled lvalue reference types for E .","title":"Types"},{"location":"result/_APIs/#new_apis","text":"as_ref () as_mut () indirect () indirect_ok () indirect_err () v1.2.0","title":"New APIs"},{"location":"result/_APIs/#enhancement","text":"new API: transpose new API: map_or_else v1.1.2","title":"enhancement"},{"location":"result/_APIs/#bug_fix","text":"Result ::and_then(O&& op) do not perticipate in overload resolution if unless op returns Result < U , E > . std :: invoke_result_t < O && , T > must be returns Result < U , E > . It means op must only maps T -> U , never changes E . Result ::or_else(O&& op) do not perticipate in overload resolution if unless op returns Result < T , F > . std :: invoke_result_t < O && , E > must be returns Result < T , F > . It means op must only maps E -> F , never changes T . v1.1.1","title":"bug fix"},{"location":"result/_APIs/#bug_fix_1","text":"Result ::unwrap_or_default() is now explicitly deleted if and only if std :: is_default_constructible_v < T > || std :: is_aggregate_v < T > is false.","title":"bug fix"},{"location":"result/_APIs/and_finally/","text":"basic_result::and_finally(F f) -> void template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &&>> and_finally ( F && f ) const & ; }; Invokes the provided function with the contained success value (if success), or doing nothing (if failure). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { result < int , std :: string > x = success ( 42 ); int hook = 0 ; x . and_finally ([ & ]( int const & v ){ hook = v ; }); assert ( hook == 42 ); } // end example","title":""},{"location":"result/_APIs/and_peek/","text":"basic_result::and_peek(F f) -> basic_result template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> and_peek ( F && f ) && ; }; Peeks the contained success value and then returns self. Invokes the provided function with the contained value and then return self (if success), or return self without doing anything (if failure). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { result < int , std :: string > x = success ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == success ( 42 )); assert ( hook == 42 ); } // end example","title":""},{"location":"result/_APIs/and_then/","text":"basic_result< , T, E>::and_then(O op) -> basic_result< , U, E> where O: T -> basic_result<_, U, E> template < mutability _mu , class T , class E > class basic_result { template < class O , std :: enable_of > constexpr auto and_then ( O && op ) & -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T &> , failure < E >> , std :: invoke_result_t < O , T >> ; template < class O > constexpr auto and_then ( O && op ) const & -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T const &> , failure < E >> , std :: invoke_result_t < O , T >> ; template < class O > constexpr auto and_then ( O && op ) && -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T &&> , failure < E >> , std :: invoke_result_t < O , T >> ; }; Calls op if the result is success, otherwise returns the failure value of self. This function can be used for control flow based on result values. Remarks and_then ( O && ) qualifier shall not participate in overload resolution unless is_convertible_result_with_v < std :: invoke_result_t < O && , T qualifier > , failure < E >> is true. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; result < int , int > x = success ( 2u ); result < int , int > y = failure ( 3u ); assert ( x . and_then ( sq ). and_then ( sq ) == success ( 16u )); assert ( x . and_then ( sq ). and_then ( err ) == failure ( 4u )); assert ( x . and_then ( err ). and_then ( sq ) == failure ( 2u )); assert ( y . and_then ( sq ). and_then ( sq ) == failure ( 3u )); } // end example","title":""},{"location":"result/_APIs/conj/","text":"basic_result< , T, E>::conj(basic_result< , U, E> res) -> basic_result<_, U, E> template < mutability _mu , class T , class E > class basic_result { template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: conj ( basic_result < _ , U , E > const & res ) const & -> basic_result < U , E > ; template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: operator && ( basic_result < _ , U , E > const & res ) const & -> basic_result < U , E > ; }; Returns res if the result is success , otherwise returns the failure value of self. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < std :: string , std :: string > y = success ( \"foo\" s ); assert (( x && y ) == failure ( \"early error\" s )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"not a 2\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = success ( \"different result type\" s ); assert (( x && y ) == success ( \"different result type\" s )); } } // end example","title":""},{"location":"result/_APIs/disj/","text":"basic_result< , T, E>::disj(basic_result< , T, F> res) -> basic_result<_, T, F> template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr auto basic_result < _ , T , E >:: disj ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; template < class F > constexpr auto basic_result < _ , T , E >:: operator || ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; }; Returns res if the result is failure , otherwise returns the success value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < unsigned , std :: string > y = success ( 2 ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert ( x . disj ( y ) == failure ( \"late error\" s )); assert (( x || y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = success ( 100 ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } } // end example","title":""},{"location":"result/_APIs/err/","text":"basic_result<_, T, E>::err() -> maybe<E> template < class T , class E > class basic_result < mutability :: immut , T , E > { constexpr auto result < T , E >:: err () & -> maybe < const E > ; constexpr auto result < T , E >:: err () const & -> maybe < const E > ; constexpr auto result < T , E >:: err () && -> maybe < const E > ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { constexpr auto mut_result < T , E >:: err () & -> maybe < E > ; constexpr auto mut_result < T , E >:: err () const & -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () && -> maybe < E > ; }; Converts from basic_result to maybe . Converts self into a maybe , and discarding the success value, if any. Note that these functions propagate mutability to element type of maybe . Remarks If self is rvalue and E is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 2 ); assert ( x . err () == nothing ); result < unsigned , std :: string > y = failure ( \"Nothing here\" s ); assert ( y . err () == just ( \"Nothing here\" s )); } // end example","title":""},{"location":"result/_APIs/is_err/","text":"basic_result<_, T, E>::is_err() -> bool template < mutability _mu , class T , class E > class basic_result { constexpr bool is_err () const noexcept ; }; Returns true if the result is failure. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 3 ); assert ( x . is_err () == false ); result < unsigned , std :: string > y = failure ( \"Some error message\" s ); assert ( y . is_err () == true ); } // end example","title":""},{"location":"result/_APIs/is_ok/","text":"basic_result<_, T, E>:::is_ok() -> bool template < mutability _mu , class T , class E > class basic_result { constexpr bool is_ok () const noexcept ; }; Returns true if the result is success . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 3 ); assert ( x . is_ok () == true ); result < unsigned , std :: string > y = failure ( \"Some error message\" s ); assert ( y . is_ok () == false ); } // end example","title":""},{"location":"result/_APIs/map/","text":"basic_result< , T, E>::map(O op) -> basic_result< , U, E> where O: T -> U template < mutability _mu , class T , class E > class basic_result { constexpr auto map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , result < std :: invoke_result_t < O , T > , E >> ; }; Maps a result < T , E > to result < U , E > by applying a function to a contained success value, leaving an failure value untouched. This function can be used to compose the results of two functions. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> #include <boost/lambda/lambda.hpp> using namespace mitama ; using namespace std :: string_literals ; using boost :: lambda :: _1 ; int main () { result < int , int > ok = success ( 2 ); assert ( ok . map ( _1 * 2 ) == success ( 4 )); result < int , int > err = failure ( 2 ); assert ( err . map ( _1 * 2 ) == failure ( 2 )); } // end example","title":""},{"location":"result/_APIs/map_err/","text":"basic_result< , T, E>::map_err(O op) -> basic_result< , T, F> where O: E -> F template < mutability _mu , class T , class E > class basic_result { template < class O > constexpr auto map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , result < T , std :: invoke_result_t < O , E >>> ; }; Maps a result < T , E > to result < T , F > by applying a function to a contained failure value, leaving an success value untouched. This function can be used to pass through a successful result while handling an error. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; result < unsigned , unsigned > x = success ( 2 ); assert ( x . map_err ( stringify ) == success ( 2u )); result < unsigned , unsigned > y = failure ( 13 ); assert ( y . map_err ( stringify ) == failure ( \"error code: 13\" s )); } // end example","title":""},{"location":"result/_APIs/map_or_else/","text":"basic_result<_, T, E>::map_or_else(Fallback _fallback, Map _map) -> U where Fallback: E -> U, Map: T -> U, template < mutability _mu , class T , class E > class basic_result { template < class Map , class Fallback > constexpr auto map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; }; Maps a result < T , E > to U by applying a function to a contained success value, or a fallback function to a contained failure value. This function can be used to unpack a successful result while handling an error. Examples Basic usage: // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto k = 21 ; { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); } } // end example","title":""},{"location":"result/_APIs/ok/","text":"basic_result<_, T, E>::ok() -> maybe<T> template < class T , class E > class basic_result < mutability :: immut , T , E > { constexpr auto result < T , E >:: ok () & -> maybe < const T > ; constexpr auto result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto result < T , E >:: ok () && -> maybe < const T > ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { constexpr auto mut_result < T , E >:: ok () & -> maybe < T > ; constexpr auto mut_result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () && -> maybe < T > ; }; Converts from basic_result to maybe . Converts self into a maybe , and discarding the failure value, if any. Note that these functions propagate mutability to element type of maybe . Remarks If self is rvalue and T is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < T >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 2 ); assert ( x . ok () == just ( 2 )); result < unsigned , std :: string > y = failure ( \"Nothing here\" s ); assert ( y . ok () == nothing ); } // end example","title":""},{"location":"result/_APIs/or_else/","text":"basic_result< , T, E>or_else(O op) -> basic_result< , T, F> where O: E -> basic_result<_, T, F> template < mutability _mu , class T , class E > class basic_result { template < class O > constexpr auto basic_result < _ , T , E >:: or_else ( O && op ) const & -> std :: invoke_result < O && , E > ; }; Calls op if the result is failure , otherwise returns the success value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v < std :: invoke_result_t < O , T > , success < T >> is true. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; result < int , int > x = success ( 2u ); result < int , int > y = failure ( 3u ); assert ( x . or_else ( sq ). or_else ( sq ) == success ( 2u )); assert ( x . or_else ( err ). or_else ( sq ) == success ( 2u )); assert ( y . or_else ( sq ). or_else ( err ) == success ( 9u )); assert ( y . or_else ( err ). or_else ( err ) == failure ( 3u )); } // end example","title":""},{"location":"result/_APIs/or_finally/","text":"basic_result::or_finally(F f) -> void template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &&>> and_finally ( F && f ) const & ; }; Invokes the provided function with contained failure value (if failure), or doing nothing (if success). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":""},{"location":"result/_APIs/or_peek/","text":"basic_result::or_peek(F f) -> basic_result template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> or_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> or_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> or_peek ( F && f ) && ; }; Peeks the contained failure value and then returns self. Invokes the provided function and then return self (if failure), or return self without doing anything (if success). Example // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":""},{"location":"result/_APIs/transpose/","text":"basic_result< , maybe&ltT>, E>::transpose() -> maybe<basic_result< , T, E>> template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; }; Transposes a result of a maybe into a maybe of a result . success ( nothing ) will be mapped to nothing . success ( just ( v )) and failure ( v ) will be mapped to just ( success ( v )) and just ( failure ( v )) . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; int main () { result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); assert ( x . transpose () == y ); } // end example","title":""},{"location":"result/_APIs/unwrap/","text":"basic_result<_, T, E>::unwrap() -> E& template < class T , class E > class basic_result < mutability :: immut , T , E > { auto unwrap () & -> const T ; auto unwrap () const & -> const T ; auto unwrap () && -> const T ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { auto unwrap () & -> T ; auto unwrap () const & -> const T ; auto unwrap () && -> T ; }; Unwraps a result, yielding the content of an success . Exception Raise mitama :: runtime_panic if a result is containing failure value. Remarks If self is rvalue and T is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < T >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); assert ( x . unwrap () == 2 ); } try { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; } } // end example","title":""},{"location":"result/_APIs/unwrap_err/","text":"basic_result<_, T, E>::unwrap_err() -> E& template < class T , class E > class basic_result < mutability :: immut , T , E > { auto unwrap_err () & -> const E ; auto unwrap_err () const & -> const E ; auto unwrap_err () && -> const E ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { auto mut_unwrap_err () & -> E ; auto mut_unwrap_err () const & -> const E ; auto mut_unwrap_err () && -> E ; }; Unwraps a result, yielding the content of an failure . Exception Raise mitama :: runtime_panic if a result is containing success value. Remarks If self is rvalue and E is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> . Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { try { result < unsigned , std :: string > x = success ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; } { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); assert ( x . unwrap_err () == \"emergency failure\" s ); } } // end example","title":""},{"location":"result/_APIs/unwrap_or/","text":"basic_result<_, T, E>::unwrap_or(T const& optb) -> T template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , T , E >:: unwrap_or ( T const & optb ) const noexcept }; Unwraps a result, yielding the content of an success . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , unsigned > ok = success ( 2 ); result < unsigned , unsigned > err = failure ( 2 ); assert ( ok . unwrap_or ( 1u ) == 2u ); assert ( err . unwrap_or ( 1u ) == 1u ); } // end example","title":""},{"location":"result/_APIs/unwrap_or_default/","text":"basic_result<_, T, E>::unwrap_or_default() -> T where T is default constructible template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , T , E >:: unwrap_or_default () const & -> T ; }; Returns the contained value or a default. If success , returns the contained value, otherwise if failure , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < int > good = success ( 1909 ); result < int > bad = failure <> (); auto good_year = good . unwrap_or_default (); auto bad_year = bad . unwrap_or_default (); assert ( 1909 == good_year ); assert ( 0 == bad_year ); } // end example","title":""},{"location":"result/_APIs/unwrap_or_else/","text":"basic_result<_, T, E>::unwrap_or_else() -> T template < mutability _mu , class T , class E > class basic_result { template < class O > auto basic_result < _ , T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > ; }; Unwraps a result, yielding the content of an success . If the value is an failure then it invokes op with its value. Example // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < int , std :: string > ok = success ( 2 ); result < int , std :: string > err = failure ( \"foo\" s ); assert ( ok . unwrap_or_else ( & std :: string :: size ) == 2 ); assert ( err . unwrap_or_else ( & std :: string :: size ) == 3 ); } // end example","title":""},{"location":"result/_metafunctions/is_result/","text":"is_result \u00b6 template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":""},{"location":"result/_metafunctions/is_result/#is_result","text":"template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":"is_result"},{"location":"result/_metafunctions/is_result_with/","text":"is_result_with \u00b6 template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":""},{"location":"result/_metafunctions/is_result_with/#is_result_with","text":"template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"is_result_with"}]}