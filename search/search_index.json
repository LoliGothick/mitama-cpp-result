{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 result is a header only C++17 library for error handling. Prerequisites and installation \u00b6 Compiler/Toolchain Status clang >= 7.0.0 Testing on CircleCI; tested on each push to GitHub gcc >= 8.3.0 Testing on CircleCI; tested on each push to GitHub boost >= 1.67.0 Testing on CircleCI; tested on each push to GitHub More specifically, Mitama.result requires a compiler/standard library supporting the following C++17 features: constexpr if constexpr lambda inline variables fold expressions class template deduction and deduction guide All the C++17 type traits from the < type_traits > header std :: { invoke , apply } from the < functional > header std :: string_view from the < string_view > header std :: monostate from the < variant > header Mitama.result requires a Boost supporting the following libraries: boost :: optional from the < boost / optional . hpp > header boost :: variant from the < boost / variant . hpp > header boost :: format from the < boost / format . hpp > header boost :: hana :: { fix , overload , overload_linearly } from the < boost / hana / functional / { fix , overload , overload_linearly } . hpp > header Basic Usage \u00b6 Here is a bad code, see below. If this program fail to assert, you don't know the reason for the error. bool func ( int a ) { if ( first check ) return false ; if ( second check ) return false ; if ( third check ) return false ; // function body... return true ; } // ... assert ( func ( 42 )); Here is a code using result. Even if this program fail to assert, you can get the reason for the error. auto func ( int a ) -> mitama :: result < int , std :: string > { if ( first check ) return mitama :: failure ( \"first check failed\" ); // early return if ( second check ) return mitama :: failure ( \"second check failed\" ); // early return if ( third check ) return mitama :: failure ( \"third check failed\" ); // early return // function body... return mitama :: success ( 42 ); } // ... int value func ( 42 ). unwrap (); // even if fail to unwrap, // raise an exception // and you get reason for the error.","title":"Home"},{"location":"#introduction","text":"result is a header only C++17 library for error handling.","title":"Introduction"},{"location":"#prerequisites_and_installation","text":"Compiler/Toolchain Status clang >= 7.0.0 Testing on CircleCI; tested on each push to GitHub gcc >= 8.3.0 Testing on CircleCI; tested on each push to GitHub boost >= 1.67.0 Testing on CircleCI; tested on each push to GitHub More specifically, Mitama.result requires a compiler/standard library supporting the following C++17 features: constexpr if constexpr lambda inline variables fold expressions class template deduction and deduction guide All the C++17 type traits from the < type_traits > header std :: { invoke , apply } from the < functional > header std :: string_view from the < string_view > header std :: monostate from the < variant > header Mitama.result requires a Boost supporting the following libraries: boost :: optional from the < boost / optional . hpp > header boost :: variant from the < boost / variant . hpp > header boost :: format from the < boost / format . hpp > header boost :: hana :: { fix , overload , overload_linearly } from the < boost / hana / functional / { fix , overload , overload_linearly } . hpp > header","title":"Prerequisites and installation"},{"location":"#basic_usage","text":"Here is a bad code, see below. If this program fail to assert, you don't know the reason for the error. bool func ( int a ) { if ( first check ) return false ; if ( second check ) return false ; if ( third check ) return false ; // function body... return true ; } // ... assert ( func ( 42 )); Here is a code using result. Even if this program fail to assert, you can get the reason for the error. auto func ( int a ) -> mitama :: result < int , std :: string > { if ( first check ) return mitama :: failure ( \"first check failed\" ); // early return if ( second check ) return mitama :: failure ( \"second check failed\" ); // early return if ( third check ) return mitama :: failure ( \"third check failed\" ); // early return // function body... return mitama :: success ( 42 ); } // ... int value func ( 42 ). unwrap (); // even if fail to unwrap, // raise an exception // and you get reason for the error.","title":"Basic Usage"},{"location":"maybe/APIs/","text":"is_just \u00b6 is_just() constexpr bool maybe < T >:: is_just () const noexcept ; Returns true if the maybe has same value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( x . is_just () ); maybe < int > y = nothing ; assert ( ! y . is_just () ); } // end example is_nothing \u00b6 is_nothing() constexpr bool maybe < T >:: is_nothing () const noexcept ; Returns true if the maybe has not same value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( ! x . is_nothing () ); maybe < int > y = nothing ; assert ( y . is_nothing () ); } // end example as_ref \u00b6 as_ref() auto maybe < T >:: as_ref () & -> maybe < T &> ; auto maybe < T >:: as_ref () const & -> maybe < const T &> ; Converts from maybe < T >& to maybe < T &> . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> #include <iostream> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe text = just ( \"Hello, world!\" s ); // First, cast `maybe<T>` to `maybe<T&>` with `as_ref`, auto text_length = text . as_ref (). map ( & std :: string :: size ); std :: cout << \"still can print text: \" << text << \" \\n \" ; } // end example expect \u00b6 expect(msg) auto maybe < T >:: expect ( std :: string_view msg ) & -> T & ; auto maybe < T >:: expect ( std :: string_view msg ) const & -> T const & ; auto maybe < T >:: expect ( std :: string_view msg ) && -> T && ; Unwraps a maybe, yielding the content of an just . Exception Raise mitama :: runtime_panic if the value is a nothing with a custom panic message provided by msg . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"value\" s ); assert ( x . expect ( \"the world is ending\" ) == \"value\" s ); } try { maybe < int > x = nothing ; x . expect ( \"the world is ending\" ); // panics with `the world is ending` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'the world is ending' } } // end example unwrap \u00b6 unwrap() auto maybe < T >:: unwrap () & -> T & ; auto maybe < T >:: unwrap () const & -> T const & ; auto maybe < T >:: unwrap () && -> T && ; Unwraps a maybe, yielding the content of an just . Exception Raise mitama :: runtime_panic if a maybe has not just value. Example { maybe x = just ( \"air\" s ); assert ( x . unwrap () == \"air\" s ); } try { maybe < int > x = nothing ; x . unwrap (); // raise an exception } catch ( mitama :: runtime_panic cosnt & panic ) { std :: err << panic . what () << std :: endl ; // runtime panicked at 'called `maybe::unwrap()` on a `nothing` value' } unwrap_or \u00b6 unwrap_or(U u) -> common_type<T, U> template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T & , U &&>>:: value , std :: common_type_t < T & , U &&>> maybe < T >:: unwrap_or ( U && def ) & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T const & , U &&>>:: value , std :: common_type_t < T const & , U &&>> maybe < T >:: unwrap_or ( U && def ) const & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T && , U &&>>:: value , std :: common_type_t < T && , U &&>> maybe < T >:: unwrap_or ( U && def ) && ; Returns the contained value or a default. Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example assert ( maybe { just ( \"car\" s )}. unwrap_or ( \"bike\" s ) == \"car\" s ); assert ( maybe < std :: string > { nothing }. unwrap_or ( \"bike\" s ) == \"bike\" s ); unwrap_or_else \u00b6 unwrap_or_else() template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T const & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T const & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T && , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T && , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) && ; Returns the contained value or computes it from a invocable object op . Example int k = 10 ; assert ( maybe { just ( 4 )}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 4 ); assert ( maybe < int > {}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 20 ); map \u00b6 map(F f) -> maybe<std::invoke_result_t<F, T>> template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &> , bool > = false > auto maybe < T >:: map ( F && f ) & -> maybe < std :: invoke_result_t < F && , T &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T const &> , bool > = false > auto maybe < T >:: map ( F && f ) const & -> maybe < std :: invoke_result_t < F && , T const &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &&> , bool > = false > auto maybe < T >:: map ( F && f ) && -> maybe < std :: invoke_result_t < F && , T &&>> ; Maps an maybe < T > to maybe < U > by applying a function to a contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe maybe_some_string = just ( \"Hello, World!\" s ); // `maybe::map` takes self *by ref*, // *not* consuming `maybe_some_string` maybe maybe_some_len = maybe_some_string . map ( & std :: string :: size ); assert ( maybe_some_len == just ( 13u )); } // end example map_or \u00b6 map_or(U def, F f) -> common_type<U, std::invoke_result_t<F, T>> template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &>>> map_or ( U && def , F && f ) & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T const &>>> map_or ( U && def , F && f ) const & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &&>>> map_or ( U && def , F && f ) && ; Applies a function to the contained value (if any), or returns the provided default (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . map_or ( 42 , & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or ( 42 , & std :: string :: size ) == 42 ); } // end example map_or_else \u00b6 map_or_else(D def, F f) -> U template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>> map_or_else ( D && def , F && f ) & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>> map_or_else ( D && def , F && f ) const & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>> map_or_else ( D && def , F && f ) && ; Applies a function to the contained value (if any), or computes a default (if not). Examples // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { int k = 21 ; maybe x = just ( \"foo\" s ); assert ( x . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 42 ); } // end example ok_or \u00b6 ok_or(E err) -> result template < class E > auto maybe < T >:: ok_or ( E && err ) const & -> result < T , E > ; template < class E > auto maybe < T >:: ok_or ( E && err ) && -> result < std :: remove_reference_t < T > , E > ; auto maybe < T >:: ok_or () const & -> result < T , std :: monostate > ; auto maybe < T >:: ok_or () && -> result < std :: remove_reference_t < T > , std :: monostate > ; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ) . Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or ( 0 ) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or ( 0 ) == failure ( 0 )); assert ( y . ok_or () == failure <> ()); } // end example ok_or_else \u00b6 ok_or_else(F f) -> result<T, std::invoke_result_t<F>> template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < T , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) const & ; template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < std :: remove_reference_t < T > , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) && ; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ()) . Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or_else ([]{ return 0 ; }) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or_else ([]{ return 0 ; }) == failure ( 0 )); } // end example conj \u00b6 maybe<T>::conj(maybe<U>) -> maybe>U> template < class U > auto maybe < T >:: conj ( maybe < U > const & rhs ) -> maybe < U > ; Returns nothing if the lhs is nothing , otherwise returns rhs . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } { maybe < int > x = nothing ; maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == nothing ); } { maybe x = just ( 2 ); maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == just ( \"foo\" s )); } { maybe < int > x = nothing ; maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } } // end example and_then \u00b6 and_then(F f) -> std::invoke_result_t<F, T> template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T const &>>>> , std :: invoke_result_t < F && , T const &> > and_then ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &&>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) && ; Returns nothing if the option is nothing , otherwise calls f with the wrapped value and returns the result. Some languages call this operation flatmap. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto sq = []( int x ) -> maybe < int > { return just ( x * x ); }; auto nope = [](...) -> maybe < int > { return nothing ; }; assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( sq ) == just ( 16 )); assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( nope ) == nothing ); assert ( maybe { just ( 2 )}. and_then ( nope ). and_then ( sq ) == nothing ); assert ( nope (). and_then ( sq ). and_then ( sq ) == nothing ); } // end example filter \u00b6 filter(Pred predicate) -> maybe<T> template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T const &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) const & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &&> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) && ; Returns nothing if the option is nothing , otherwise calls predicate with the wrapped value and returns: just ( t ) if predicate returns true (where t is the wrapped value), and nothing if predicate returns false. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto is_even = []( int n ) -> bool { return n % 2 == 0 ; }; assert ( maybe < int > {}. filter ( is_even ) == nothing ); assert ( maybe { just ( 3 )}. filter ( is_even ) == nothing ); assert ( maybe { just ( 4 )}. filter ( is_even ) == just ( 4 )); } // end example disj \u00b6 maybe<T>::disj(maybe<T>) -> maybe>T> auto maybe < T >:: disj ( maybe < T > const & rhs ) -> maybe < T > ; Returns the maybe if it contains a value, otherwise returns rhs. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); maybe < int > y = nothing ; assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 100 )); } { maybe x = just ( 2 ); maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe < int > y = nothing ; assert ( x . disj ( y ) == nothing ); } } // end example or_else \u00b6 or_else(F f) -> maybe<T> template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) && ; Returns the maybe if it contains a value, otherwise calls f and returns the result. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto nobody = []() -> maybe < std :: string > { return nothing ; }; auto vikings = []() -> maybe < std :: string > { return just ( \"vikings\" s ); }; assert ( maybe { just ( \"barbarians\" s )}. or_else ( vikings ) == just ( \"barbarians\" s )); assert ( maybe < std :: string > {}. or_else ( vikings ) == just ( \"vikings\" s )); assert ( maybe < std :: string > {}. or_else ( nobody ) == nothing ); } // end example get_or_emplace \u00b6 get_or_emplace(Args... args) -> T& template < class ... Args > std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , T &> get_or_emplace ( Args && ... args ) & ; Emplace constructs T into the maybe with expression std :: forward < Args > ( args )... if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; struct noncopyable { noncopyable () = default ; noncopyable ( noncopyable const & ) = delete ; noncopyable & operator = ( noncopyable const & ) = delete ; noncopyable ( noncopyable && ) = default ; noncopyable & operator = ( noncopyable && ) = default ; bool operator == ( noncopyable && ) & { return true ; } bool operator == ( noncopyable && ) const & { return true ; } bool operator == ( noncopyable const & ) & { return true ; } bool operator == ( noncopyable const & ) const & { return true ; } }; int main () { maybe < noncopyable > x = nothing ; auto & y = x . get_or_emplace ( noncopyable {}); assert ( y == noncopyable {}); } // end example get_or_emplace_with \u00b6 get_or_emplace_with(F f,Args... args) -> T& template < class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , Args && ... > , std :: is_constructible < T , std :: invoke_result_t < F && , Args && ... >>> , T &> get_or_emplace_with ( F && f , Args && ... args ) & ; Emplace constructs T into the maybe with expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < int > x = nothing ; std :: ignore = x . get_or_emplace_with ([]{ return 5 ; }); std :: ignore = x . get_or_emplace_with ([]( auto x ){ return x ; }, 5 ); auto & y = x . get_or_emplace_with ( & std :: string :: size , \"12345\" s ); assert ( y == 5 ); y = 7 ; assert ( x == just ( 7 )); } // end example replace \u00b6 replace(Args... args) -> maybe<T> maybe < T > replace ( Args && ... args ) & ; Replaces the actual value in the maybe by expression std :: forward < Args > ( args )... , returning the old value if present, leaving a just value in its place without deinitializing either one. Example { maybe x = just ( 2 ); auto old = x . replace ( 5 ); REQUIRE ( x == just ( 5 )); REQUIRE ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace ( 3 ); REQUIRE ( x == just ( 3 )); REQUIRE ( old == nothing ); } replace_with \u00b6 replace_with(F f, Args... args) -> maybe<T> template < class F , class ... Args > maybe < T > replace_with ( F && f , Args && ... args ) & ; Replaces the actual value in the maybe by expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) , returning the old value if present, leaving a just value in its place without deinitializing either one. Example { maybe x = just ( 2 ); auto old = x . replace_with ([]{ return 5 ; }); REQUIRE ( x == just ( 5 )); REQUIRE ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace_with ( & std :: string :: size , \"foo\" s ); REQUIRE ( x == just ( 3 )); REQUIRE ( old == nothing ); } cloned \u00b6 maybe<T&>::cloned() requires T is copyable -> maybe<T> auto maybe < T &>:: cloned () & -> maybe < T > ; Maps an maybe < T &> to an maybe < T > by deep copying the contents of the maybe. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int x = 12 ; maybe < int &> opt_x = x ; assert ( opt_x == just ( 12 )); assert ( & ( opt_x . unwrap ()) == & x ); auto shallow_copied = opt_x ; assert ( & ( shallow_copied . unwrap ()) == & x ); auto cloned = opt_x . cloned (); assert ( cloned == just ( 12 )); assert ( & ( cloned . unwrap ()) != & x ); } // end example unwrap_or_default \u00b6 unwrap_or_default() auto maybe < T >:: unwrap_or_default () const & -> std :: remove_reference_t < T > ; Returns the contained value or a default. If just , returns the contained value, otherwise if nothing , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < std :: string > x = nothing ; assert ( x . unwrap_or_default () == \"\" s ); } // end example transpose \u00b6 maybe<basic_result<_, T, E>>::transpose() maybe < basic_result < _ , T , E >>:: transpose () const & -> basic_result < _ , maybe < T > , E > ; Transposes a maybe of a result into a result of a maybe . nothing will be mapped to success ( nothing ) . just ( success ( _ )) and just ( failure ( _ )) will be mapped to success ( just ( _ )) and failure ( _ ) \u3000(_ is a placeholder). Example result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); REQUIRE ( x == y . transpose ()); flatten \u00b6 maybe<maybe<T>>::flatten() -> maybe<T> auto maybe < maybe < T >>:: transpose () -> maybe < T > ; Converts from maybe < maybe < T >> to maybe < T > . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < maybe < int >> x = just ( just ( 6 )); assert ( just ( 6 ) == x . flatten ()); maybe < maybe < int >> y = just ( nothing ); assert ( nothing == y . flatten ()); maybe < maybe < int >> z = nothing ; assert ( nothing == z . flatten ()); // Flattening once only removes one level of nesting: maybe < maybe < maybe < int >>> nest = just ( just ( just ( 6 ))); assert ( just ( 6 ) == nest . flatten (). flatten ()); } // end example and_finally \u00b6 and_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >>> and_finally ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >>> and_finally ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >>> and_finally ( F && f ) && ; Invokes the provided function with the contained value (if any), or doing nothing (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example or_finally \u00b6 or_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) && ; Invokes the provided function (if nothing), or doing nothing (if any). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); and_peek \u00b6 and_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , maybe &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , maybe const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , maybe &&> and_peek ( F && f ) && ; Peeks the contained value if self is just , then returns self. Invokes the provided function with the contained value and then return self (if any), or return self without doing anything (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example or_peek \u00b6 or_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &> or_peek ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe const &> or_peek ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &&> or_peek ( F && f ) && ; Invokes the provided function and then return self (if nothing), or return self without doing anything (if any). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 );","title":"API Reference"},{"location":"maybe/APIs/#is_just","text":"is_just() constexpr bool maybe < T >:: is_just () const noexcept ; Returns true if the maybe has same value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( x . is_just () ); maybe < int > y = nothing ; assert ( ! y . is_just () ); } // end example","title":"is_just"},{"location":"maybe/APIs/#is_nothing","text":"is_nothing() constexpr bool maybe < T >:: is_nothing () const noexcept ; Returns true if the maybe has not same value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( ! x . is_nothing () ); maybe < int > y = nothing ; assert ( y . is_nothing () ); } // end example","title":"is_nothing"},{"location":"maybe/APIs/#as_ref","text":"as_ref() auto maybe < T >:: as_ref () & -> maybe < T &> ; auto maybe < T >:: as_ref () const & -> maybe < const T &> ; Converts from maybe < T >& to maybe < T &> . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> #include <iostream> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe text = just ( \"Hello, world!\" s ); // First, cast `maybe<T>` to `maybe<T&>` with `as_ref`, auto text_length = text . as_ref (). map ( & std :: string :: size ); std :: cout << \"still can print text: \" << text << \" \\n \" ; } // end example","title":"as_ref"},{"location":"maybe/APIs/#expect","text":"expect(msg) auto maybe < T >:: expect ( std :: string_view msg ) & -> T & ; auto maybe < T >:: expect ( std :: string_view msg ) const & -> T const & ; auto maybe < T >:: expect ( std :: string_view msg ) && -> T && ; Unwraps a maybe, yielding the content of an just . Exception Raise mitama :: runtime_panic if the value is a nothing with a custom panic message provided by msg . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"value\" s ); assert ( x . expect ( \"the world is ending\" ) == \"value\" s ); } try { maybe < int > x = nothing ; x . expect ( \"the world is ending\" ); // panics with `the world is ending` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'the world is ending' } } // end example","title":"expect"},{"location":"maybe/APIs/#unwrap","text":"unwrap() auto maybe < T >:: unwrap () & -> T & ; auto maybe < T >:: unwrap () const & -> T const & ; auto maybe < T >:: unwrap () && -> T && ; Unwraps a maybe, yielding the content of an just . Exception Raise mitama :: runtime_panic if a maybe has not just value. Example { maybe x = just ( \"air\" s ); assert ( x . unwrap () == \"air\" s ); } try { maybe < int > x = nothing ; x . unwrap (); // raise an exception } catch ( mitama :: runtime_panic cosnt & panic ) { std :: err << panic . what () << std :: endl ; // runtime panicked at 'called `maybe::unwrap()` on a `nothing` value' }","title":"unwrap"},{"location":"maybe/APIs/#unwrap_or","text":"unwrap_or(U u) -> common_type<T, U> template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T & , U &&>>:: value , std :: common_type_t < T & , U &&>> maybe < T >:: unwrap_or ( U && def ) & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T const & , U &&>>:: value , std :: common_type_t < T const & , U &&>> maybe < T >:: unwrap_or ( U && def ) const & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T && , U &&>>:: value , std :: common_type_t < T && , U &&>> maybe < T >:: unwrap_or ( U && def ) && ; Returns the contained value or a default. Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example assert ( maybe { just ( \"car\" s )}. unwrap_or ( \"bike\" s ) == \"car\" s ); assert ( maybe < std :: string > { nothing }. unwrap_or ( \"bike\" s ) == \"bike\" s );","title":"unwrap_or"},{"location":"maybe/APIs/#unwrap_or_else","text":"unwrap_or_else() template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T const & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T const & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T && , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T && , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) && ; Returns the contained value or computes it from a invocable object op . Example int k = 10 ; assert ( maybe { just ( 4 )}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 4 ); assert ( maybe < int > {}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 20 );","title":"unwrap_or_else"},{"location":"maybe/APIs/#map","text":"map(F f) -> maybe<std::invoke_result_t<F, T>> template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &> , bool > = false > auto maybe < T >:: map ( F && f ) & -> maybe < std :: invoke_result_t < F && , T &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T const &> , bool > = false > auto maybe < T >:: map ( F && f ) const & -> maybe < std :: invoke_result_t < F && , T const &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &&> , bool > = false > auto maybe < T >:: map ( F && f ) && -> maybe < std :: invoke_result_t < F && , T &&>> ; Maps an maybe < T > to maybe < U > by applying a function to a contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe maybe_some_string = just ( \"Hello, World!\" s ); // `maybe::map` takes self *by ref*, // *not* consuming `maybe_some_string` maybe maybe_some_len = maybe_some_string . map ( & std :: string :: size ); assert ( maybe_some_len == just ( 13u )); } // end example","title":"map"},{"location":"maybe/APIs/#map_or","text":"map_or(U def, F f) -> common_type<U, std::invoke_result_t<F, T>> template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &>>> map_or ( U && def , F && f ) & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T const &>>> map_or ( U && def , F && f ) const & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &&>>> map_or ( U && def , F && f ) && ; Applies a function to the contained value (if any), or returns the provided default (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . map_or ( 42 , & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or ( 42 , & std :: string :: size ) == 42 ); } // end example","title":"map_or"},{"location":"maybe/APIs/#map_or_else","text":"map_or_else(D def, F f) -> U template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>> map_or_else ( D && def , F && f ) & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>> map_or_else ( D && def , F && f ) const & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>> map_or_else ( D && def , F && f ) && ; Applies a function to the contained value (if any), or computes a default (if not). Examples // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { int k = 21 ; maybe x = just ( \"foo\" s ); assert ( x . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 42 ); } // end example","title":"map_or_else"},{"location":"maybe/APIs/#ok_or","text":"ok_or(E err) -> result template < class E > auto maybe < T >:: ok_or ( E && err ) const & -> result < T , E > ; template < class E > auto maybe < T >:: ok_or ( E && err ) && -> result < std :: remove_reference_t < T > , E > ; auto maybe < T >:: ok_or () const & -> result < T , std :: monostate > ; auto maybe < T >:: ok_or () && -> result < std :: remove_reference_t < T > , std :: monostate > ; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ) . Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or ( 0 ) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or ( 0 ) == failure ( 0 )); assert ( y . ok_or () == failure <> ()); } // end example","title":"ok_or"},{"location":"maybe/APIs/#ok_or_else","text":"ok_or_else(F f) -> result<T, std::invoke_result_t<F>> template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < T , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) const & ; template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < std :: remove_reference_t < T > , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) && ; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ()) . Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or_else ([]{ return 0 ; }) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or_else ([]{ return 0 ; }) == failure ( 0 )); } // end example","title":"ok_or_else"},{"location":"maybe/APIs/#conj","text":"maybe<T>::conj(maybe<U>) -> maybe>U> template < class U > auto maybe < T >:: conj ( maybe < U > const & rhs ) -> maybe < U > ; Returns nothing if the lhs is nothing , otherwise returns rhs . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } { maybe < int > x = nothing ; maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == nothing ); } { maybe x = just ( 2 ); maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == just ( \"foo\" s )); } { maybe < int > x = nothing ; maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } } // end example","title":"conj"},{"location":"maybe/APIs/#and_then","text":"and_then(F f) -> std::invoke_result_t<F, T> template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T const &>>>> , std :: invoke_result_t < F && , T const &> > and_then ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &&>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) && ; Returns nothing if the option is nothing , otherwise calls f with the wrapped value and returns the result. Some languages call this operation flatmap. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto sq = []( int x ) -> maybe < int > { return just ( x * x ); }; auto nope = [](...) -> maybe < int > { return nothing ; }; assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( sq ) == just ( 16 )); assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( nope ) == nothing ); assert ( maybe { just ( 2 )}. and_then ( nope ). and_then ( sq ) == nothing ); assert ( nope (). and_then ( sq ). and_then ( sq ) == nothing ); } // end example","title":"and_then"},{"location":"maybe/APIs/#filter","text":"filter(Pred predicate) -> maybe<T> template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T const &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) const & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &&> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) && ; Returns nothing if the option is nothing , otherwise calls predicate with the wrapped value and returns: just ( t ) if predicate returns true (where t is the wrapped value), and nothing if predicate returns false. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto is_even = []( int n ) -> bool { return n % 2 == 0 ; }; assert ( maybe < int > {}. filter ( is_even ) == nothing ); assert ( maybe { just ( 3 )}. filter ( is_even ) == nothing ); assert ( maybe { just ( 4 )}. filter ( is_even ) == just ( 4 )); } // end example","title":"filter"},{"location":"maybe/APIs/#disj","text":"maybe<T>::disj(maybe<T>) -> maybe>T> auto maybe < T >:: disj ( maybe < T > const & rhs ) -> maybe < T > ; Returns the maybe if it contains a value, otherwise returns rhs. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); maybe < int > y = nothing ; assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 100 )); } { maybe x = just ( 2 ); maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe < int > y = nothing ; assert ( x . disj ( y ) == nothing ); } } // end example","title":"disj"},{"location":"maybe/APIs/#or_else","text":"or_else(F f) -> maybe<T> template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) && ; Returns the maybe if it contains a value, otherwise calls f and returns the result. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto nobody = []() -> maybe < std :: string > { return nothing ; }; auto vikings = []() -> maybe < std :: string > { return just ( \"vikings\" s ); }; assert ( maybe { just ( \"barbarians\" s )}. or_else ( vikings ) == just ( \"barbarians\" s )); assert ( maybe < std :: string > {}. or_else ( vikings ) == just ( \"vikings\" s )); assert ( maybe < std :: string > {}. or_else ( nobody ) == nothing ); } // end example","title":"or_else"},{"location":"maybe/APIs/#get_or_emplace","text":"get_or_emplace(Args... args) -> T& template < class ... Args > std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , T &> get_or_emplace ( Args && ... args ) & ; Emplace constructs T into the maybe with expression std :: forward < Args > ( args )... if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; struct noncopyable { noncopyable () = default ; noncopyable ( noncopyable const & ) = delete ; noncopyable & operator = ( noncopyable const & ) = delete ; noncopyable ( noncopyable && ) = default ; noncopyable & operator = ( noncopyable && ) = default ; bool operator == ( noncopyable && ) & { return true ; } bool operator == ( noncopyable && ) const & { return true ; } bool operator == ( noncopyable const & ) & { return true ; } bool operator == ( noncopyable const & ) const & { return true ; } }; int main () { maybe < noncopyable > x = nothing ; auto & y = x . get_or_emplace ( noncopyable {}); assert ( y == noncopyable {}); } // end example","title":"get_or_emplace"},{"location":"maybe/APIs/#get_or_emplace_with","text":"get_or_emplace_with(F f,Args... args) -> T& template < class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , Args && ... > , std :: is_constructible < T , std :: invoke_result_t < F && , Args && ... >>> , T &> get_or_emplace_with ( F && f , Args && ... args ) & ; Emplace constructs T into the maybe with expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < int > x = nothing ; std :: ignore = x . get_or_emplace_with ([]{ return 5 ; }); std :: ignore = x . get_or_emplace_with ([]( auto x ){ return x ; }, 5 ); auto & y = x . get_or_emplace_with ( & std :: string :: size , \"12345\" s ); assert ( y == 5 ); y = 7 ; assert ( x == just ( 7 )); } // end example","title":"get_or_emplace_with"},{"location":"maybe/APIs/#replace","text":"replace(Args... args) -> maybe<T> maybe < T > replace ( Args && ... args ) & ; Replaces the actual value in the maybe by expression std :: forward < Args > ( args )... , returning the old value if present, leaving a just value in its place without deinitializing either one. Example { maybe x = just ( 2 ); auto old = x . replace ( 5 ); REQUIRE ( x == just ( 5 )); REQUIRE ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace ( 3 ); REQUIRE ( x == just ( 3 )); REQUIRE ( old == nothing ); }","title":"replace"},{"location":"maybe/APIs/#replace_with","text":"replace_with(F f, Args... args) -> maybe<T> template < class F , class ... Args > maybe < T > replace_with ( F && f , Args && ... args ) & ; Replaces the actual value in the maybe by expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) , returning the old value if present, leaving a just value in its place without deinitializing either one. Example { maybe x = just ( 2 ); auto old = x . replace_with ([]{ return 5 ; }); REQUIRE ( x == just ( 5 )); REQUIRE ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace_with ( & std :: string :: size , \"foo\" s ); REQUIRE ( x == just ( 3 )); REQUIRE ( old == nothing ); }","title":"replace_with"},{"location":"maybe/APIs/#cloned","text":"maybe<T&>::cloned() requires T is copyable -> maybe<T> auto maybe < T &>:: cloned () & -> maybe < T > ; Maps an maybe < T &> to an maybe < T > by deep copying the contents of the maybe. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int x = 12 ; maybe < int &> opt_x = x ; assert ( opt_x == just ( 12 )); assert ( & ( opt_x . unwrap ()) == & x ); auto shallow_copied = opt_x ; assert ( & ( shallow_copied . unwrap ()) == & x ); auto cloned = opt_x . cloned (); assert ( cloned == just ( 12 )); assert ( & ( cloned . unwrap ()) != & x ); } // end example","title":"cloned"},{"location":"maybe/APIs/#unwrap_or_default","text":"unwrap_or_default() auto maybe < T >:: unwrap_or_default () const & -> std :: remove_reference_t < T > ; Returns the contained value or a default. If just , returns the contained value, otherwise if nothing , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < std :: string > x = nothing ; assert ( x . unwrap_or_default () == \"\" s ); } // end example","title":"unwrap_or_default"},{"location":"maybe/APIs/#transpose","text":"maybe<basic_result<_, T, E>>::transpose() maybe < basic_result < _ , T , E >>:: transpose () const & -> basic_result < _ , maybe < T > , E > ; Transposes a maybe of a result into a result of a maybe . nothing will be mapped to success ( nothing ) . just ( success ( _ )) and just ( failure ( _ )) will be mapped to success ( just ( _ )) and failure ( _ ) \u3000(_ is a placeholder). Example result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); REQUIRE ( x == y . transpose ());","title":"transpose"},{"location":"maybe/APIs/#flatten","text":"maybe<maybe<T>>::flatten() -> maybe<T> auto maybe < maybe < T >>:: transpose () -> maybe < T > ; Converts from maybe < maybe < T >> to maybe < T > . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < maybe < int >> x = just ( just ( 6 )); assert ( just ( 6 ) == x . flatten ()); maybe < maybe < int >> y = just ( nothing ); assert ( nothing == y . flatten ()); maybe < maybe < int >> z = nothing ; assert ( nothing == z . flatten ()); // Flattening once only removes one level of nesting: maybe < maybe < maybe < int >>> nest = just ( just ( just ( 6 ))); assert ( just ( 6 ) == nest . flatten (). flatten ()); } // end example","title":"flatten"},{"location":"maybe/APIs/#and_finally","text":"and_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >>> and_finally ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >>> and_finally ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >>> and_finally ( F && f ) && ; Invokes the provided function with the contained value (if any), or doing nothing (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example","title":"and_finally"},{"location":"maybe/APIs/#or_finally","text":"or_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) && ; Invokes the provided function (if nothing), or doing nothing (if any). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 );","title":"or_finally"},{"location":"maybe/APIs/#and_peek","text":"and_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , maybe &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , maybe const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , maybe &&> and_peek ( F && f ) && ; Peeks the contained value if self is just , then returns self. Invokes the provided function with the contained value and then return self (if any), or return self without doing anything (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example","title":"and_peek"},{"location":"maybe/APIs/#or_peek","text":"or_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &> or_peek ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe const &> or_peek ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &&> or_peek ( F && f ) && ; Invokes the provided function and then return self (if nothing), or return self without doing anything (if any). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 );","title":"or_peek"},{"location":"maybe/comparisons/","text":"operator== namespace mitama { template < class T , class U > constexpr bool operator == ( const maybe < T >& lhs , const maybe < U >& rhs ); // (1) template < class T , class U > constexpr bool operator == ( const maybe < T >& lhs , const just_t < U >& rhs ); // (2) template < class T , class U > constexpr bool operator == ( const just_t < T >& lhs , const maybe < U >& rhs ); // (3) template < class T > constexpr bool operator == ( const maybe < T >& lhs , nothing_t ) noexcept ; // (4) template < class T > constexpr bool operator == ( nothing_t , const maybe < T >& rhs ) noexcept ; // (5) template < class T , class U > constexpr bool operator == ( const maybe < T >& lhs , const U & rhs ); // (6) template < class T , class U > constexpr bool operator == ( const U & lhs , const maybe < T >& rhs ); // (7) } 1-7) Compares two maybe objects, lhs and rhs. The contained values are compared (using the corresponding operator of T and U) only if both lhs and rhs contain values. Otherwise, lhs is considered equal to rhs if, and only if, both lhs and rhs do not contain a value. lhs is considered less than rhs if, and only if, rhs contains a value and lhs does not.","title":""},{"location":"maybe/intro/","text":"Introduction \u00b6 Definition of class maybe \u00b6 namespace mitama { template < class T , class = void // for detection idiom > class maybe ; } Concepts \u00b6 maybe < T > is a class that holds a value type T or nothing. maybe < T > holds a value as boost :: optional < T > . Therefore, T must satisfy the following requirements for bounded types: Complete type Destructible just/nothing \u00b6 just and nothing are in-place factory for maybe < T > . If you want to initialize maybe < T > with some value, initialize with just ( value ) . mitama :: maybe < int > some_int = mitama :: just ( 42 ); Similarly, if you want to initialize maybe < T > with none value, initialize with nothing . mitama :: maybe < int > nope_int = mitama :: nothing ;","title":"Maybe 101"},{"location":"maybe/intro/#introduction","text":"","title":"Introduction"},{"location":"maybe/intro/#definition_of_class_maybe","text":"namespace mitama { template < class T , class = void // for detection idiom > class maybe ; }","title":"Definition of class maybe"},{"location":"maybe/intro/#concepts","text":"maybe < T > is a class that holds a value type T or nothing. maybe < T > holds a value as boost :: optional < T > . Therefore, T must satisfy the following requirements for bounded types: Complete type Destructible","title":"Concepts"},{"location":"maybe/intro/#justnothing","text":"just and nothing are in-place factory for maybe < T > . If you want to initialize maybe < T > with some value, initialize with just ( value ) . mitama :: maybe < int > some_int = mitama :: just ( 42 ); Similarly, if you want to initialize maybe < T > with none value, initialize with nothing . mitama :: maybe < int > nope_int = mitama :: nothing ;","title":"just/nothing"},{"location":"maybe/special_members/","text":"Constructors \u00b6 default constructor [1/7] \u00b6 maybe () = default ; copy constructor [2/7] \u00b6 maybe ( maybe const & ) = default ; constructor [3/7] \u00b6 maybe ( maybe && ) = default ; constructor for nothing [4/7] \u00b6 Delegates to default constructor. maybe ( const nothing_t ) : maybe () {} constructor for maybe<U>, where constructible T from U [5/7] \u00b6 template < typename U , std :: enable_if_t < std :: disjunction_v < mitamagic :: is_pointer_like < std :: remove_reference_t < U >> , std :: is_pointer < std :: remove_reference_t < U >>> , bool > = false > maybe ( U && u ) : storage_ () { if ( u ) storage_ . emplace ( * std :: forward < U > ( u )); } in-place constructor [6/7] \u00b6 template < class ... Args , std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , Args && ... args ) : storage_ ( etude :: in_place ( std :: forward < Args > ( args )...)) {} in-place constructor with initializer_list [7/7] \u00b6 template < class U , class ... Args , std :: enable_if_t < std :: is_constructible_v < T , std :: initializer_list < U > , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , std :: initializer_list < U > il , Args && ... args ) : storage_ ( etude :: in_place ( il , std :: forward < Args > ( args )...)) {} Assignment operators \u00b6 copy assignment [1/2] \u00b6 maybe & operator = ( maybe const & ) = default ; move assignment [1/2] \u00b6 maybe & operator = ( maybe && ) = default ;","title":"Special Members"},{"location":"maybe/special_members/#constructors","text":"","title":"Constructors"},{"location":"maybe/special_members/#default_constructor_17","text":"maybe () = default ;","title":"default constructor [1/7]"},{"location":"maybe/special_members/#copy_constructor_27","text":"maybe ( maybe const & ) = default ;","title":"copy constructor [2/7]"},{"location":"maybe/special_members/#constructor_37","text":"maybe ( maybe && ) = default ;","title":"constructor [3/7]"},{"location":"maybe/special_members/#constructor_for_nothing_47","text":"Delegates to default constructor. maybe ( const nothing_t ) : maybe () {}","title":"constructor for nothing [4/7]"},{"location":"maybe/special_members/#constructor_for_maybeu_where_constructible_t_from_u_57","text":"template < typename U , std :: enable_if_t < std :: disjunction_v < mitamagic :: is_pointer_like < std :: remove_reference_t < U >> , std :: is_pointer < std :: remove_reference_t < U >>> , bool > = false > maybe ( U && u ) : storage_ () { if ( u ) storage_ . emplace ( * std :: forward < U > ( u )); }","title":"constructor for maybe&lt;U&gt;, where constructible T from U  [5/7]"},{"location":"maybe/special_members/#in-place_constructor_67","text":"template < class ... Args , std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , Args && ... args ) : storage_ ( etude :: in_place ( std :: forward < Args > ( args )...)) {}","title":"in-place constructor [6/7]"},{"location":"maybe/special_members/#in-place_constructor_with_initializer_list_77","text":"template < class U , class ... Args , std :: enable_if_t < std :: is_constructible_v < T , std :: initializer_list < U > , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , std :: initializer_list < U > il , Args && ... args ) : storage_ ( etude :: in_place ( il , std :: forward < Args > ( args )...)) {}","title":"in-place constructor with initializer_list [7/7]"},{"location":"maybe/special_members/#assignment_operators","text":"","title":"Assignment operators"},{"location":"maybe/special_members/#copy_assignment_12","text":"maybe & operator = ( maybe const & ) = default ;","title":"copy assignment [1/2]"},{"location":"maybe/special_members/#move_assignment_12","text":"maybe & operator = ( maybe && ) = default ;","title":"move assignment [1/2]"},{"location":"maybe/_APIs/and_finally/","text":"and_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >>> and_finally ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >>> and_finally ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >>> and_finally ( F && f ) && ; Invokes the provided function with the contained value (if any), or doing nothing (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example","title":""},{"location":"maybe/_APIs/and_peek/","text":"and_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , maybe &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , maybe const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , maybe &&> and_peek ( F && f ) && ; Peeks the contained value if self is just , then returns self. Invokes the provided function with the contained value and then return self (if any), or return self without doing anything (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example","title":""},{"location":"maybe/_APIs/and_then/","text":"and_then(F f) -> std::invoke_result_t<F, T> template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T const &>>>> , std :: invoke_result_t < F && , T const &> > and_then ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , is_maybe < std :: decay_t < std :: invoke_result_t < F && , T &&>>>> , std :: invoke_result_t < F && , T &> > and_then ( F && f ) && ; Returns nothing if the option is nothing , otherwise calls f with the wrapped value and returns the result. Some languages call this operation flatmap. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto sq = []( int x ) -> maybe < int > { return just ( x * x ); }; auto nope = [](...) -> maybe < int > { return nothing ; }; assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( sq ) == just ( 16 )); assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( nope ) == nothing ); assert ( maybe { just ( 2 )}. and_then ( nope ). and_then ( sq ) == nothing ); assert ( nope (). and_then ( sq ). and_then ( sq ) == nothing ); } // end example","title":""},{"location":"maybe/_APIs/as_ref/","text":"as_ref() auto maybe < T >:: as_ref () & -> maybe < T &> ; auto maybe < T >:: as_ref () const & -> maybe < const T &> ; Converts from maybe < T >& to maybe < T &> . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> #include <iostream> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe text = just ( \"Hello, world!\" s ); // First, cast `maybe<T>` to `maybe<T&>` with `as_ref`, auto text_length = text . as_ref (). map ( & std :: string :: size ); std :: cout << \"still can print text: \" << text << \" \\n \" ; } // end example","title":""},{"location":"maybe/_APIs/cloned/","text":"maybe<T&>::cloned() requires T is copyable -> maybe<T> auto maybe < T &>:: cloned () & -> maybe < T > ; Maps an maybe < T &> to an maybe < T > by deep copying the contents of the maybe. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int x = 12 ; maybe < int &> opt_x = x ; assert ( opt_x == just ( 12 )); assert ( & ( opt_x . unwrap ()) == & x ); auto shallow_copied = opt_x ; assert ( & ( shallow_copied . unwrap ()) == & x ); auto cloned = opt_x . cloned (); assert ( cloned == just ( 12 )); assert ( & ( cloned . unwrap ()) != & x ); } // end example","title":""},{"location":"maybe/_APIs/conj/","text":"maybe<T>::conj(maybe<U>) -> maybe>U> template < class U > auto maybe < T >:: conj ( maybe < U > const & rhs ) -> maybe < U > ; Returns nothing if the lhs is nothing , otherwise returns rhs . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } { maybe < int > x = nothing ; maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == nothing ); } { maybe x = just ( 2 ); maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == just ( \"foo\" s )); } { maybe < int > x = nothing ; maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } } // end example","title":""},{"location":"maybe/_APIs/disj/","text":"maybe<T>::disj(maybe<T>) -> maybe>T> auto maybe < T >:: disj ( maybe < T > const & rhs ) -> maybe < T > ; Returns the maybe if it contains a value, otherwise returns rhs. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); maybe < int > y = nothing ; assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 100 )); } { maybe x = just ( 2 ); maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe < int > y = nothing ; assert ( x . disj ( y ) == nothing ); } } // end example","title":""},{"location":"maybe/_APIs/expect/","text":"expect(msg) auto maybe < T >:: expect ( std :: string_view msg ) & -> T & ; auto maybe < T >:: expect ( std :: string_view msg ) const & -> T const & ; auto maybe < T >:: expect ( std :: string_view msg ) && -> T && ; Unwraps a maybe, yielding the content of an just . Exception Raise mitama :: runtime_panic if the value is a nothing with a custom panic message provided by msg . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"value\" s ); assert ( x . expect ( \"the world is ending\" ) == \"value\" s ); } try { maybe < int > x = nothing ; x . expect ( \"the world is ending\" ); // panics with `the world is ending` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'the world is ending' } } // end example","title":""},{"location":"maybe/_APIs/filter/","text":"filter(Pred predicate) -> maybe<T> template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T const &> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) const & ; template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T &&> , maybe < T >> maybe < T >:: filter ( Pred && predicate ) && ; Returns nothing if the option is nothing , otherwise calls predicate with the wrapped value and returns: just ( t ) if predicate returns true (where t is the wrapped value), and nothing if predicate returns false. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto is_even = []( int n ) -> bool { return n % 2 == 0 ; }; assert ( maybe < int > {}. filter ( is_even ) == nothing ); assert ( maybe { just ( 3 )}. filter ( is_even ) == nothing ); assert ( maybe { just ( 4 )}. filter ( is_even ) == just ( 4 )); } // end example","title":""},{"location":"maybe/_APIs/flatten/","text":"maybe<maybe<T>>::flatten() -> maybe<T> auto maybe < maybe < T >>:: transpose () -> maybe < T > ; Converts from maybe < maybe < T >> to maybe < T > . Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < maybe < int >> x = just ( just ( 6 )); assert ( just ( 6 ) == x . flatten ()); maybe < maybe < int >> y = just ( nothing ); assert ( nothing == y . flatten ()); maybe < maybe < int >> z = nothing ; assert ( nothing == z . flatten ()); // Flattening once only removes one level of nesting: maybe < maybe < maybe < int >>> nest = just ( just ( just ( 6 ))); assert ( just ( 6 ) == nest . flatten (). flatten ()); } // end example","title":""},{"location":"maybe/_APIs/get_or_emplace/","text":"get_or_emplace(Args... args) -> T& template < class ... Args > std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , T &> get_or_emplace ( Args && ... args ) & ; Emplace constructs T into the maybe with expression std :: forward < Args > ( args )... if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; struct noncopyable { noncopyable () = default ; noncopyable ( noncopyable const & ) = delete ; noncopyable & operator = ( noncopyable const & ) = delete ; noncopyable ( noncopyable && ) = default ; noncopyable & operator = ( noncopyable && ) = default ; bool operator == ( noncopyable && ) & { return true ; } bool operator == ( noncopyable && ) const & { return true ; } bool operator == ( noncopyable const & ) & { return true ; } bool operator == ( noncopyable const & ) const & { return true ; } }; int main () { maybe < noncopyable > x = nothing ; auto & y = x . get_or_emplace ( noncopyable {}); assert ( y == noncopyable {}); } // end example","title":""},{"location":"maybe/_APIs/get_or_emplace_with/","text":"get_or_emplace_with(F f,Args... args) -> T& template < class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , Args && ... > , std :: is_constructible < T , std :: invoke_result_t < F && , Args && ... >>> , T &> get_or_emplace_with ( F && f , Args && ... args ) & ; Emplace constructs T into the maybe with expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) if it is nothing , then returns a mutable reference to the contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < int > x = nothing ; std :: ignore = x . get_or_emplace_with ([]{ return 5 ; }); std :: ignore = x . get_or_emplace_with ([]( auto x ){ return x ; }, 5 ); auto & y = x . get_or_emplace_with ( & std :: string :: size , \"12345\" s ); assert ( y == 5 ); y = 7 ; assert ( x == just ( 7 )); } // end example","title":""},{"location":"maybe/_APIs/is_just/","text":"is_just() constexpr bool maybe < T >:: is_just () const noexcept ; Returns true if the maybe has same value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( x . is_just () ); maybe < int > y = nothing ; assert ( ! y . is_just () ); } // end example","title":""},{"location":"maybe/_APIs/is_nothing/","text":"is_nothing() constexpr bool maybe < T >:: is_nothing () const noexcept ; Returns true if the maybe has not same value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( ! x . is_nothing () ); maybe < int > y = nothing ; assert ( y . is_nothing () ); } // end example","title":""},{"location":"maybe/_APIs/map/","text":"map(F f) -> maybe<std::invoke_result_t<F, T>> template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &> , bool > = false > auto maybe < T >:: map ( F && f ) & -> maybe < std :: invoke_result_t < F && , T &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T const &> , bool > = false > auto maybe < T >:: map ( F && f ) const & -> maybe < std :: invoke_result_t < F && , T const &>> ; template < class F , std :: enable_if_t < std :: is_invocable_v < F && , T &&> , bool > = false > auto maybe < T >:: map ( F && f ) && -> maybe < std :: invoke_result_t < F && , T &&>> ; Maps an maybe < T > to maybe < U > by applying a function to a contained value. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe maybe_some_string = just ( \"Hello, World!\" s ); // `maybe::map` takes self *by ref*, // *not* consuming `maybe_some_string` maybe maybe_some_len = maybe_some_string . map ( & std :: string :: size ); assert ( maybe_some_len == just ( 13u )); } // end example","title":""},{"location":"maybe/_APIs/map_or/","text":"map_or(U def, F f) -> common_type<U, std::invoke_result_t<F, T>> template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &>>> map_or ( U && def , F && f ) & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T const &>>> map_or ( U && def , F && f ) const & ; template < class U , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < U && , std :: invoke_result_t < F && , T &&>>> map_or ( U && def , F && f ) && ; Applies a function to the contained value (if any), or returns the provided default (if not). Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . map_or ( 42 , & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or ( 42 , & std :: string :: size ) == 42 ); } // end example","title":""},{"location":"maybe/_APIs/map_or_else/","text":"map_or_else(D def, F f) -> U template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &>>> map_or_else ( D && def , F && f ) & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T const &> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T const &>>> map_or_else ( D && def , F && f ) const & ; template < class D , class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , T &&> , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T &&>>> map_or_else ( D && def , F && f ) && ; Applies a function to the contained value (if any), or computes a default (if not). Examples // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { int k = 21 ; maybe x = just ( \"foo\" s ); assert ( x . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 42 ); } // end example","title":""},{"location":"maybe/_APIs/ok_or/","text":"ok_or(E err) -> result template < class E > auto maybe < T >:: ok_or ( E && err ) const & -> result < T , E > ; template < class E > auto maybe < T >:: ok_or ( E && err ) && -> result < std :: remove_reference_t < T > , E > ; auto maybe < T >:: ok_or () const & -> result < T , std :: monostate > ; auto maybe < T >:: ok_or () && -> result < std :: remove_reference_t < T > , std :: monostate > ; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ) . Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated. Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or ( 0 ) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or ( 0 ) == failure ( 0 )); assert ( y . ok_or () == failure <> ()); } // end example","title":""},{"location":"maybe/_APIs/ok_or_else/","text":"ok_or_else(F f) -> result<T, std::invoke_result_t<F>> template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < T , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) const & ; template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < std :: remove_reference_t < T > , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) && ; Transforms the maybe < T > into a result < T , E > , mapping just ( v ) to success ( v ) and nothing to failure ( err ()) . Example // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or_else ([]{ return 0 ; }) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or_else ([]{ return 0 ; }) == failure ( 0 )); } // end example","title":""},{"location":"maybe/_APIs/or_else/","text":"or_else(F f) -> maybe<T> template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) && ; Returns the maybe if it contains a value, otherwise calls f and returns the result. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto nobody = []() -> maybe < std :: string > { return nothing ; }; auto vikings = []() -> maybe < std :: string > { return just ( \"vikings\" s ); }; assert ( maybe { just ( \"barbarians\" s )}. or_else ( vikings ) == just ( \"barbarians\" s )); assert ( maybe < std :: string > {}. or_else ( vikings ) == just ( \"vikings\" s )); assert ( maybe < std :: string > {}. or_else ( nobody ) == nothing ); } // end example","title":""},{"location":"maybe/_APIs/or_finally/","text":"or_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ) && ; Invokes the provided function (if nothing), or doing nothing (if any). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 );","title":""},{"location":"maybe/_APIs/or_peek/","text":"or_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &> or_peek ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe const &> or_peek ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &&> or_peek ( F && f ) && ; Invokes the provided function and then return self (if nothing), or return self without doing anything (if any). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 );","title":""},{"location":"maybe/_APIs/replace/","text":"replace(Args... args) -> maybe<T> maybe < T > replace ( Args && ... args ) & ; Replaces the actual value in the maybe by expression std :: forward < Args > ( args )... , returning the old value if present, leaving a just value in its place without deinitializing either one. Example { maybe x = just ( 2 ); auto old = x . replace ( 5 ); REQUIRE ( x == just ( 5 )); REQUIRE ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace ( 3 ); REQUIRE ( x == just ( 3 )); REQUIRE ( old == nothing ); }","title":""},{"location":"maybe/_APIs/replace_with/","text":"replace_with(F f, Args... args) -> maybe<T> template < class F , class ... Args > maybe < T > replace_with ( F && f , Args && ... args ) & ; Replaces the actual value in the maybe by expression std :: invoke ( std :: forward < F > ( f ), std :: forward < Args > ( args )...) , returning the old value if present, leaving a just value in its place without deinitializing either one. Example { maybe x = just ( 2 ); auto old = x . replace_with ([]{ return 5 ; }); REQUIRE ( x == just ( 5 )); REQUIRE ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace_with ( & std :: string :: size , \"foo\" s ); REQUIRE ( x == just ( 3 )); REQUIRE ( old == nothing ); }","title":""},{"location":"maybe/_APIs/transpose/","text":"maybe<basic_result<_, T, E>>::transpose() maybe < basic_result < _ , T , E >>:: transpose () const & -> basic_result < _ , maybe < T > , E > ; Transposes a maybe of a result into a result of a maybe . nothing will be mapped to success ( nothing ) . just ( success ( _ )) and just ( failure ( _ )) will be mapped to success ( just ( _ )) and failure ( _ ) \u3000(_ is a placeholder). Example result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); REQUIRE ( x == y . transpose ());","title":""},{"location":"maybe/_APIs/unwrap/","text":"unwrap() auto maybe < T >:: unwrap () & -> T & ; auto maybe < T >:: unwrap () const & -> T const & ; auto maybe < T >:: unwrap () && -> T && ; Unwraps a maybe, yielding the content of an just . Exception Raise mitama :: runtime_panic if a maybe has not just value. Example { maybe x = just ( \"air\" s ); assert ( x . unwrap () == \"air\" s ); } try { maybe < int > x = nothing ; x . unwrap (); // raise an exception } catch ( mitama :: runtime_panic cosnt & panic ) { std :: err << panic . what () << std :: endl ; // runtime panicked at 'called `maybe::unwrap()` on a `nothing` value' }","title":""},{"location":"maybe/_APIs/unwrap_or/","text":"unwrap_or(U u) -> common_type<T, U> template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T & , U &&>>:: value , std :: common_type_t < T & , U &&>> maybe < T >:: unwrap_or ( U && def ) & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T const & , U &&>>:: value , std :: common_type_t < T const & , U &&>> maybe < T >:: unwrap_or ( U && def ) const & ; template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < T && , U &&>>:: value , std :: common_type_t < T && , U &&>> maybe < T >:: unwrap_or ( U && def ) && ; Returns the contained value or a default. Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example assert ( maybe { just ( \"car\" s )}. unwrap_or ( \"bike\" s ) == \"car\" s ); assert ( maybe < std :: string > { nothing }. unwrap_or ( \"bike\" s ) == \"bike\" s );","title":""},{"location":"maybe/_APIs/unwrap_or_default/","text":"unwrap_or_default() auto maybe < T >:: unwrap_or_default () const & -> std :: remove_reference_t < T > ; Returns the contained value or a default. If just , returns the contained value, otherwise if nothing , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < std :: string > x = nothing ; assert ( x . unwrap_or_default () == \"\" s ); } // end example","title":""},{"location":"maybe/_APIs/unwrap_or_else/","text":"unwrap_or_else() template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T const & , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T const & , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) const & ; template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < T && , std :: invoke_result_t < F &&>>>> , std :: common_type_t < T && , std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) && ; Returns the contained value or computes it from a invocable object op . Example int k = 10 ; assert ( maybe { just ( 4 )}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 4 ); assert ( maybe < int > {}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 20 );","title":""},{"location":"result/APIs/","text":"is_ok \u00b6 result<T, E>::is_ok() -> bool constexpr bool basic_result < _ , T , E >:: is_ok () const noexcept ; Returns true if the result is success . Example result < uint32_t , std :: string > x = success ( - 3 ); assert ( x . is_ok (), true ); result < uint32_t , std :: string > y = failure ( \"Some error message\" ); assert ( y . is_ok (), false ); is_err \u00b6 result<T, E>::is_err() -> bool constexpr bool basic_result < _ , T , E >:: is_err () const noexcept ; Returns true if the result is failure. Example result < uint32_t , std :: string > x = success ( - 3 ); assert_eq ( x . is_err (), false ); result < uint32_t , std :: string > y = failure ( \"Some error message\" ); assert_eq ( y . is_err (), true ); ok \u00b6 result<T, E>::ok() -> maybe<T> constexpr auto result < T , E >:: ok () & -> maybe < const T > ; constexpr auto result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto result < T , E >:: ok () && -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () & -> maybe < T > ; constexpr auto mut_result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () && -> maybe < T > ; Converts from basic_result to maybe . Converts self into an maybe , and discarding the failure value, if any. Note that these functions propagate mutability to optional element types. Example result < unsigned , std :: string > x = success ( 2 ); assert ( x . ok () == just ( 2 )); result < unsigned , std :: string > y = failure ( \"Nothing here\" ); assert ( y . ok () == nothing ); Remarks If self is rvalue and T is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < T >>>> . err \u00b6 result<T, E>::err() -> maybe<E> constexpr auto result < T , E >:: err () & -> maybe < const E > ; constexpr auto result < T , E >:: err () const & -> maybe < const E > ; constexpr auto result < T , E >:: err () && -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () & -> maybe < E > ; constexpr auto mut_result < T , E >:: err () const & -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () && -> maybe < E > ; Converts from basic_result to maybe . Converts self into an maybe , and discarding the success value, if any. Note that these functions propagate mutability to optional element types. Example result < unsigned , std :: string > x = success ( 2 ); assert ( x . err () == nothing ); result < unsigned , std :: string > y = failure ( \"Nothing here\" ); assert ( y . err () == just ( \"Nothing here\" s )); Remarks If self is rvalue and E is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> . map \u00b6 result<T, E>::map(O op) -> result<U, E> where O: T -> U constexpr auto basic_result < _ , T , E >:: map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , result < std :: invoke_result_t < O , T > , E >> ; Maps a result < T , E > to result < U , E > by applying a function to a contained success value, leaving an failure value untouched. This function can be used to compose the results of two functions. Example std :: string line = \"1,3,5,7\" ; for ( auto num : split ( line , \",\" )) { if ( auto res = parse < int > ( num ). map ( _1 * 2 ); res . is_ok ()) { assert_true ( res . ok (). value () % 2 == 0 ); } } map_or_else \u00b6 result<T, E>::map_or_else(Fallback _fallback, Map _map) -> U where Fallback: E -> U, Map: T -> U, template < class Map , class Fallback > constexpr auto basic_result < _ , T , E >:: map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; Maps a result < T , E > to U by applying a function to a contained success value, or a fallback function to a contained failure value. This function can be used to unpack a successful result while handling an error. Examples Basic usage: auto k = 21 ; { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); } map_err \u00b6 result<T, E>::map_err(O op) -> result<T, F> where O: E -> F template < class O > constexpr auto basic_result < _ , T , E >:: map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , result < T , std :: invoke_result_t < O , E >>> ; Maps a result < T , E > to result < T , F > by applying a function to a contained failure value, leaving an success value untouched. This function can be used to pass through a successful result while handling an error. Example auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; result < unsigned , unsigned > x = success ( 2 ); assert_eq ( x . map_err ( stringify ), success ( 2u )); result < unsigned , unsigned > y = failure ( 13 ); assert_eq ( y . map_err ( stringify ), failure ( \"error code: 13\" s )); conj \u00b6 result&ltT, E>::conj(result&ltU, E> res) -> result&ltU, E> template < class F > constexpr auto basic_result < _ , T , E >:: conj ( basic_result < _ , U , E > const & res ) const & -> result < U , E > ; template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: operator && ( basic_result < _ , U , E > const & res ) const & -> result < U , E > ; Returns res if the result is success , otherwise returns the failure value of self. Example { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < std :: string , std :: string > y = success ( \"foo\" s ); assert (( x && y ) == failure ( \"early error\" s )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"not a 2\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = success ( \"different result type\" s ); assert (( x && y ) == success ( \"different result type\" s )); } and_then \u00b6 result<T, E>::and_then(O op) -> result<U, E> where O: T -> result<U, E> template < class O > constexpr auto basic_result < _ , T , E >:: and_then ( O && op ) -> std :: invoke_result < O && , T > ; Calls op if the result is success, otherwise returns the failure value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v < std :: invoke_result_t < O , T > , failure < E >> is true. Example auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; assert ( success ( 2u ). and_then ( sq ). and_then ( sq ) == success ( 16u )); assert ( success ( 2u ). and_then ( sq ). and_then ( err ) == failure ( 4u )); assert ( success ( 2u ). and_then ( err ). and_then ( sq ) == failure ( 2u )); assert ( failure ( 3u ). and_then ( sq ). and_then ( sq ) == failure ( 3u )); disj \u00b6 result&ltT, E>::disj(result&ltT, F> res) -> result&ltT, F> template < class F > constexpr auto basic_result < _ , T , E >:: disj ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; template < class F > constexpr auto basic_result < _ , T , E >:: operator || ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; Returns res if the result is failure , otherwise returns the success value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. Example { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert_eq ( x || y , success ( 2u )); assert_eq ( x . disj ( y ), success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < unsigned , std :: string > y = success ( 2 ); assert_eq ( x || y , success ( 2u )); assert_eq ( x . disj ( y ), success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert_eq ( x || y , failure ( \"late error\" s )); assert_eq ( x . disj ( y ), failure ( \"late error\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = success ( 100 ); assert_eq ( x || y , success ( 2u )); assert_eq ( x . disj ( y ), success ( 2u )); } or_else \u00b6 result<T, E>::or_else(O op) ->result<T, F> where O: E -> result<T, F> template < class O > constexpr auto basic_result < _ , T , E >:: or_else ( O && op ) const & -> std :: invoke_result < O && , E > ; Calls op if the result is failure , otherwise returns the success value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v < std :: invoke_result_t < O , T > , success < T >> is true. Example auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; assert_eq ( success ( 2 ). or_else ( sq ). or_else ( sq ), success ( 2u )); assert_eq ( success ( 2 ). or_else ( err ). or_else ( sq ), success ( 2u )); assert_eq ( failure ( 3 ). or_else ( sq ). or_else ( err ), success ( 9u )); assert_eq ( failure ( 3 ). or_else ( err ). or_else ( err ), failure ( 3u )); unwrap_or \u00b6 result<, E>::unwrap_or(T const& optb) -> T auto basic_result < _ , T , E >:: unwrap_or ( T const & optb ) const noexcept Unwraps a result, yielding the content of an success . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example result < unsigned , unsigned > err = failure ( 2 ); result < unsigned , unsigned > ok = success ( 2 ); assert_eq ( ok . unwrap_or ( 1u ), 2u ); assert_eq ( err . unwrap_or ( 1u ), 1u ); unwrap_or_else \u00b6 result<T, E>::unwrap_or_else() -> T template < class O > auto basic_result < _ , T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > ; Unwraps a result, yielding the content of an success . If the value is an failure then it calls op with its value. Example auto count = []( std :: stringx ) -> size_t { return x . size (); }; assert_eq ( success ( 2 ). unwrap_or_else ( count ), 2 ); assert_eq ( failure ( \"foo\" s ). unwrap_or_else ( count ), 3 ); unwrap \u00b6 result<T, E>::unwrap() -> E& auto result < T , E >:: unwrap () & -> const T ; auto result < T , E >:: unwrap () const & -> const T ; auto result < T , E >:: unwrap () && -> const T ; auto mut_result < T , E >:: unwrap () & -> T ; auto mut_result < T , E >:: unwrap () const & -> const T ; auto mut_result < T , E >:: unwrap () && -> T ; Unwraps a result, yielding the content of an success . Exception Raise mitama :: runtime_panic if a result is containing failure value. Example { result < unsigned , std :: string > x = success ( 2 ); assert_eq ( x . unwrap (), 2 ); } try { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic cosnt & panic ) { std :: err << panic . what () << std :: endl ; // `emergency failure` } unwrap_err \u00b6 result<T, E>::unwrap_err() -> E& auto result < T , E >:: unwrap_err () & -> const E ; auto result < T , E >:: unwrap_err () const & -> const E ; auto result < T , E >:: unwrap_err () && -> const E ; auto mut_result < T , E >:: unwrap_err () & -> E ; auto mut_result < T , E >:: unwrap_err () const & -> const E ; auto mut_result < T , E >:: unwrap_err () && -> E ; Unwraps a result, yielding the content of an failure . Exception Raise mitama :: runtime_panic if a result is containing success value. Remarks If self is rvalue and E is a reference type, this function returns boost :: optional < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> . Example try { result < unsigned , std :: string > x = success ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: err << panic . what () << std :: endl ; // 2 } { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); assert_eq ( x . unwrap_err (), \"emergency failure\" s ); } unwrap_or_default \u00b6 result<T: DefaultConstructible, E>::unwrap_or_default() -> T auto basic_result < _ , T , E >:: unwrap_or_default () const & -> T ; Returns the contained value or a default. If success , returns the contained value, otherwise if failure , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example auto good_year_from_input = \"1909\" s ; auto bad_year_from_input = \"190blarg\" s ; auto good_year = parse < int > ( good_year_from_input ). unwrap_or_default (); auto bad_year = parse < int > ( bad_year_from_input ). unwrap_or_default (); assert_eq ( 1909 , good_year ); assert_eq ( 0 , bad_year ); * transpose \u00b6 result<<T>, E>::transpose() -> maybe<result<T, E>> auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; Transposes a result of an maybe into an maybe of a result . success ( nothing ) will be mapped to nothing . success ( just ( v )) and failure ( v ) will be mapped to just ( success ( v )) and just ( failure ( v )) . Example struct SomeError {}; result < maybe < int > , SomeError > x = success ( just ( 5 )); maybe < result < int , SomeError >> y = just ( success ( 5 )); assert_eq ! ( x . transpose (), y ); and_finally \u00b6 and_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &&>> and_finally ( F && f ) const & ; Invokes the provided function with the contained success value (if success), or doing nothing (if failure). Example maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & hook ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); or_finally \u00b6 or_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &&>> and_finally ( F && f ) const & ; Invokes the provided function with contained failure value (if failure), or doing nothing (if success). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); and_peek \u00b6 and_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> and_peek ( F && f ) && ; Peeks the contained success value and then returns self. Invokes the provided function with the contained value and then return self (if success), or return self without doing anything (if failure). Example maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & hook ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); or_peek \u00b6 or_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> or_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> or_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> or_peek ( F && f ) && ; Peeks the contained failure value and then returns self. Invokes the provided function and then return self (if failure), or return self without doing anything (if success). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 );","title":"APIs"},{"location":"result/APIs/#is_ok","text":"result<T, E>::is_ok() -> bool constexpr bool basic_result < _ , T , E >:: is_ok () const noexcept ; Returns true if the result is success . Example result < uint32_t , std :: string > x = success ( - 3 ); assert ( x . is_ok (), true ); result < uint32_t , std :: string > y = failure ( \"Some error message\" ); assert ( y . is_ok (), false );","title":"is_ok"},{"location":"result/APIs/#is_err","text":"result<T, E>::is_err() -> bool constexpr bool basic_result < _ , T , E >:: is_err () const noexcept ; Returns true if the result is failure. Example result < uint32_t , std :: string > x = success ( - 3 ); assert_eq ( x . is_err (), false ); result < uint32_t , std :: string > y = failure ( \"Some error message\" ); assert_eq ( y . is_err (), true );","title":"is_err"},{"location":"result/APIs/#ok","text":"result<T, E>::ok() -> maybe<T> constexpr auto result < T , E >:: ok () & -> maybe < const T > ; constexpr auto result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto result < T , E >:: ok () && -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () & -> maybe < T > ; constexpr auto mut_result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () && -> maybe < T > ; Converts from basic_result to maybe . Converts self into an maybe , and discarding the failure value, if any. Note that these functions propagate mutability to optional element types. Example result < unsigned , std :: string > x = success ( 2 ); assert ( x . ok () == just ( 2 )); result < unsigned , std :: string > y = failure ( \"Nothing here\" ); assert ( y . ok () == nothing ); Remarks If self is rvalue and T is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < T >>>> .","title":"ok"},{"location":"result/APIs/#err","text":"result<T, E>::err() -> maybe<E> constexpr auto result < T , E >:: err () & -> maybe < const E > ; constexpr auto result < T , E >:: err () const & -> maybe < const E > ; constexpr auto result < T , E >:: err () && -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () & -> maybe < E > ; constexpr auto mut_result < T , E >:: err () const & -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () && -> maybe < E > ; Converts from basic_result to maybe . Converts self into an maybe , and discarding the success value, if any. Note that these functions propagate mutability to optional element types. Example result < unsigned , std :: string > x = success ( 2 ); assert ( x . err () == nothing ); result < unsigned , std :: string > y = failure ( \"Nothing here\" ); assert ( y . err () == just ( \"Nothing here\" s )); Remarks If self is rvalue and E is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> .","title":"err"},{"location":"result/APIs/#map","text":"result<T, E>::map(O op) -> result<U, E> where O: T -> U constexpr auto basic_result < _ , T , E >:: map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , result < std :: invoke_result_t < O , T > , E >> ; Maps a result < T , E > to result < U , E > by applying a function to a contained success value, leaving an failure value untouched. This function can be used to compose the results of two functions. Example std :: string line = \"1,3,5,7\" ; for ( auto num : split ( line , \",\" )) { if ( auto res = parse < int > ( num ). map ( _1 * 2 ); res . is_ok ()) { assert_true ( res . ok (). value () % 2 == 0 ); } }","title":"map"},{"location":"result/APIs/#map_or_else","text":"result<T, E>::map_or_else(Fallback _fallback, Map _map) -> U where Fallback: E -> U, Map: T -> U, template < class Map , class Fallback > constexpr auto basic_result < _ , T , E >:: map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; Maps a result < T , E > to U by applying a function to a contained success value, or a fallback function to a contained failure value. This function can be used to unpack a successful result while handling an error. Examples Basic usage: auto k = 21 ; { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); }","title":"map_or_else"},{"location":"result/APIs/#map_err","text":"result<T, E>::map_err(O op) -> result<T, F> where O: E -> F template < class O > constexpr auto basic_result < _ , T , E >:: map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , result < T , std :: invoke_result_t < O , E >>> ; Maps a result < T , E > to result < T , F > by applying a function to a contained failure value, leaving an success value untouched. This function can be used to pass through a successful result while handling an error. Example auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; result < unsigned , unsigned > x = success ( 2 ); assert_eq ( x . map_err ( stringify ), success ( 2u )); result < unsigned , unsigned > y = failure ( 13 ); assert_eq ( y . map_err ( stringify ), failure ( \"error code: 13\" s ));","title":"map_err"},{"location":"result/APIs/#conj","text":"result&ltT, E>::conj(result&ltU, E> res) -> result&ltU, E> template < class F > constexpr auto basic_result < _ , T , E >:: conj ( basic_result < _ , U , E > const & res ) const & -> result < U , E > ; template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: operator && ( basic_result < _ , U , E > const & res ) const & -> result < U , E > ; Returns res if the result is success , otherwise returns the failure value of self. Example { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < std :: string , std :: string > y = success ( \"foo\" s ); assert (( x && y ) == failure ( \"early error\" s )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"not a 2\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = success ( \"different result type\" s ); assert (( x && y ) == success ( \"different result type\" s )); }","title":"conj"},{"location":"result/APIs/#and_then","text":"result<T, E>::and_then(O op) -> result<U, E> where O: T -> result<U, E> template < class O > constexpr auto basic_result < _ , T , E >:: and_then ( O && op ) -> std :: invoke_result < O && , T > ; Calls op if the result is success, otherwise returns the failure value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v < std :: invoke_result_t < O , T > , failure < E >> is true. Example auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; assert ( success ( 2u ). and_then ( sq ). and_then ( sq ) == success ( 16u )); assert ( success ( 2u ). and_then ( sq ). and_then ( err ) == failure ( 4u )); assert ( success ( 2u ). and_then ( err ). and_then ( sq ) == failure ( 2u )); assert ( failure ( 3u ). and_then ( sq ). and_then ( sq ) == failure ( 3u ));","title":"and_then"},{"location":"result/APIs/#disj","text":"result&ltT, E>::disj(result&ltT, F> res) -> result&ltT, F> template < class F > constexpr auto basic_result < _ , T , E >:: disj ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; template < class F > constexpr auto basic_result < _ , T , E >:: operator || ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; Returns res if the result is failure , otherwise returns the success value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. Example { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert_eq ( x || y , success ( 2u )); assert_eq ( x . disj ( y ), success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < unsigned , std :: string > y = success ( 2 ); assert_eq ( x || y , success ( 2u )); assert_eq ( x . disj ( y ), success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert_eq ( x || y , failure ( \"late error\" s )); assert_eq ( x . disj ( y ), failure ( \"late error\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = success ( 100 ); assert_eq ( x || y , success ( 2u )); assert_eq ( x . disj ( y ), success ( 2u )); }","title":"disj"},{"location":"result/APIs/#or_else","text":"result<T, E>::or_else(O op) ->result<T, F> where O: E -> result<T, F> template < class O > constexpr auto basic_result < _ , T , E >:: or_else ( O && op ) const & -> std :: invoke_result < O && , E > ; Calls op if the result is failure , otherwise returns the success value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v < std :: invoke_result_t < O , T > , success < T >> is true. Example auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; assert_eq ( success ( 2 ). or_else ( sq ). or_else ( sq ), success ( 2u )); assert_eq ( success ( 2 ). or_else ( err ). or_else ( sq ), success ( 2u )); assert_eq ( failure ( 3 ). or_else ( sq ). or_else ( err ), success ( 9u )); assert_eq ( failure ( 3 ). or_else ( err ). or_else ( err ), failure ( 3u ));","title":"or_else"},{"location":"result/APIs/#unwrap_or","text":"result<, E>::unwrap_or(T const& optb) -> T auto basic_result < _ , T , E >:: unwrap_or ( T const & optb ) const noexcept Unwraps a result, yielding the content of an success . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example result < unsigned , unsigned > err = failure ( 2 ); result < unsigned , unsigned > ok = success ( 2 ); assert_eq ( ok . unwrap_or ( 1u ), 2u ); assert_eq ( err . unwrap_or ( 1u ), 1u );","title":"unwrap_or"},{"location":"result/APIs/#unwrap_or_else","text":"result<T, E>::unwrap_or_else() -> T template < class O > auto basic_result < _ , T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > ; Unwraps a result, yielding the content of an success . If the value is an failure then it calls op with its value. Example auto count = []( std :: stringx ) -> size_t { return x . size (); }; assert_eq ( success ( 2 ). unwrap_or_else ( count ), 2 ); assert_eq ( failure ( \"foo\" s ). unwrap_or_else ( count ), 3 );","title":"unwrap_or_else"},{"location":"result/APIs/#unwrap","text":"result<T, E>::unwrap() -> E& auto result < T , E >:: unwrap () & -> const T ; auto result < T , E >:: unwrap () const & -> const T ; auto result < T , E >:: unwrap () && -> const T ; auto mut_result < T , E >:: unwrap () & -> T ; auto mut_result < T , E >:: unwrap () const & -> const T ; auto mut_result < T , E >:: unwrap () && -> T ; Unwraps a result, yielding the content of an success . Exception Raise mitama :: runtime_panic if a result is containing failure value. Example { result < unsigned , std :: string > x = success ( 2 ); assert_eq ( x . unwrap (), 2 ); } try { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic cosnt & panic ) { std :: err << panic . what () << std :: endl ; // `emergency failure` }","title":"unwrap"},{"location":"result/APIs/#unwrap_err","text":"result<T, E>::unwrap_err() -> E& auto result < T , E >:: unwrap_err () & -> const E ; auto result < T , E >:: unwrap_err () const & -> const E ; auto result < T , E >:: unwrap_err () && -> const E ; auto mut_result < T , E >:: unwrap_err () & -> E ; auto mut_result < T , E >:: unwrap_err () const & -> const E ; auto mut_result < T , E >:: unwrap_err () && -> E ; Unwraps a result, yielding the content of an failure . Exception Raise mitama :: runtime_panic if a result is containing success value. Remarks If self is rvalue and E is a reference type, this function returns boost :: optional < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> . Example try { result < unsigned , std :: string > x = success ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: err << panic . what () << std :: endl ; // 2 } { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); assert_eq ( x . unwrap_err (), \"emergency failure\" s ); }","title":"unwrap_err"},{"location":"result/APIs/#unwrap_or_default","text":"result<T: DefaultConstructible, E>::unwrap_or_default() -> T auto basic_result < _ , T , E >:: unwrap_or_default () const & -> T ; Returns the contained value or a default. If success , returns the contained value, otherwise if failure , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example auto good_year_from_input = \"1909\" s ; auto bad_year_from_input = \"190blarg\" s ; auto good_year = parse < int > ( good_year_from_input ). unwrap_or_default (); auto bad_year = parse < int > ( bad_year_from_input ). unwrap_or_default (); assert_eq ( 1909 , good_year ); assert_eq ( 0 , bad_year ); *","title":"unwrap_or_default"},{"location":"result/APIs/#transpose","text":"result<<T>, E>::transpose() -> maybe<result<T, E>> auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; Transposes a result of an maybe into an maybe of a result . success ( nothing ) will be mapped to nothing . success ( just ( v )) and failure ( v ) will be mapped to just ( success ( v )) and just ( failure ( v )) . Example struct SomeError {}; result < maybe < int > , SomeError > x = success ( just ( 5 )); maybe < result < int , SomeError >> y = just ( success ( 5 )); assert_eq ! ( x . transpose (), y );","title":"transpose"},{"location":"result/APIs/#and_finally","text":"and_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &&>> and_finally ( F && f ) const & ; Invokes the provided function with the contained success value (if success), or doing nothing (if failure). Example maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & hook ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 );","title":"and_finally"},{"location":"result/APIs/#or_finally","text":"or_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &&>> and_finally ( F && f ) const & ; Invokes the provided function with contained failure value (if failure), or doing nothing (if success). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 );","title":"or_finally"},{"location":"result/APIs/#and_peek","text":"and_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> and_peek ( F && f ) && ; Peeks the contained success value and then returns self. Invokes the provided function with the contained value and then return self (if success), or return self without doing anything (if failure). Example maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & hook ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 );","title":"and_peek"},{"location":"result/APIs/#or_peek","text":"or_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> or_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> or_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> or_peek ( F && f ) && ; Peeks the contained failure value and then returns self. Invokes the provided function and then return self (if failure), or return self without doing anything (if success). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 );","title":"or_peek"},{"location":"result/comparisons/","text":"operator== [1/3] template < mutability _ , class U , class F > bool basic_result < _ , T , E >:: operator == ( basic_result < _ , U , F > const & rhs ) const & ; Equality comparison for basic_result < _ , T , E > and basic_result < _ , U , F > . Remarks This operator shall not participate in overload resolution unless std :: declval < T const &> () == std :: declval < U const &> () is valid expression and std :: declval < E const &> () == std :: declval < F const &> () is valid expression. operator==() [2/3] template < class U > bool result :: operator == ( success < U > const & rhs ) const & Equality comparison for basic_result < _ , T , E > and success < U > . Returns true if this has success value this -> unwrap () equals rhs value, otherwise false . Remarks This operator shall not participate in overload resolution unless std :: declval < T const &> () == std :: declval < U const &> () is valid expression. operator==() [3/3] template < class F > bool basic_result :: operator == ( failure < F > const & rhs ) const & Equality comparison for basic_result < _ , T , E > and failure < F > . Returns true if this has failure value this -> unwrap_err () equals rhs value, otherwise false . Remarks This operator shall not participate in overload resolution unless std :: declval < E const &> () == std :: declval < F const &> () is valid expression.","title":""},{"location":"result/intro/","text":"Introduction \u00b6 Definition of class basic_result \u00b6 enum class mutability : bool { mut = false , immut = true , }; template < mutability Mut > inline constexpr bool is_mut_v = ! static_cast < bool > ( Mut ); template < mutability , class = std :: monostate , // success type class = std :: monostate , // failure type class = decltype ( nullptr ) // for detection idiom > class basic_result ; Concepts \u00b6 basic_result < _ , T , E > is a class that holds either a success value type T or a failure value type E . basic_result < _ , T , E > holds values like boost :: variant < T , E > . Therefore, T and E must satisfy the following requirements for bounded types: CopyConstructible or MoveConstructible. Destructor upholds the no-throw exception-safety guarantee. Complete at the point of variant template instantiation. In more detail, see the document . result/mut_result the alias templates \u00b6 First (non-type) template parameter of basic_result is a value of enum class mutability for mutability control. The library provides two type synonyms of basic_result as follows: mut_result < T , E > stands for basic_result < mutability :: mut , T , E > result < T , E > stands for basic_result < mutability :: immut , T , E > You should use mut_result < T , E > if you want to resubstitute, result < T , E > do not provides assignment operators or mutable accessors. success/failure the in-place factory classes \u00b6 success and failure are in-place factory classes for basic_result . If you want to initialize result < T , E > with successful value of T , initialize with success < T > . result < int , std :: string > res = success ( 42 ); Similarly, if you want to initialize result < T , E > with unsuccessful value of E , initialize with failure < E > . result < int , std :: string > res = failure ( \"error\" s ); Result of reference types \u00b6 (In Progress...)","title":"Result 101"},{"location":"result/intro/#introduction","text":"","title":"Introduction"},{"location":"result/intro/#definition_of_class_basic_result","text":"enum class mutability : bool { mut = false , immut = true , }; template < mutability Mut > inline constexpr bool is_mut_v = ! static_cast < bool > ( Mut ); template < mutability , class = std :: monostate , // success type class = std :: monostate , // failure type class = decltype ( nullptr ) // for detection idiom > class basic_result ;","title":"Definition of class basic_result"},{"location":"result/intro/#concepts","text":"basic_result < _ , T , E > is a class that holds either a success value type T or a failure value type E . basic_result < _ , T , E > holds values like boost :: variant < T , E > . Therefore, T and E must satisfy the following requirements for bounded types: CopyConstructible or MoveConstructible. Destructor upholds the no-throw exception-safety guarantee. Complete at the point of variant template instantiation. In more detail, see the document .","title":"Concepts"},{"location":"result/intro/#resultmut_result_the_alias_templates","text":"First (non-type) template parameter of basic_result is a value of enum class mutability for mutability control. The library provides two type synonyms of basic_result as follows: mut_result < T , E > stands for basic_result < mutability :: mut , T , E > result < T , E > stands for basic_result < mutability :: immut , T , E > You should use mut_result < T , E > if you want to resubstitute, result < T , E > do not provides assignment operators or mutable accessors.","title":"result/mut_result the alias templates"},{"location":"result/intro/#successfailure_the_in-place_factory_classes","text":"success and failure are in-place factory classes for basic_result . If you want to initialize result < T , E > with successful value of T , initialize with success < T > . result < int , std :: string > res = success ( 42 ); Similarly, if you want to initialize result < T , E > with unsuccessful value of E , initialize with failure < E > . result < int , std :: string > res = failure ( \"error\" s );","title":"success/failure the in-place factory classes"},{"location":"result/intro/#result_of_reference_types","text":"(In Progress...)","title":"Result of reference types"},{"location":"result/metafunctions/","text":"is_result \u00b6 is_result \u00b6 template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ; is_result_with \u00b6 is_result_with \u00b6 template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"Meta Functions"},{"location":"result/metafunctions/#is_result","text":"","title":"is_result"},{"location":"result/metafunctions/#is_result_1","text":"template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":"is_result"},{"location":"result/metafunctions/#is_result_with","text":"","title":"is_result_with"},{"location":"result/metafunctions/#is_result_with_1","text":"template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"is_result_with"},{"location":"result/special_members/","text":"Constructors \u00b6 default constructor (deleted) [0/16] \u00b6 Default constructor is not permitted. explicit copy constructor for convertible basic_result [1/16] \u00b6 template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v < T , U > && is_nothrow_copy_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true and std :: disjunction < std :: negation < std :: is_convertible < F , E >> , std :: negation < std :: is_convertible < U , T >>> is true. If is_trivially_copy_constructible_v < T , U > && is_trivially_copy_constructible_v < E , F > is true, this constructor shall be a constexpr constructor. non-explicit copy constructor for convertible basic_result [2/16] \u00b6 template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v < T , U > && is_nothrow_copy_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true, std :: is_convertible < F , E > is true and, std :: is_convertible < U , T >> is true. If is_trivially_copy_constructible_v < T , U > && is_trivially_copy_constructible_v < E , F > is true, this constructor shall be a constexpr constructor. explicit move constructor for convertible basic_result [3/16] \u00b6 template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v < T , U > && is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true and, std :: disjunction < std :: negation < std :: is_convertible < F , E >> , std :: negation < std :: is_convertible < U , T >>> is true. If is_trivially_move_constructible_v < T , U > && is_trivially_move_constructible_v < E , F > is true, this constructor shall be a constexpr constructor. non-explicit copy constructor for convertible basic_result [4/16] \u00b6 template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v < T , U > && is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true, std :: is_convertible < F , E > is true and, std :: is_convertible < U , T >> is true. If is_trivially_move_constructible_v < T , U > && is_trivially_move_constructible_v < E , F > is true, this constructor shall be a constexpr constructor. non-explicit copy constructor from success [5/16] \u00b6 template < class U > basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && is_convertible_v < U , T > is true. explicit copy constructor from success [6/16] \u00b6 template < class U > explicit basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && ! is_convertible_v < U , T > is true. non-explicit move constructor from success [7/16] \u00b6 template < class U > basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && is_convertible_v < U , T > is true. explicit move constructor from success [8/16] \u00b6 template < class U > explicit basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && ! is_convertible_v < U , T > is true. non-explicit copy constructor from failure [9/16] \u00b6 template < class F > basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && is_convertible_v < F , E > is true. explicit copy constructor from failure [10/16] \u00b6 template < class F > explicit basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && ! is_convertible_v < F , E > is true. non-explicit move constructor from failure [11/16] \u00b6 template < class F > basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && is_convertible_v < F , E > is true. explicit move constructor from failure [12/16] \u00b6 template < class F > explicit basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E >&& . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , U > && ! is_convertible_v < U , E > is true. emplace constructor for successful results [13/16] \u00b6 template < class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , Args && ... args ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( success < T > ( std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , Args && ... > is true, this constructor shall be a nothrow constructor. Example using my_result = result < std :: tuple < int , int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , 1 , 1 ); // same as `my_result(success(std::tuple{1,1}))` emplace constructor for unsuccessful results [14/16] \u00b6 template < class ... Args > explicit basic_result :: basic_result ( in_place_err_t , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( failure < E > ( std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , Args && ... > is true, this constructor shall be a nothrow constructor. Example using my_result = result < int , std :: string > ; auto res = my_result ( mitama :: in_place_err , 'a' , 5 ); // failure(\"aaaaa\") emplace constructor with initializer_list for successful results [15/16] \u00b6 template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( success < T > ( il , std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of T. Example using my_result = result < std :: vector < int > , std :: string > ; auto res = my_result ( in_place_ok , { 1 , 2 , 3 , 4 }, std :: allocator < int > ()); // success([1,2,3,4]) emplace constructor with initializer_list for unsuccessful results [16/16] \u00b6 template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( failure < E > ( il , std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = result < std :: string , std :: vector < int >> ; auto res = my_result ( in_place_err , { 1 , 2 , 3 , 4 }); // failure([1,2,3,4]) Assignment operators \u00b6 copy assignment operator [1/6] \u00b6 template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F > const & res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable. move assignment operator [2/6] \u00b6 template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F >&& res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable. copy assignment operator for success [3/6] \u00b6 template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U > const & _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable. move assignment operator for success [4/6] \u00b6 template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U >&& _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable. copy assignment operator for failure [5/6] \u00b6 template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F > const & _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable. move assignment operator for failure [6/6] \u00b6 template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F >&& _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"Special Members"},{"location":"result/special_members/#constructors","text":"","title":"Constructors"},{"location":"result/special_members/#default_constructor_deleted_016","text":"Default constructor is not permitted.","title":"default constructor (deleted) [0/16]"},{"location":"result/special_members/#explicit_copy_constructor_for_convertible_basic_result_116","text":"template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v < T , U > && is_nothrow_copy_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true and std :: disjunction < std :: negation < std :: is_convertible < F , E >> , std :: negation < std :: is_convertible < U , T >>> is true. If is_trivially_copy_constructible_v < T , U > && is_trivially_copy_constructible_v < E , F > is true, this constructor shall be a constexpr constructor.","title":"explicit copy constructor for convertible basic_result [1/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_for_convertible_basic_result_216","text":"template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v < T , U > && is_nothrow_copy_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true, std :: is_convertible < F , E > is true and, std :: is_convertible < U , T >> is true. If is_trivially_copy_constructible_v < T , U > && is_trivially_copy_constructible_v < E , F > is true, this constructor shall be a constexpr constructor.","title":"non-explicit copy constructor for convertible basic_result [2/16]"},{"location":"result/special_members/#explicit_move_constructor_for_convertible_basic_result_316","text":"template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v < T , U > && is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true and, std :: disjunction < std :: negation < std :: is_convertible < F , E >> , std :: negation < std :: is_convertible < U , T >>> is true. If is_trivially_move_constructible_v < T , U > && is_trivially_move_constructible_v < E , F > is true, this constructor shall be a constexpr constructor.","title":"explicit move constructor for convertible basic_result [3/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_for_convertible_basic_result_416","text":"template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v < T , U > && is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std :: is_constructible < T , U > is true, std :: is_constructible < E , F > is true, std :: is_convertible < F , E > is true and, std :: is_convertible < U , T >> is true. If is_trivially_move_constructible_v < T , U > && is_trivially_move_constructible_v < E , F > is true, this constructor shall be a constexpr constructor.","title":"non-explicit copy constructor for convertible basic_result [4/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_from_success_516","text":"template < class U > basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && is_convertible_v < U , T > is true.","title":"non-explicit copy constructor from success [5/16]"},{"location":"result/special_members/#explicit_copy_constructor_from_success_616","text":"template < class U > explicit basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && ! is_convertible_v < U , T > is true.","title":"explicit copy constructor from success [6/16]"},{"location":"result/special_members/#non-explicit_move_constructor_from_success_716","text":"template < class U > basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && is_convertible_v < U , T > is true.","title":"non-explicit move constructor from success [7/16]"},{"location":"result/special_members/#explicit_move_constructor_from_success_816","text":"template < class U > explicit basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success < T > . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , U > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < T , U > && ! is_convertible_v < U , T > is true.","title":"explicit move constructor from success [8/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_from_failure_916","text":"template < class F > basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && is_convertible_v < F , E > is true.","title":"non-explicit copy constructor from failure [9/16]"},{"location":"result/special_members/#explicit_copy_constructor_from_failure_1016","text":"template < class F > explicit basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && ! is_convertible_v < F , E > is true.","title":"explicit copy constructor from failure [10/16]"},{"location":"result/special_members/#non-explicit_move_constructor_from_failure_1116","text":"template < class F > basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E > . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , F > && is_convertible_v < F , E > is true.","title":"non-explicit move constructor from failure [11/16]"},{"location":"result/special_members/#explicit_move_constructor_from_failure_1216","text":"template < class F > explicit basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure < E >&& . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , F > is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v < E , U > && ! is_convertible_v < U , E > is true.","title":"explicit move constructor from failure [12/16]"},{"location":"result/special_members/#emplace_constructor_for_successful_results_1316","text":"template < class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , Args && ... args ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( success < T > ( std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v < T , Args && ... > is true, this constructor shall be a nothrow constructor. Example using my_result = result < std :: tuple < int , int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , 1 , 1 ); // same as `my_result(success(std::tuple{1,1}))`","title":"emplace constructor for successful results [13/16]"},{"location":"result/special_members/#emplace_constructor_for_unsuccessful_results_1416","text":"template < class ... Args > explicit basic_result :: basic_result ( in_place_err_t , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( failure < E > ( std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v < E , Args && ... > is true, this constructor shall be a nothrow constructor. Example using my_result = result < int , std :: string > ; auto res = my_result ( mitama :: in_place_err , 'a' , 5 ); // failure(\"aaaaa\")","title":"emplace constructor for unsuccessful results [14/16]"},{"location":"result/special_members/#emplace_constructor_with_initializer_list_for_successful_results_1516","text":"template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( success < T > ( il , std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of T. Example using my_result = result < std :: vector < int > , std :: string > ; auto res = my_result ( in_place_ok , { 1 , 2 , 3 , 4 }, std :: allocator < int > ()); // success([1,2,3,4])","title":"emplace constructor with initializer_list for successful results [15/16]"},{"location":"result/special_members/#emplace_constructor_with_initializer_list_for_unsuccessful_results_1616","text":"template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression ( failure < E > ( il , std :: forward < Args > ( args )...)) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = result < std :: string , std :: vector < int >> ; auto res = my_result ( in_place_err , { 1 , 2 , 3 , 4 }); // failure([1,2,3,4])","title":"emplace constructor with initializer_list for unsuccessful results [16/16]"},{"location":"result/special_members/#assignment_operators","text":"","title":"Assignment operators"},{"location":"result/special_members/#copy_assignment_operator_16","text":"template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F > const & res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator [1/6]"},{"location":"result/special_members/#move_assignment_operator_26","text":"template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F >&& res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator [2/6]"},{"location":"result/special_members/#copy_assignment_operator_for_success_36","text":"template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U > const & _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator for success [3/6]"},{"location":"result/special_members/#move_assignment_operator_for_success_46","text":"template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U >&& _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator for success [4/6]"},{"location":"result/special_members/#copy_assignment_operator_for_failure_56","text":"template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F > const & _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator for failure [5/6]"},{"location":"result/special_members/#move_assignment_operator_for_failure_66","text":"template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F >&& _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator for failure [6/6]"},{"location":"result/_APIs/","text":"CHANGELOG \u00b6 v5.0.0 (breaking change!) Types \u00b6 basic_result { Result < T , E > => basic_result < mutability , T , E > } Enabled lvalue reference types for both of T and E result < T , E > the alias template for immutable basic_result mut_result < T , E > the alias template for mutable basic_result success { Ok < T > => success < T > } Enabled lvalue reference types for T . failure { Err < E > => failure < E > } Enabled lvalue reference types for E . New APIs \u00b6 as_ref () as_mut () indirect () indirect_ok () indirect_err () v1.2.0 enhancement \u00b6 new API: transpose new API: map_or_else v1.1.2 bug fix \u00b6 Result ::and_then(O&& op) do not perticipate in overload resolution if unless op returns Result < U , E > . std :: invoke_result_t < O && , T > must be returns Result < U , E > . It means op must only maps T -> U , never changes E . Result ::or_else(O&& op) do not perticipate in overload resolution if unless op returns Result < T , F > . std :: invoke_result_t < O && , E > must be returns Result < T , F > . It means op must only maps E -> F , never changes T . v1.1.1 bug fix \u00b6 Result ::unwrap_or_default() is now explicitly deleted if and only if std :: is_default_constructible_v < T > || std :: is_aggregate_v < T > is false.","title":"CHANGELOG"},{"location":"result/_APIs/#changelog","text":"v5.0.0 (breaking change!)","title":"CHANGELOG"},{"location":"result/_APIs/#types","text":"basic_result { Result < T , E > => basic_result < mutability , T , E > } Enabled lvalue reference types for both of T and E result < T , E > the alias template for immutable basic_result mut_result < T , E > the alias template for mutable basic_result success { Ok < T > => success < T > } Enabled lvalue reference types for T . failure { Err < E > => failure < E > } Enabled lvalue reference types for E .","title":"Types"},{"location":"result/_APIs/#new_apis","text":"as_ref () as_mut () indirect () indirect_ok () indirect_err () v1.2.0","title":"New APIs"},{"location":"result/_APIs/#enhancement","text":"new API: transpose new API: map_or_else v1.1.2","title":"enhancement"},{"location":"result/_APIs/#bug_fix","text":"Result ::and_then(O&& op) do not perticipate in overload resolution if unless op returns Result < U , E > . std :: invoke_result_t < O && , T > must be returns Result < U , E > . It means op must only maps T -> U , never changes E . Result ::or_else(O&& op) do not perticipate in overload resolution if unless op returns Result < T , F > . std :: invoke_result_t < O && , E > must be returns Result < T , F > . It means op must only maps E -> F , never changes T . v1.1.1","title":"bug fix"},{"location":"result/_APIs/#bug_fix_1","text":"Result ::unwrap_or_default() is now explicitly deleted if and only if std :: is_default_constructible_v < T > || std :: is_aggregate_v < T > is false.","title":"bug fix"},{"location":"result/_APIs/and_finally/","text":"and_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , T &&>> and_finally ( F && f ) const & ; Invokes the provided function with the contained success value (if success), or doing nothing (if failure). Example maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & hook ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 );","title":""},{"location":"result/_APIs/and_peek/","text":"and_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> and_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> and_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> and_peek ( F && f ) && ; Peeks the contained success value and then returns self. Invokes the provided function with the contained value and then return self (if success), or return self without doing anything (if failure). Example maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & hook ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 );","title":""},{"location":"result/_APIs/and_then/","text":"result<T, E>::and_then(O op) -> result<U, E> where O: T -> result<U, E> template < class O > constexpr auto basic_result < _ , T , E >:: and_then ( O && op ) -> std :: invoke_result < O && , T > ; Calls op if the result is success, otherwise returns the failure value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v < std :: invoke_result_t < O , T > , failure < E >> is true. Example auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; assert ( success ( 2u ). and_then ( sq ). and_then ( sq ) == success ( 16u )); assert ( success ( 2u ). and_then ( sq ). and_then ( err ) == failure ( 4u )); assert ( success ( 2u ). and_then ( err ). and_then ( sq ) == failure ( 2u )); assert ( failure ( 3u ). and_then ( sq ). and_then ( sq ) == failure ( 3u ));","title":""},{"location":"result/_APIs/conj/","text":"result&ltT, E>::conj(result&ltU, E> res) -> result&ltU, E> template < class F > constexpr auto basic_result < _ , T , E >:: conj ( basic_result < _ , U , E > const & res ) const & -> result < U , E > ; template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: operator && ( basic_result < _ , U , E > const & res ) const & -> result < U , E > ; Returns res if the result is success , otherwise returns the failure value of self. Example { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < std :: string , std :: string > y = success ( \"foo\" s ); assert (( x && y ) == failure ( \"early error\" s )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"not a 2\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = success ( \"different result type\" s ); assert (( x && y ) == success ( \"different result type\" s )); }","title":""},{"location":"result/_APIs/disj/","text":"result&ltT, E>::disj(result&ltT, F> res) -> result&ltT, F> template < class F > constexpr auto basic_result < _ , T , E >:: disj ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; template < class F > constexpr auto basic_result < _ , T , E >:: operator || ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; Returns res if the result is failure , otherwise returns the success value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. Example { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert_eq ( x || y , success ( 2u )); assert_eq ( x . disj ( y ), success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < unsigned , std :: string > y = success ( 2 ); assert_eq ( x || y , success ( 2u )); assert_eq ( x . disj ( y ), success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert_eq ( x || y , failure ( \"late error\" s )); assert_eq ( x . disj ( y ), failure ( \"late error\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = success ( 100 ); assert_eq ( x || y , success ( 2u )); assert_eq ( x . disj ( y ), success ( 2u )); }","title":""},{"location":"result/_APIs/err/","text":"result<T, E>::err() -> maybe<E> constexpr auto result < T , E >:: err () & -> maybe < const E > ; constexpr auto result < T , E >:: err () const & -> maybe < const E > ; constexpr auto result < T , E >:: err () && -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () & -> maybe < E > ; constexpr auto mut_result < T , E >:: err () const & -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () && -> maybe < E > ; Converts from basic_result to maybe . Converts self into an maybe , and discarding the success value, if any. Note that these functions propagate mutability to optional element types. Example result < unsigned , std :: string > x = success ( 2 ); assert ( x . err () == nothing ); result < unsigned , std :: string > y = failure ( \"Nothing here\" ); assert ( y . err () == just ( \"Nothing here\" s )); Remarks If self is rvalue and E is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> .","title":""},{"location":"result/_APIs/is_err/","text":"result<T, E>::is_err() -> bool constexpr bool basic_result < _ , T , E >:: is_err () const noexcept ; Returns true if the result is failure. Example result < uint32_t , std :: string > x = success ( - 3 ); assert_eq ( x . is_err (), false ); result < uint32_t , std :: string > y = failure ( \"Some error message\" ); assert_eq ( y . is_err (), true );","title":""},{"location":"result/_APIs/is_ok/","text":"result<T, E>::is_ok() -> bool constexpr bool basic_result < _ , T , E >:: is_ok () const noexcept ; Returns true if the result is success . Example result < uint32_t , std :: string > x = success ( - 3 ); assert ( x . is_ok (), true ); result < uint32_t , std :: string > y = failure ( \"Some error message\" ); assert ( y . is_ok (), false );","title":""},{"location":"result/_APIs/map/","text":"result<T, E>::map(O op) -> result<U, E> where O: T -> U constexpr auto basic_result < _ , T , E >:: map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , result < std :: invoke_result_t < O , T > , E >> ; Maps a result < T , E > to result < U , E > by applying a function to a contained success value, leaving an failure value untouched. This function can be used to compose the results of two functions. Example std :: string line = \"1,3,5,7\" ; for ( auto num : split ( line , \",\" )) { if ( auto res = parse < int > ( num ). map ( _1 * 2 ); res . is_ok ()) { assert_true ( res . ok (). value () % 2 == 0 ); } }","title":""},{"location":"result/_APIs/map_err/","text":"result<T, E>::map_err(O op) -> result<T, F> where O: E -> F template < class O > constexpr auto basic_result < _ , T , E >:: map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , result < T , std :: invoke_result_t < O , E >>> ; Maps a result < T , E > to result < T , F > by applying a function to a contained failure value, leaving an success value untouched. This function can be used to pass through a successful result while handling an error. Example auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; result < unsigned , unsigned > x = success ( 2 ); assert_eq ( x . map_err ( stringify ), success ( 2u )); result < unsigned , unsigned > y = failure ( 13 ); assert_eq ( y . map_err ( stringify ), failure ( \"error code: 13\" s ));","title":""},{"location":"result/_APIs/map_or_else/","text":"result<T, E>::map_or_else(Fallback _fallback, Map _map) -> U where Fallback: E -> U, Map: T -> U, template < class Map , class Fallback > constexpr auto basic_result < _ , T , E >:: map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; Maps a result < T , E > to U by applying a function to a contained success value, or a fallback function to a contained failure value. This function can be used to unpack a successful result while handling an error. Examples Basic usage: auto k = 21 ; { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); }","title":""},{"location":"result/_APIs/ok/","text":"result<T, E>::ok() -> maybe<T> constexpr auto result < T , E >:: ok () & -> maybe < const T > ; constexpr auto result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto result < T , E >:: ok () && -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () & -> maybe < T > ; constexpr auto mut_result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () && -> maybe < T > ; Converts from basic_result to maybe . Converts self into an maybe , and discarding the failure value, if any. Note that these functions propagate mutability to optional element types. Example result < unsigned , std :: string > x = success ( 2 ); assert ( x . ok () == just ( 2 )); result < unsigned , std :: string > y = failure ( \"Nothing here\" ); assert ( y . ok () == nothing ); Remarks If self is rvalue and T is a reference type, this function returns maybe < dangling < std :: reference_wrapper < std :: remove_reference_t < T >>>> .","title":""},{"location":"result/_APIs/or_else/","text":"result<T, E>::or_else(O op) ->result<T, F> where O: E -> result<T, F> template < class O > constexpr auto basic_result < _ , T , E >:: or_else ( O && op ) const & -> std :: invoke_result < O && , E > ; Calls op if the result is failure , otherwise returns the success value of self. This function can be used for control flow based on result values. Remarks This constructor shall not participate in overload resolution unless is_result_with_v < std :: invoke_result_t < O , T > , success < T >> is true. Example auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; assert_eq ( success ( 2 ). or_else ( sq ). or_else ( sq ), success ( 2u )); assert_eq ( success ( 2 ). or_else ( err ). or_else ( sq ), success ( 2u )); assert_eq ( failure ( 3 ). or_else ( sq ). or_else ( err ), success ( 9u )); assert_eq ( failure ( 3 ). or_else ( err ). or_else ( err ), failure ( 3u ));","title":""},{"location":"result/_APIs/or_finally/","text":"or_finally(F f) -> void template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &>> and_finally ( F && f ) & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E const &>> and_finally ( F && f ) const & ; template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , E &&>> and_finally ( F && f ) const & ; Invokes the provided function with contained failure value (if failure), or doing nothing (if success). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 );","title":""},{"location":"result/_APIs/or_peek/","text":"or_peek(F f) -> maybe<T> template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &> , std :: is_invocable < F >> , basic_result &> or_peek ( F && f ) & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T const &> , std :: is_invocable < F >> , basic_result const &> or_peek ( F && f ) const & ; template < class F > std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , T &&> , std :: is_invocable < F >> , basic_result &&> or_peek ( F && f ) && ; Peeks the contained failure value and then returns self. Invokes the provided function and then return self (if failure), or return self without doing anything (if success). Example maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 );","title":""},{"location":"result/_APIs/transpose/","text":"result<<T>, E>::transpose() -> maybe<result<T, E>> auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; Transposes a result of an maybe into an maybe of a result . success ( nothing ) will be mapped to nothing . success ( just ( v )) and failure ( v ) will be mapped to just ( success ( v )) and just ( failure ( v )) . Example struct SomeError {}; result < maybe < int > , SomeError > x = success ( just ( 5 )); maybe < result < int , SomeError >> y = just ( success ( 5 )); assert_eq ! ( x . transpose (), y );","title":""},{"location":"result/_APIs/unwrap/","text":"result<T, E>::unwrap() -> E& auto result < T , E >:: unwrap () & -> const T ; auto result < T , E >:: unwrap () const & -> const T ; auto result < T , E >:: unwrap () && -> const T ; auto mut_result < T , E >:: unwrap () & -> T ; auto mut_result < T , E >:: unwrap () const & -> const T ; auto mut_result < T , E >:: unwrap () && -> T ; Unwraps a result, yielding the content of an success . Exception Raise mitama :: runtime_panic if a result is containing failure value. Example { result < unsigned , std :: string > x = success ( 2 ); assert_eq ( x . unwrap (), 2 ); } try { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic cosnt & panic ) { std :: err << panic . what () << std :: endl ; // `emergency failure` }","title":""},{"location":"result/_APIs/unwrap_err/","text":"result<T, E>::unwrap_err() -> E& auto result < T , E >:: unwrap_err () & -> const E ; auto result < T , E >:: unwrap_err () const & -> const E ; auto result < T , E >:: unwrap_err () && -> const E ; auto mut_result < T , E >:: unwrap_err () & -> E ; auto mut_result < T , E >:: unwrap_err () const & -> const E ; auto mut_result < T , E >:: unwrap_err () && -> E ; Unwraps a result, yielding the content of an failure . Exception Raise mitama :: runtime_panic if a result is containing success value. Remarks If self is rvalue and E is a reference type, this function returns boost :: optional < dangling < std :: reference_wrapper < std :: remove_reference_t < E >>>> . Example try { result < unsigned , std :: string > x = success ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: err << panic . what () << std :: endl ; // 2 } { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); assert_eq ( x . unwrap_err (), \"emergency failure\" s ); }","title":""},{"location":"result/_APIs/unwrap_or/","text":"result<, E>::unwrap_or(T const& optb) -> T auto basic_result < _ , T , E >:: unwrap_or ( T const & optb ) const noexcept Unwraps a result, yielding the content of an success . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example result < unsigned , unsigned > err = failure ( 2 ); result < unsigned , unsigned > ok = success ( 2 ); assert_eq ( ok . unwrap_or ( 1u ), 2u ); assert_eq ( err . unwrap_or ( 1u ), 1u );","title":""},{"location":"result/_APIs/unwrap_or_default/","text":"result<T: DefaultConstructible, E>::unwrap_or_default() -> T auto basic_result < _ , T , E >:: unwrap_or_default () const & -> T ; Returns the contained value or a default. If success , returns the contained value, otherwise if failure , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v < T > is true. Example auto good_year_from_input = \"1909\" s ; auto bad_year_from_input = \"190blarg\" s ; auto good_year = parse < int > ( good_year_from_input ). unwrap_or_default (); auto bad_year = parse < int > ( bad_year_from_input ). unwrap_or_default (); assert_eq ( 1909 , good_year ); assert_eq ( 0 , bad_year ); *","title":""},{"location":"result/_APIs/unwrap_or_else/","text":"result<T, E>::unwrap_or_else() -> T template < class O > auto basic_result < _ , T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > ; Unwraps a result, yielding the content of an success . If the value is an failure then it calls op with its value. Example auto count = []( std :: stringx ) -> size_t { return x . size (); }; assert_eq ( success ( 2 ). unwrap_or_else ( count ), 2 ); assert_eq ( failure ( \"foo\" s ). unwrap_or_else ( count ), 3 );","title":""},{"location":"result/_metafunctions/is_result/","text":"is_result \u00b6 template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":""},{"location":"result/_metafunctions/is_result/#is_result","text":"template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":"is_result"},{"location":"result/_metafunctions/is_result_with/","text":"is_result_with \u00b6 template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":""},{"location":"result/_metafunctions/is_result_with/#is_result_with","text":"template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"is_result_with"}]}