{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Result is a header only C++17 library for error handling. Prerequisites and installation Compiler/Toolchain Status clang >= 5.0.0 Testing on Wandbox; tested on each push to GitHub gcc >= 7.1.0 Testing on Wandbox; tested on each push to GitHub More specifically, Mitama.Result requires a compiler/standard library supporting the following C++17 features: constexpr if inline variables class template deduction and deduction guide All the C++17 type traits from the header std::optional from the header std::variant from the header Basic Usage Here is a bad code, see below. If this program fail to assert, you don't know the reason for the error. bool func ( int a ) { if ( first check ) return false ; if ( second check ) return false ; if ( third check ) return false ; // function body... return true ; } // ... assert ( func ( 42 )); Here is a code using Result. Even if this program fail to assert, you can get the reason for the error. auto func ( int a ) -> mitama :: Result < int , std :: string > { if ( first check ) return mitama :: Err ( \"first check failed\" ); // early return if ( second check ) return mitama :: Err ( \"second check failed\" ); // early return if ( third check ) return mitama :: Err ( \"third check failed\" ); // early return // function body... return mitama :: Ok ( 42 ); } // ... int value func ( 42 ). unwrap (); // even if fail to unwrap, // raise runtime_panic // and you get reason for the error.","title":"Home"},{"location":"#introduction","text":"Result is a header only C++17 library for error handling.","title":"Introduction"},{"location":"#prerequisites-and-installation","text":"Compiler/Toolchain Status clang >= 5.0.0 Testing on Wandbox; tested on each push to GitHub gcc >= 7.1.0 Testing on Wandbox; tested on each push to GitHub More specifically, Mitama.Result requires a compiler/standard library supporting the following C++17 features: constexpr if inline variables class template deduction and deduction guide All the C++17 type traits from the header std::optional from the header std::variant from the header","title":"Prerequisites and installation"},{"location":"#basic-usage","text":"Here is a bad code, see below. If this program fail to assert, you don't know the reason for the error. bool func ( int a ) { if ( first check ) return false ; if ( second check ) return false ; if ( third check ) return false ; // function body... return true ; } // ... assert ( func ( 42 )); Here is a code using Result. Even if this program fail to assert, you can get the reason for the error. auto func ( int a ) -> mitama :: Result < int , std :: string > { if ( first check ) return mitama :: Err ( \"first check failed\" ); // early return if ( second check ) return mitama :: Err ( \"second check failed\" ); // early return if ( third check ) return mitama :: Err ( \"third check failed\" ); // early return // function body... return mitama :: Ok ( 42 ); } // ... int value func ( 42 ). unwrap (); // even if fail to unwrap, // raise runtime_panic // and you get reason for the error.","title":"Basic Usage"},{"location":"Result101/","text":"mitama::Result 101 \u6b63\u5e38\u5024\u3068\u7570\u5e38\u5024\u306e\u3069\u3061\u3089\u304b\u306e\u72b6\u614b\u3092\u53d6\u308a\u3046\u308b\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u5c02\u7528\u306e\u76f4\u548c\u578b. Motivation C++\u306e\u6301\u3064\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u306e\u6a5f\u80fd\u306b\u306f\u3044\u304f\u3064\u304b\u306e\u554f\u984c\u304c\u3042\u308b. \u624b\u8efd\u306b\u6b63\u5e38\u5024\u3068\u7570\u5e38\u5024\u3092\u4e21\u65b9\u6271\u3048\u308b\u578b\u304c\u5fc5\u8981\u3067\u3042\u308b. \u554f\u984c\u70b9\u3092\u78ba\u8a8d\u3059\u308b\u305f\u3081\u3001\u5404\u8a00\u8a9e\u306e\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u306e\u5178\u578b\u7684\u306a\u30d1\u30bf\u30fc\u30f3\u3092\u898b\u3066\u307f\u308b. \u8a00\u8a9e\u3054\u3068\u306e\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u3068\u6700\u8fd1\u306e\u52d5\u5411 \u8a00\u8a9e\u3054\u3068\u306e\u3088\u304f\u898b\u3089\u308c\u308b\u30a8\u30e9\u30fc\u306e\u6271\u3044\u304b\u305f\u3002 \u4e3b\u306b\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u306a\u3069\u306e\u30a8\u30e9\u30fc\u306e\u6271\u3044\u3092\u8abf\u3079\u3066\u3044\u308b\u3002 Lang \u4f8b\u5916 \u591a\u5024\u8fd4\u5374 Null\u8a31\u5bb9\u578b \u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1 C++ Yes Yes Yes No No Java Yes No Yes No No Go No Yes Yes No Partial Rust Partial No Yes Yes Yes Haskell Yes No Yes Yes Yes Scala Yes Yes Yes Yes Yes \u6700\u8fd1\u306e\u8a00\u8a9e\u306b\u306a\u308b\u3068\u3001\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u3068\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u306b\u3088\u308b\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u304c\u3067\u304d\u308b\u3082\u306e\u304c\u591a\u3044\u3002 \u4f1d\u7d71\u7684\u306a\u30a2\u30d7\u30ed\u30fc\u30c1 \u4f1d\u7d71\u7684\u306aC\u8a00\u8a9e\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3067\u306f\u30a8\u30e9\u30fc\u5024\u3092\u623b\u308a\u5024\u3068\u3057\u3001 \u8fd4\u308a\u5024\u3092\u5f15\u6570\u3068\u3057\u3066\u66f8\u304d\u63db\u3048\u308b. \uff08C\u8a00\u8a9e\u306b\u306fbool\u304c\u306a\u3044\u306e\u3067int\u578b\u3092\u8fd4\u3059\u3053\u3068\u304c\u591a\u3044\u304c\u3001C++\u306b\u306fbool\u304c\u3042\u308b. \u307e\u305f\u3001C\u8a00\u8a9e\u306b\u53c2\u7167\u306f\u306a\u3044\u304cC++\u306b\u306f\u53c2\u7167\u304c\u3042\u308b.\uff09 bool f ( int & a /* return value */ ){ /// implementation if (...) return false ; // error else return true ; } int a ; if ( ! f ( a )) { // error handling ... } \u3053\u306e\u65b9\u6cd5\u306f\u623b\u308a\u5024\u3092\u53d7\u3051\u53d6\u308b\u305f\u3081\u4e88\u3081\u5909\u6570\u3092\u7528\u610f\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u305a\u3001 \u307e\u305f\u526f\u4f5c\u7528\u306b\u3088\u308a\u5909\u6570\u3092\u66f8\u304d\u63db\u3048\u308b\u305f\u3081\u30b3\u30fc\u30c9\u306e\u898b\u901a\u3057\u304c\u60aa\u304f\u306a\u308b. \u4f8b\u5916\u3068\u3044\u3046\u30a2\u30d7\u30ed\u30fc\u30c1 C++\u306b\u306f\u4f8b\u5916\u3068\u3044\u3046\u6a5f\u80fd\u304c\u3042\u308b. int f (){ /// implementation if (...) throw std :: runtime_error ( \"error\" ); else return 42 ; } try { int v = f (); } catch ( std :: runtime_error const & e ) { // error handling ... } \u4f8b\u5916\u306e\u554f\u984c\u306f\u3001\u4f8b\u5916\u30c6\u30fc\u30d6\u30eb\u306b\u3088\u308a\u30e9\u30f3\u30bf\u30a4\u30e0\u306b\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u304c\u5927\u304d\u3044\u3053\u3068\u304c\u3042\u308b. \u4f8b\u5916\u306f\u30ad\u30e3\u30c3\u30c1\u306b\u5931\u6557\u3059\u308b\u3068terminate()\u3092\u547c\u3073\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u7d42\u4e86\u3055\u305b\u308b. \u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u9032\u884c\u304c\u4e0d\u53ef\u80fd\u306a\u30a8\u30e9\u30fc\u3092\u6271\u3046\u306b\u306f\u6700\u9069\u3067\u3042\u308b\u304c\u3001 \u3061\u3087\u3063\u3068\u3057\u305f\u8a08\u7b97\u306e\u5931\u6557\u3084\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u306e\u5931\u6557\u306a\u3069\u306e \u5dfb\u304d\u623b\u3057\u304c\u53ef\u80fd\u306a\u30a8\u30e9\u30fc\u3092\u6271\u3046\u306b\u306f\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u304c\u5c11\u3005\u6c17\u306b\u306a\u308b. \u3053\u308c\u3068\u540c\u69d8\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u306f\u591a\u304f\u306e\u8a00\u8a9e\u304c\u63a1\u7528\u3057\u3066\u3044\u308b\u3002 \u7279\u306b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u8a00\u8a9e\u3002 C++\u3001Java\u3001C#\u3001Python\u306a\u3069\u306f\u4f8b\u5916\u3092\u4e3b\u306a\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u6a5f\u80fd\u3068\u3057\u3066\u5099\u3048\u3066\u3044\u308b\u3002 \u591a\u5024\u8fd4\u5374\u3068\u3044\u3046\u30a2\u30d7\u30ed\u30fc\u30c1 Go\u306f\u4f8b\u5916\u3092\u5099\u3048\u3066\u3044\u306a\u3044\u3002 Go\u306f\u95a2\u6570\u304c\u8907\u6570\u306e\u623b\u308a\u5024\u3092\u8fd4\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u305f\u3081\u30012\u3064\u3081\u306e\u623b\u308a\u5024\u3067error\u578b\u3092\u8fd4\u3059\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u308b. func f ( first string , family string ) ( string , error ) { if ( first == \"\" ) || ( family == \"\" ) { return nil , errors . New ( \"error: empty name\" ) } return strings . ToUpper ( first ) + strings . toLower ( family )), nil } if name , err := f ( \"\" , \"Joi\" ); err { /// error handling } C++17\u3067\u306f\u540c\u3058\u3088\u3046\u306a\u3053\u3068\u304c\u3067\u304d\u308b. auto f ( int a ){ using std :: literals :: string_literals ; if ( a < 0 ) return std :: tuple { 0 , false }; else return std :: tuple { 1 , true }; } if ( auto [ value , err ] = f (); ! err ) { // error handling ... } else { // ok // ... } tuple like\u306a\u6a5f\u80fd\u3092\u6709\u3057\u3066\u3044\u308b\u8a00\u8a9e\u3067\u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3092\u63a1\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002 \u3057\u304b\u3057\u3001\u3053\u306e\u65b9\u6cd5\u306f\u30a8\u30e9\u30fc\u5024\u3092\u7121\u8996\u3057\u3066\u6368\u3066\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u306e\u3067\u3001\u3053\u308c\u4e00\u672c\u3067\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u3092\u884c\u3046\u306e\u306f\u3044\u3044\u30a2\u30a4\u30c7\u30a2\u3068\u306f\u8a00\u3048\u306a\u3044\u3060\u308d\u3046. \u5b9f\u969b\u3001Go2\u306e\u30c9\u30e9\u30d5\u30c8\u3067\u4fee\u6b63\u6848\u304c\u51fa\u3066\u3044\u308b. C++\u306e\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u3082\u4f8b\u5916\u3092\u4f7f\u3046\u307e\u3067\u3082\u306a\u3044\u3068\u3044\u3046\u5834\u5408\u306b\u304a\u3044\u3066\u3001\u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3092\u7528\u3044\u308b\u3002 \u4f8b\u3048\u3070\u3001map\u306eemplace\u306f\u633f\u5165\u4f4d\u7f6e\u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u3068\u633f\u5165\u306b\u6210\u529f\u3057\u305f\u304b\u3092\u8868\u3059bool\u5024\u306epair\u3092\u8fd4\u308a\u5024\u3068\u3057\u3066\u3044\u308b\u3002 \u7121\u52b9\u5024\u3092\u8868\u3059\u7279\u5225\u306a\u578b\uff08Null\u8a31\u5bb9\u578b\uff09\u3068\u3044\u3046\u30a2\u30d7\u30ed\u30fc\u30c1 Null\u3068\u3044\u3046\u72b6\u614b\u3092\u8a31\u5bb9\u3057\u3001\u30a8\u30e9\u30fc\u3092\u8868\u3059\u3068\u3044\u3046\u65b9\u6cd5\u3002 \u975eNull\u8a31\u5bb9\u578b\u3068Null\u8a31\u5bb9\u578b\u3092\u533a\u5225\u3067\u304d\u308b\u6a5f\u80fd\u3084\u3001Optional\u306b\u3088\u308b\u3002 C#\u3001Kotlin\u3001Swift\u306a\u3069\u306fNull\u8a31\u5bb9\u578b\u3092\u4f7f\u3046\u3002 C++\u3001Java\u3001Rust\u306a\u3069\u306fOptional\u3092\u4f7f\u3046\u3002 Haskell\u306fMaybe\u3092\u4f7f\u3046\u3002 Haskell\u306f\u3053\u306e\u5f8c\u306e\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u3067\u89e3\u8aac\u3059\u308b\u3002 \u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u306e\u826f\u3044\u3068\u3053\u308d\u306f\u3001\u6210\u529f\u3068\u5931\u6557\u3092\u4e00\u3064\u306e\u5909\u6570\uff08\u578b\uff09\u3067\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3068\u3044\u3046\u3053\u3068\u3060\u3002 \u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u306e\u6b20\u70b9\u306f\u30a8\u30e9\u30fc\u3068\u3044\u3046\u3053\u3068\u3057\u304b\u308f\u304b\u3089\u305a\u3001\u30a8\u30e9\u30fc\u539f\u56e0\u304c\u5168\u304f\u308f\u304b\u3089\u305a\u30c7\u30d0\u30c3\u30b0\u304c\u56f0\u96e3\u3068\u3044\u3046\u3053\u3068\u3067\u3042\u308b\u3002 \u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u3068\u3044\u3046\u30a2\u30d7\u30ed\u30fc\u30c1 C++\u306ebool\u578b\u3067\u6210\u529f\u3068\u5931\u6557\u3092\u8868\u3057\u305f\u3068\u304d\u3001int\u578b\u304cbool\u306b\u5909\u63db\u3067\u304d\u3066\u3057\u307e\u3046\u3002 \u30a8\u30e9\u30fc\u3068\u95a2\u4fc2\u306a\u3044int\u5024\u3092\u8fd4\u5374\u3057\u3066\u3082bool\u306b\u5909\u63db\u3055\u308c\u3066\u30b3\u30f3\u30d1\u30a4\u30eb\u304c\u901a\u3063\u3066\u3057\u307e\u3044\u3001\u304a\u304b\u3057\u306a\u52d5\u304d\u3092\u3059\u308b\u3068\u3044\u3046\u4e8b\u6545\u3092\u8d77\u3053\u3059\u53ef\u80fd\u6027\u304c\u3042\u308b\u3002 Haskell\u3067\u306f Bool \u306f \u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b \u3067\u3042\u308b\u3002 data Bool = True | False Bool\u306fTrue\u304bFalse\u4ee5\u5916\u306e\u5024\u3092\u53d6\u308a\u5f97\u306a\u3044\u3002 \u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u306f\u4e8b\u6545\u3092\u578b\u30ec\u30d9\u30eb\u3067\u9632\u3050\u3002 Haskell\u306b\u304a\u3051\u308b\u7121\u52b9\u5024\u3092\u8868\u3059Maybe\u3082\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u3067\u3042\u308b\u3002 data Maybe a = Nothing | Just a \u591a\u304f\u306e\u8a00\u8a9e\u3067enum\uff08\u5217\u6319\u578b\uff09\u3068\u547c\u3070\u308c\u308b\u6a5f\u80fd\u3067\u306a\u3093\u3060\u304b\u3093\u3060\u9811\u5f35\u308c\u3070\u5b9f\u73fe\u53ef\u80fd\u3002 \u3068\u3053\u308d\u3067\u3001Rust\u3067\u306fenum\u306f\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u3067\u3042\u308b. enum V { A , B , } \u306e\u3088\u3046\u306b\u3059\u308b\u3068V\u306f\u3001A\u304bB\u306e\u578b\u3092\u53d6\u308a\u3046\u308b\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u578b\u306b\u306a\u308b. Result\u306e\u5b9a\u7fa9\u3092\u898b\u3066\u307f\u3088\u3046. enum Result < T , E > { Ok ( T ), Err ( E ), } \u3053\u308c\u306f\u30b8\u30a7\u30cd\u30ea\u30af\u30b9\u3067\u3042\u308a\u3001 Ok(T) , Err(E) \u306f\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3067\u3042\u308b. Result<T, E> \u306f Ok(T) \u304b Err(E) \u306e\u3069\u3061\u3089\u304b\u306e\u72b6\u614b\u3092\u6301\u3064. Result\u3092\u53d7\u3051\u53d6\u308a\u5024\u3092\u53d6\u308a\u51fa\u3059\u306b\u306f unwrap \u3092\u547c\u3073\u51fa\u3059\u5fc5\u8981\u304c\u3042\u308b. Err\u306e\u72b6\u614b\u306eResult\u3067unwrap\u3092\u547c\u3073\u51fa\u3059\u3068panic\uff08\u4f8b\u5916\u306e\u3088\u3046\u306a\u3082\u306e\uff09\u306b\u306a\u308b\u3002 \u7570\u5e38\u5024\u3068\u6b63\u5e38\u5024\u3092\u7d71\u5408\u7684\u306b\u6271\u3048\u3066\u3044\u308b. \u5024\u3092\u53d6\u308a\u51fa\u3057\u3066\u4f7f\u3046\u3057\u304b\u306a\u3044\u305f\u3081\u3001\u30a8\u30e9\u30fc\u72b6\u614b\u3092\u7121\u8996\u3057\u3066\u30a8\u30e9\u30fc\u5024\u3092\u6368\u3066\u308b\u3053\u3068\u306f\u3067\u304d\u306a\u3044. \u5b9f\u884c\u6642\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u306f\u5c11\u306a\u304f\u3001\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u5dfb\u304d\u623b\u3057\u3084\u30a8\u30e9\u30fc\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u904b\u642c\u306b\u6c17\u8efd\u306b\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u308b. map , map_err , and_then , or_else \u306a\u3069\u306e\u4fbf\u5229\u306a\u95a2\u6570\u7fa4\u3082\u3042\u308b. \u6b63\u5e38\u5024\u3092\u6301\u3064\u72b6\u614b\u3068\u7570\u5e38\u5024\u3092\u6301\u3064\u72b6\u614b\u3092\u30b7\u30fc\u30e0\u30ec\u30b9\u306b\u6271\u3048\u308b\u3001\u304b\u3064\u30a8\u30e9\u30fc\u30e1\u30c3\u30bb\u30fc\u30b8\u3082\u904b\u642c\u3067\u304d\u308b\u3002 \u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3092C++\u3067\u3082\u63a1\u7528\u3057\u305f\u3044. Result for C++ \u5b9f\u7528\u306b\u8010\u3048\u308b\u3088\u3046\u306b2\u3064\u306e\u578b\u306e\u76f4\u548c\u578b\u3068\u3057\u3066\u306e\u6a5f\u80fd\u3092\u5b9f\u88c5\u3057\u305f. std::variant \u3067\u306f Result<int, int> \u306e\u3088\u3046\u306a\u540c\u3058\u578b\u306b\u6b63\u5e38\u30fb\u7570\u5e38\u3068\u3044\u30462\u3064\u306e\u610f\u5473\u3092\u3082\u305f\u305b\u308b\u305f\u3081\u306b\u306f\u578b\u3092` std :: variant < Ok < int > , Err < int >> \u306e\u3088\u3046\u306b\u30e9\u30c3\u30d7\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b. Result\u306e\u5185\u90e8\u5b9f\u88c5\u306f\u3053\u306e\u3088\u3046\u306b\u306a\u3063\u3066\u304a\u308a\u3001\u30d8\u30eb\u30d1\u30fc\u578b\u3068\u3057\u3066 Ok<T> \u3068 Err<E> \u3068\u3044\u3046\u30af\u30e9\u30b9\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u7528\u3044\u308b. Basic Usage \u5358\u7d14\u306aif\u6587\u3092\u7f6e\u304d\u63db\u3048\u308b\u3088\u3046\u306a\u4f7f\u3044\u65b9\u304c\u8003\u3048\u3089\u308c\u308b. Result\u306e\u826f\u3044\u3068\u3053\u308d\u306f\u3001 \u3069\u306e\u6642\u70b9\u3067\u30a8\u30e9\u30fc\u306b\u306a\u3063\u305f\u304b\u3092\u30e1\u30c3\u30bb\u30fc\u30b8\u542b\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3053\u3068\u3067\u3042\u308b. \u3053\u308c\u306b\u3088\u308a\u3001\u30d0\u30b0\u306e\u8ffd\u8de1\u304c\u5bb9\u6613\u306b\u306a\u308b\u3057\u3001\u30a8\u30e9\u30fc\u30e1\u30c3\u30bb\u30fc\u30b8\u3082\u89aa\u5207\u306b\u306a\u308b. auto even = []( uint32_t u ) -> Result < uint32_t , std :: string > { if ( u % 2 == 0 ) return Ok ( u ); // implicit convert to Result<uint32_t, std::string> else return Err ( \"odd\" s ); // implicit convert to Result<uint32_t, std::string> }; auto func = []( auto u ) -> Result < uint32_t , std :: string > { if ( u % 3 == 0 ) return Ok ( 1u ); // implicit convert to Result<uint32_t, std::string> else return Err ( \"error\" s ); // implicit convert to Result<uint32_t, std::string> }; auto res = even ( 2 ) . and_then ( func ) // if even(2) is ok, and then call func ( returns Err ); if ( res . is_err ()) { std :: string mesasge = res . unwrap_err (); // get error message } uint32_t value = res . unwrap (); // get result value // ...","title":"Result 101"},{"location":"Result101/#mitamaresult-101","text":"\u6b63\u5e38\u5024\u3068\u7570\u5e38\u5024\u306e\u3069\u3061\u3089\u304b\u306e\u72b6\u614b\u3092\u53d6\u308a\u3046\u308b\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u5c02\u7528\u306e\u76f4\u548c\u578b.","title":"mitama::Result 101"},{"location":"Result101/#motivation","text":"C++\u306e\u6301\u3064\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u306e\u6a5f\u80fd\u306b\u306f\u3044\u304f\u3064\u304b\u306e\u554f\u984c\u304c\u3042\u308b. \u624b\u8efd\u306b\u6b63\u5e38\u5024\u3068\u7570\u5e38\u5024\u3092\u4e21\u65b9\u6271\u3048\u308b\u578b\u304c\u5fc5\u8981\u3067\u3042\u308b. \u554f\u984c\u70b9\u3092\u78ba\u8a8d\u3059\u308b\u305f\u3081\u3001\u5404\u8a00\u8a9e\u306e\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u306e\u5178\u578b\u7684\u306a\u30d1\u30bf\u30fc\u30f3\u3092\u898b\u3066\u307f\u308b.","title":"Motivation"},{"location":"Result101/#_1","text":"\u8a00\u8a9e\u3054\u3068\u306e\u3088\u304f\u898b\u3089\u308c\u308b\u30a8\u30e9\u30fc\u306e\u6271\u3044\u304b\u305f\u3002 \u4e3b\u306b\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u306a\u3069\u306e\u30a8\u30e9\u30fc\u306e\u6271\u3044\u3092\u8abf\u3079\u3066\u3044\u308b\u3002 Lang \u4f8b\u5916 \u591a\u5024\u8fd4\u5374 Null\u8a31\u5bb9\u578b \u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1 C++ Yes Yes Yes No No Java Yes No Yes No No Go No Yes Yes No Partial Rust Partial No Yes Yes Yes Haskell Yes No Yes Yes Yes Scala Yes Yes Yes Yes Yes \u6700\u8fd1\u306e\u8a00\u8a9e\u306b\u306a\u308b\u3068\u3001\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u3068\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u306b\u3088\u308b\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u304c\u3067\u304d\u308b\u3082\u306e\u304c\u591a\u3044\u3002","title":"\u8a00\u8a9e\u3054\u3068\u306e\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u3068\u6700\u8fd1\u306e\u52d5\u5411"},{"location":"Result101/#_2","text":"\u4f1d\u7d71\u7684\u306aC\u8a00\u8a9e\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3067\u306f\u30a8\u30e9\u30fc\u5024\u3092\u623b\u308a\u5024\u3068\u3057\u3001 \u8fd4\u308a\u5024\u3092\u5f15\u6570\u3068\u3057\u3066\u66f8\u304d\u63db\u3048\u308b. \uff08C\u8a00\u8a9e\u306b\u306fbool\u304c\u306a\u3044\u306e\u3067int\u578b\u3092\u8fd4\u3059\u3053\u3068\u304c\u591a\u3044\u304c\u3001C++\u306b\u306fbool\u304c\u3042\u308b. \u307e\u305f\u3001C\u8a00\u8a9e\u306b\u53c2\u7167\u306f\u306a\u3044\u304cC++\u306b\u306f\u53c2\u7167\u304c\u3042\u308b.\uff09 bool f ( int & a /* return value */ ){ /// implementation if (...) return false ; // error else return true ; } int a ; if ( ! f ( a )) { // error handling ... } \u3053\u306e\u65b9\u6cd5\u306f\u623b\u308a\u5024\u3092\u53d7\u3051\u53d6\u308b\u305f\u3081\u4e88\u3081\u5909\u6570\u3092\u7528\u610f\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u305a\u3001 \u307e\u305f\u526f\u4f5c\u7528\u306b\u3088\u308a\u5909\u6570\u3092\u66f8\u304d\u63db\u3048\u308b\u305f\u3081\u30b3\u30fc\u30c9\u306e\u898b\u901a\u3057\u304c\u60aa\u304f\u306a\u308b.","title":"\u4f1d\u7d71\u7684\u306a\u30a2\u30d7\u30ed\u30fc\u30c1"},{"location":"Result101/#_3","text":"C++\u306b\u306f\u4f8b\u5916\u3068\u3044\u3046\u6a5f\u80fd\u304c\u3042\u308b. int f (){ /// implementation if (...) throw std :: runtime_error ( \"error\" ); else return 42 ; } try { int v = f (); } catch ( std :: runtime_error const & e ) { // error handling ... } \u4f8b\u5916\u306e\u554f\u984c\u306f\u3001\u4f8b\u5916\u30c6\u30fc\u30d6\u30eb\u306b\u3088\u308a\u30e9\u30f3\u30bf\u30a4\u30e0\u306b\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u304c\u5927\u304d\u3044\u3053\u3068\u304c\u3042\u308b. \u4f8b\u5916\u306f\u30ad\u30e3\u30c3\u30c1\u306b\u5931\u6557\u3059\u308b\u3068terminate()\u3092\u547c\u3073\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u7d42\u4e86\u3055\u305b\u308b. \u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u9032\u884c\u304c\u4e0d\u53ef\u80fd\u306a\u30a8\u30e9\u30fc\u3092\u6271\u3046\u306b\u306f\u6700\u9069\u3067\u3042\u308b\u304c\u3001 \u3061\u3087\u3063\u3068\u3057\u305f\u8a08\u7b97\u306e\u5931\u6557\u3084\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u306e\u5931\u6557\u306a\u3069\u306e \u5dfb\u304d\u623b\u3057\u304c\u53ef\u80fd\u306a\u30a8\u30e9\u30fc\u3092\u6271\u3046\u306b\u306f\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u304c\u5c11\u3005\u6c17\u306b\u306a\u308b. \u3053\u308c\u3068\u540c\u69d8\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u306f\u591a\u304f\u306e\u8a00\u8a9e\u304c\u63a1\u7528\u3057\u3066\u3044\u308b\u3002 \u7279\u306b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u8a00\u8a9e\u3002 C++\u3001Java\u3001C#\u3001Python\u306a\u3069\u306f\u4f8b\u5916\u3092\u4e3b\u306a\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u6a5f\u80fd\u3068\u3057\u3066\u5099\u3048\u3066\u3044\u308b\u3002","title":"\u4f8b\u5916\u3068\u3044\u3046\u30a2\u30d7\u30ed\u30fc\u30c1"},{"location":"Result101/#_4","text":"Go\u306f\u4f8b\u5916\u3092\u5099\u3048\u3066\u3044\u306a\u3044\u3002 Go\u306f\u95a2\u6570\u304c\u8907\u6570\u306e\u623b\u308a\u5024\u3092\u8fd4\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u305f\u3081\u30012\u3064\u3081\u306e\u623b\u308a\u5024\u3067error\u578b\u3092\u8fd4\u3059\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u308b. func f ( first string , family string ) ( string , error ) { if ( first == \"\" ) || ( family == \"\" ) { return nil , errors . New ( \"error: empty name\" ) } return strings . ToUpper ( first ) + strings . toLower ( family )), nil } if name , err := f ( \"\" , \"Joi\" ); err { /// error handling } C++17\u3067\u306f\u540c\u3058\u3088\u3046\u306a\u3053\u3068\u304c\u3067\u304d\u308b. auto f ( int a ){ using std :: literals :: string_literals ; if ( a < 0 ) return std :: tuple { 0 , false }; else return std :: tuple { 1 , true }; } if ( auto [ value , err ] = f (); ! err ) { // error handling ... } else { // ok // ... } tuple like\u306a\u6a5f\u80fd\u3092\u6709\u3057\u3066\u3044\u308b\u8a00\u8a9e\u3067\u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3092\u63a1\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002 \u3057\u304b\u3057\u3001\u3053\u306e\u65b9\u6cd5\u306f\u30a8\u30e9\u30fc\u5024\u3092\u7121\u8996\u3057\u3066\u6368\u3066\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u306e\u3067\u3001\u3053\u308c\u4e00\u672c\u3067\u30a8\u30e9\u30fc\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u3092\u884c\u3046\u306e\u306f\u3044\u3044\u30a2\u30a4\u30c7\u30a2\u3068\u306f\u8a00\u3048\u306a\u3044\u3060\u308d\u3046. \u5b9f\u969b\u3001Go2\u306e\u30c9\u30e9\u30d5\u30c8\u3067\u4fee\u6b63\u6848\u304c\u51fa\u3066\u3044\u308b. C++\u306e\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u3082\u4f8b\u5916\u3092\u4f7f\u3046\u307e\u3067\u3082\u306a\u3044\u3068\u3044\u3046\u5834\u5408\u306b\u304a\u3044\u3066\u3001\u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3092\u7528\u3044\u308b\u3002 \u4f8b\u3048\u3070\u3001map\u306eemplace\u306f\u633f\u5165\u4f4d\u7f6e\u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u3068\u633f\u5165\u306b\u6210\u529f\u3057\u305f\u304b\u3092\u8868\u3059bool\u5024\u306epair\u3092\u8fd4\u308a\u5024\u3068\u3057\u3066\u3044\u308b\u3002","title":"\u591a\u5024\u8fd4\u5374\u3068\u3044\u3046\u30a2\u30d7\u30ed\u30fc\u30c1"},{"location":"Result101/#null","text":"Null\u3068\u3044\u3046\u72b6\u614b\u3092\u8a31\u5bb9\u3057\u3001\u30a8\u30e9\u30fc\u3092\u8868\u3059\u3068\u3044\u3046\u65b9\u6cd5\u3002 \u975eNull\u8a31\u5bb9\u578b\u3068Null\u8a31\u5bb9\u578b\u3092\u533a\u5225\u3067\u304d\u308b\u6a5f\u80fd\u3084\u3001Optional\u306b\u3088\u308b\u3002 C#\u3001Kotlin\u3001Swift\u306a\u3069\u306fNull\u8a31\u5bb9\u578b\u3092\u4f7f\u3046\u3002 C++\u3001Java\u3001Rust\u306a\u3069\u306fOptional\u3092\u4f7f\u3046\u3002 Haskell\u306fMaybe\u3092\u4f7f\u3046\u3002 Haskell\u306f\u3053\u306e\u5f8c\u306e\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u3067\u89e3\u8aac\u3059\u308b\u3002 \u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u306e\u826f\u3044\u3068\u3053\u308d\u306f\u3001\u6210\u529f\u3068\u5931\u6557\u3092\u4e00\u3064\u306e\u5909\u6570\uff08\u578b\uff09\u3067\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3068\u3044\u3046\u3053\u3068\u3060\u3002 \u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u306e\u6b20\u70b9\u306f\u30a8\u30e9\u30fc\u3068\u3044\u3046\u3053\u3068\u3057\u304b\u308f\u304b\u3089\u305a\u3001\u30a8\u30e9\u30fc\u539f\u56e0\u304c\u5168\u304f\u308f\u304b\u3089\u305a\u30c7\u30d0\u30c3\u30b0\u304c\u56f0\u96e3\u3068\u3044\u3046\u3053\u3068\u3067\u3042\u308b\u3002","title":"\u7121\u52b9\u5024\u3092\u8868\u3059\u7279\u5225\u306a\u578b\uff08Null\u8a31\u5bb9\u578b\uff09\u3068\u3044\u3046\u30a2\u30d7\u30ed\u30fc\u30c1"},{"location":"Result101/#_5","text":"C++\u306ebool\u578b\u3067\u6210\u529f\u3068\u5931\u6557\u3092\u8868\u3057\u305f\u3068\u304d\u3001int\u578b\u304cbool\u306b\u5909\u63db\u3067\u304d\u3066\u3057\u307e\u3046\u3002 \u30a8\u30e9\u30fc\u3068\u95a2\u4fc2\u306a\u3044int\u5024\u3092\u8fd4\u5374\u3057\u3066\u3082bool\u306b\u5909\u63db\u3055\u308c\u3066\u30b3\u30f3\u30d1\u30a4\u30eb\u304c\u901a\u3063\u3066\u3057\u307e\u3044\u3001\u304a\u304b\u3057\u306a\u52d5\u304d\u3092\u3059\u308b\u3068\u3044\u3046\u4e8b\u6545\u3092\u8d77\u3053\u3059\u53ef\u80fd\u6027\u304c\u3042\u308b\u3002 Haskell\u3067\u306f Bool \u306f \u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b \u3067\u3042\u308b\u3002 data Bool = True | False Bool\u306fTrue\u304bFalse\u4ee5\u5916\u306e\u5024\u3092\u53d6\u308a\u5f97\u306a\u3044\u3002 \u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u306f\u4e8b\u6545\u3092\u578b\u30ec\u30d9\u30eb\u3067\u9632\u3050\u3002 Haskell\u306b\u304a\u3051\u308b\u7121\u52b9\u5024\u3092\u8868\u3059Maybe\u3082\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u3067\u3042\u308b\u3002 data Maybe a = Nothing | Just a \u591a\u304f\u306e\u8a00\u8a9e\u3067enum\uff08\u5217\u6319\u578b\uff09\u3068\u547c\u3070\u308c\u308b\u6a5f\u80fd\u3067\u306a\u3093\u3060\u304b\u3093\u3060\u9811\u5f35\u308c\u3070\u5b9f\u73fe\u53ef\u80fd\u3002 \u3068\u3053\u308d\u3067\u3001Rust\u3067\u306fenum\u306f\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u3067\u3042\u308b. enum V { A , B , } \u306e\u3088\u3046\u306b\u3059\u308b\u3068V\u306f\u3001A\u304bB\u306e\u578b\u3092\u53d6\u308a\u3046\u308b\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u578b\u306b\u306a\u308b. Result\u306e\u5b9a\u7fa9\u3092\u898b\u3066\u307f\u3088\u3046. enum Result < T , E > { Ok ( T ), Err ( E ), } \u3053\u308c\u306f\u30b8\u30a7\u30cd\u30ea\u30af\u30b9\u3067\u3042\u308a\u3001 Ok(T) , Err(E) \u306f\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3067\u3042\u308b. Result<T, E> \u306f Ok(T) \u304b Err(E) \u306e\u3069\u3061\u3089\u304b\u306e\u72b6\u614b\u3092\u6301\u3064. Result\u3092\u53d7\u3051\u53d6\u308a\u5024\u3092\u53d6\u308a\u51fa\u3059\u306b\u306f unwrap \u3092\u547c\u3073\u51fa\u3059\u5fc5\u8981\u304c\u3042\u308b. Err\u306e\u72b6\u614b\u306eResult\u3067unwrap\u3092\u547c\u3073\u51fa\u3059\u3068panic\uff08\u4f8b\u5916\u306e\u3088\u3046\u306a\u3082\u306e\uff09\u306b\u306a\u308b\u3002 \u7570\u5e38\u5024\u3068\u6b63\u5e38\u5024\u3092\u7d71\u5408\u7684\u306b\u6271\u3048\u3066\u3044\u308b. \u5024\u3092\u53d6\u308a\u51fa\u3057\u3066\u4f7f\u3046\u3057\u304b\u306a\u3044\u305f\u3081\u3001\u30a8\u30e9\u30fc\u72b6\u614b\u3092\u7121\u8996\u3057\u3066\u30a8\u30e9\u30fc\u5024\u3092\u6368\u3066\u308b\u3053\u3068\u306f\u3067\u304d\u306a\u3044. \u5b9f\u884c\u6642\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u306f\u5c11\u306a\u304f\u3001\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u5dfb\u304d\u623b\u3057\u3084\u30a8\u30e9\u30fc\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u904b\u642c\u306b\u6c17\u8efd\u306b\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u308b. map , map_err , and_then , or_else \u306a\u3069\u306e\u4fbf\u5229\u306a\u95a2\u6570\u7fa4\u3082\u3042\u308b. \u6b63\u5e38\u5024\u3092\u6301\u3064\u72b6\u614b\u3068\u7570\u5e38\u5024\u3092\u6301\u3064\u72b6\u614b\u3092\u30b7\u30fc\u30e0\u30ec\u30b9\u306b\u6271\u3048\u308b\u3001\u304b\u3064\u30a8\u30e9\u30fc\u30e1\u30c3\u30bb\u30fc\u30b8\u3082\u904b\u642c\u3067\u304d\u308b\u3002 \u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3092C++\u3067\u3082\u63a1\u7528\u3057\u305f\u3044.","title":"\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u3068\u3044\u3046\u30a2\u30d7\u30ed\u30fc\u30c1"},{"location":"Result101/#result-for-c","text":"\u5b9f\u7528\u306b\u8010\u3048\u308b\u3088\u3046\u306b2\u3064\u306e\u578b\u306e\u76f4\u548c\u578b\u3068\u3057\u3066\u306e\u6a5f\u80fd\u3092\u5b9f\u88c5\u3057\u305f. std::variant \u3067\u306f Result<int, int> \u306e\u3088\u3046\u306a\u540c\u3058\u578b\u306b\u6b63\u5e38\u30fb\u7570\u5e38\u3068\u3044\u30462\u3064\u306e\u610f\u5473\u3092\u3082\u305f\u305b\u308b\u305f\u3081\u306b\u306f\u578b\u3092` std :: variant < Ok < int > , Err < int >> \u306e\u3088\u3046\u306b\u30e9\u30c3\u30d7\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b. Result\u306e\u5185\u90e8\u5b9f\u88c5\u306f\u3053\u306e\u3088\u3046\u306b\u306a\u3063\u3066\u304a\u308a\u3001\u30d8\u30eb\u30d1\u30fc\u578b\u3068\u3057\u3066 Ok<T> \u3068 Err<E> \u3068\u3044\u3046\u30af\u30e9\u30b9\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u7528\u3044\u308b.","title":"Result for C++"},{"location":"Result101/#basic-usage","text":"\u5358\u7d14\u306aif\u6587\u3092\u7f6e\u304d\u63db\u3048\u308b\u3088\u3046\u306a\u4f7f\u3044\u65b9\u304c\u8003\u3048\u3089\u308c\u308b. Result\u306e\u826f\u3044\u3068\u3053\u308d\u306f\u3001 \u3069\u306e\u6642\u70b9\u3067\u30a8\u30e9\u30fc\u306b\u306a\u3063\u305f\u304b\u3092\u30e1\u30c3\u30bb\u30fc\u30b8\u542b\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3053\u3068\u3067\u3042\u308b. \u3053\u308c\u306b\u3088\u308a\u3001\u30d0\u30b0\u306e\u8ffd\u8de1\u304c\u5bb9\u6613\u306b\u306a\u308b\u3057\u3001\u30a8\u30e9\u30fc\u30e1\u30c3\u30bb\u30fc\u30b8\u3082\u89aa\u5207\u306b\u306a\u308b. auto even = []( uint32_t u ) -> Result < uint32_t , std :: string > { if ( u % 2 == 0 ) return Ok ( u ); // implicit convert to Result<uint32_t, std::string> else return Err ( \"odd\" s ); // implicit convert to Result<uint32_t, std::string> }; auto func = []( auto u ) -> Result < uint32_t , std :: string > { if ( u % 3 == 0 ) return Ok ( 1u ); // implicit convert to Result<uint32_t, std::string> else return Err ( \"error\" s ); // implicit convert to Result<uint32_t, std::string> }; auto res = even ( 2 ) . and_then ( func ) // if even(2) is ok, and then call func ( returns Err ); if ( res . is_err ()) { std :: string mesasge = res . unwrap_err (); // get error message } uint32_t value = res . unwrap (); // get result value // ...","title":"Basic Usage"},{"location":"Result101/Err/","text":"class Err Err is a helper class to construct Result . Result has constructor Example #include <string> []( auto value ) -> Result < int , std :: string > { using namespace std :: literals ; if ( value ) return Ok ( value ); else return Err ( \"error\" s ); };","title":"Err"},{"location":"Result101/Err/#class-err","text":"Err is a helper class to construct Result . Result has constructor Example #include <string> []( auto value ) -> Result < int , std :: string > { using namespace std :: literals ; if ( value ) return Ok ( value ); else return Err ( \"error\" s ); };","title":"class Err"},{"location":"Result101/Err/constructors/","text":"Err() [1/9] template < class T > mitama :: Err < T >:: Err () = delete default constructor is explicitly deleted. Err() [2/9] template <> mitama :: Err < std :: monostate >:: Err () = default default constructor is explicitly defaulted. Err() [3/9] template < class T > template < class U > constexpr mitama :: Err < T >:: Err ( U && u ) non-explicit generic constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<U>(u) . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Err() [4/9] template < class T > template < class U > explicit mitama :: Err < T >:: Err ( U && u ) explicit generic constructor template Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<U>(u) . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Err() [5/9] template < class T > template < typename U > constexpr mitama :: Err < T >:: Err ( const Err < U > & t ) non-explicit constructor for Err Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Err() [6/9] template < class T > template < typename U > explicit mitama :: Err < T >:: Err ( const Err < U > & t ) explicit generic copy constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Err() [7/9] template < class T > template < typename U > constexpr mitama :: Err < T >:: Err ( Err < U > && t ) non-explicit move constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Err() [8/9] template < class T > template < typename U > constexpr mitama :: Err < T >:: Err ( Err < U > && t ) explicit move constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Err() [9/9] ```cpp template template constexpr mitama::Err ::Err(std::in_place_t, Args &&... args) in-place constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<Args>(args)... . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"constructors"},{"location":"Result101/Err/constructors/#err-19","text":"template < class T > mitama :: Err < T >:: Err () = delete default constructor is explicitly deleted.","title":"Err() [1/9]"},{"location":"Result101/Err/constructors/#err-29","text":"template <> mitama :: Err < std :: monostate >:: Err () = default default constructor is explicitly defaulted.","title":"Err() [2/9]"},{"location":"Result101/Err/constructors/#err-39","text":"template < class T > template < class U > constexpr mitama :: Err < T >:: Err ( U && u ) non-explicit generic constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<U>(u) . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Err() [3/9]"},{"location":"Result101/Err/constructors/#err-49","text":"template < class T > template < class U > explicit mitama :: Err < T >:: Err ( U && u ) explicit generic constructor template Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<U>(u) . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Err() [4/9]"},{"location":"Result101/Err/constructors/#err-59","text":"template < class T > template < typename U > constexpr mitama :: Err < T >:: Err ( const Err < U > & t ) non-explicit constructor for Err Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Err() [5/9]"},{"location":"Result101/Err/constructors/#err-69","text":"template < class T > template < typename U > explicit mitama :: Err < T >:: Err ( const Err < U > & t ) explicit generic copy constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Err() [6/9]"},{"location":"Result101/Err/constructors/#err-79","text":"template < class T > template < typename U > constexpr mitama :: Err < T >:: Err ( Err < U > && t ) non-explicit move constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Err() [7/9]"},{"location":"Result101/Err/constructors/#err-89","text":"template < class T > template < typename U > constexpr mitama :: Err < T >:: Err ( Err < U > && t ) explicit move constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Err() [8/9]"},{"location":"Result101/Err/constructors/#err-99","text":"```cpp template template constexpr mitama::Err ::Err(std::in_place_t, Args &&... args) in-place constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<Args>(args)... . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Err() [9/9]"},{"location":"Result101/Err/deduction_guides/","text":"Deduction guide template < class T > Err ( T && ) -> Err < std :: decay_t < T >> ;","title":"deduction guides"},{"location":"Result101/Err/deduction_guides/#deduction-guide","text":"template < class T > Err ( T && ) -> Err < std :: decay_t < T >> ;","title":"Deduction guide"},{"location":"Result101/Ok/","text":"class Ok Ok is a helper class to construct Result . Result has constructor Example #include <string> []( auto value ) -> Result < int , std :: string > { using namespace std :: literals ; if ( value ) return Ok ( value ); else return Err ( \"error\" s ); };","title":"Ok"},{"location":"Result101/Ok/#class-ok","text":"Ok is a helper class to construct Result . Result has constructor Example #include <string> []( auto value ) -> Result < int , std :: string > { using namespace std :: literals ; if ( value ) return Ok ( value ); else return Err ( \"error\" s ); };","title":"class Ok"},{"location":"Result101/Ok/constructors/","text":"Ok() [1/9] template < class T > mitama :: Ok < T >:: Ok () = delete default constructor is explicitly deleted. Ok() [2/9] template <> mitama :: Ok < std :: monostate >:: Ok () = default default constructor is explicitly defaulted. Ok() [3/9] template < class T > template < class U > constexpr mitama :: Ok < T >:: Ok ( U && u ) non-explicit generic constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<U>(u) . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Ok() [4/9] template < class T > template < class U > explicit mitama :: Ok < T >:: Ok ( U && u ) explicit generic constructor template Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<U>(u) . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Ok() [5/9] template < class T > template < typename U > constexpr mitama :: Ok < T >:: Ok ( const Ok < U > & t ) non-explicit constructor for Ok Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Ok() [6/9] template < class T > template < typename U > explicit mitama :: Ok < T >:: Ok ( const Ok < U > & t ) explicit generic copy constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Ok() [7/9] template < class T > template < typename U > constexpr mitama :: Ok < T >:: Ok ( Ok < U > && t ) non-explicit move constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Ok() [8/9] template < class T > template < typename U > constexpr mitama :: Ok < T >:: Ok ( Ok < U > && t ) explicit move constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor. Ok() [9/9] ```cpp template template constexpr mitama::Ok ::Ok(std::in_place_t, Args &&... args) in-place constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<Args>(args)... . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"constructors"},{"location":"Result101/Ok/constructors/#ok-19","text":"template < class T > mitama :: Ok < T >:: Ok () = delete default constructor is explicitly deleted.","title":"Ok() [1/9]"},{"location":"Result101/Ok/constructors/#ok-29","text":"template <> mitama :: Ok < std :: monostate >:: Ok () = default default constructor is explicitly defaulted.","title":"Ok() [2/9]"},{"location":"Result101/Ok/constructors/#ok-39","text":"template < class T > template < class U > constexpr mitama :: Ok < T >:: Ok ( U && u ) non-explicit generic constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<U>(u) . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Ok() [3/9]"},{"location":"Result101/Ok/constructors/#ok-49","text":"template < class T > template < class U > explicit mitama :: Ok < T >:: Ok ( U && u ) explicit generic constructor template Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<U>(u) . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Ok() [4/9]"},{"location":"Result101/Ok/constructors/#ok-59","text":"template < class T > template < typename U > constexpr mitama :: Ok < T >:: Ok ( const Ok < U > & t ) non-explicit constructor for Ok Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Ok() [5/9]"},{"location":"Result101/Ok/constructors/#ok-69","text":"template < class T > template < typename U > explicit mitama :: Ok < T >:: Ok ( const Ok < U > & t ) explicit generic copy constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Ok() [6/9]"},{"location":"Result101/Ok/constructors/#ok-79","text":"template < class T > template < typename U > constexpr mitama :: Ok < T >:: Ok ( Ok < U > && t ) non-explicit move constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Ok() [7/9]"},{"location":"Result101/Ok/constructors/#ok-89","text":"template < class T > template < typename U > constexpr mitama :: Ok < T >:: Ok ( Ok < U > && t ) explicit move constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression t.x . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Ok() [8/9]"},{"location":"Result101/Ok/constructors/#ok-99","text":"```cpp template template constexpr mitama::Ok ::Ok(std::in_place_t, Args &&... args) in-place constructor Initializes the contained variant as if direct-non-list-initializing an object of type T with the expression std::forward<Args>(args)... . Exceptions Any exception thrown by the selected constructor of T . Remarks The expression inside noexcept is equivalent to is_nothrow_constructible_v<T, U> . This constructor shall not participate in overload resolution unless is_constructible_v<T, U> and !is_conertible_v<U, T> is true. If is_trivially_constructible_v<T, U> is true, this constructor shall be a constexpr constructor.","title":"Ok() [9/9]"},{"location":"Result101/Ok/deduction_guides/","text":"Deduction guide template < class T > Ok ( T && ) -> Ok < std :: decay_t < T >> ;","title":"deduction guides"},{"location":"Result101/Ok/deduction_guides/#deduction-guide","text":"template < class T > Ok ( T && ) -> Ok < std :: decay_t < T >> ;","title":"Deduction guide"},{"location":"Result101/Result/","text":"class Result Result <T, E> is a class template that has Ok value type of T and Err value type of E . Actually, it is a wrapper class of std::variant<Ok<T>, Err<E>> that has a useful API.","title":"Result"},{"location":"Result101/Result/#class-result","text":"Result <T, E> is a class template that has Ok value type of T and Err value type of E . Actually, it is a wrapper class of std::variant<Ok<T>, Err<E>> that has a useful API.","title":"class Result"},{"location":"Result101/Result/constructors/","text":"Constructors Result(Result const&) [1/14] template < class T , class E > constexpr mitama :: Result < T , E >:: Result ( const Result < T , E >& rhs ) Copy constructor. Initializes the contained variant as. Exceptions Any exception thrown by the selected constructor of T or E . Remarks This constructor shall be defined as deleted unless is_copy_constructible_v<T> && is_copy_constructible_v<E> is true. If is_trivially_copy_constructible_v<T> && is_trivially_copy_constructible_v<E> is true, this constructor shall be a constexpr constructor. Result(Result&&) [2/14] template < class T , class E > constexpr mitama :: Result < T , E >:: Result ( Result < T , E > && rhs ) Move constructor. Initializes the contained variant. Exceptions Any exception thrown by the selected constructor of T or E . Remarks The expression inside noexcept is equivalent to is_nothrow_move_constructible_v<T> && is_nothrow_move_constructible_v<E> . This constructor shall not participate in overload resolution unless is_move_constructible_v<T> && is_move_constructible_v<E> is true. If is_trivially_move_constructible_v<T> && is_trivially_move_constructible_v<T> is true, this constructor shall be a constexpr constructor. Result() [3/14] template < class T , class E > template < class U > mitama :: Result < T , E >:: Result ( Ok < U > const & ok ) constructor from Ok const& . Initializes the contained variant as if in-place-initializing an object of type Ok<T> const& . Exceptions Any exception thrown by the selected constructor of T. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true. Result() [4/14] template < class T , class E > template < class U > explicit mitama :: Result < T , E >:: Result ( Ok < U > const & ok ) constructor for Ok const& Initializes the contained variant as if in-place-initializing an object of type Ok const&. Exceptions Any exception thrown by the selected constructor of T . Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true. Result() [5/14] template < class T , class E > template < class U > mitama :: Result < T , E >:: Result ( Ok < U >&& ok ) constructor for Ok&& . Initializes the contained variant as if in-place-initializing an object of type Ok<T>&& . Exceptions Any exception thrown by the selected constructor of T. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true. Result() [6/14] template < class T , class E > template < class U > explicit mitama :: Result < T , E >:: Result ( Ok < U > && ok ) constructor for Ok&& . Initializes the contained variant as if in-place-initializing an object of type Ok<T>&& . Exceptions Any exception thrown by the selected constructor of T. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true. Result() [7/14] template < class T , class E > template < class U > mitama :: Result < T , E >:: Result ( Err < U > const & err ) constructor for Err const& . Initializes the contained variant as if in-place-initializing an object of type Err<E> const& . Exceptions Any exception thrown by the selected constructor of E . Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && is_convertible_v<U, E> is true. Result() [8/14] template < class T , class E > template < class U > explicit mitama :: Result < T , E >:: Result ( Err < U > const & err ) constructor for Err const& . Initializes the contained variant as if in-place-initializing an object of type Err<E> const& . Exceptions Any exception thrown by the selected constructor of E . Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && !is_convertible_v<U, E> is true. Result() [9/14] template < class T , class E > template < class U > mitama :: Result < T , E >:: Result ( Err < U > && err ) constructor for Err&& . Initializes the contained variant as if in-place-initializing an object of type Err<E>&& . Exceptions Any exception thrown by the selected constructor of E. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && is_convertible_v<U, E> is true. Result() [10/14] template < class T , class E > template < class U > explicit mitama :: Result < T , E >:: Result ( Err < U > && err ) constructor for Err&& . Initializes the contained variant as if in-place-initializing an object of type Err<E>&& . Exceptions Any exception thrown by the selected constructor of E . Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && !is_convertible_v<U, E> is true. Result() [11/14] template < class T , class E > template < class ... Args > explicit mitama :: Result < T , E >:: Result ( in_place_ok_t , Args && ... args ) constructor for ok value. Initializes the contained variant as if in-place-initializing an object of type with expression (std::in_place_type<Ok<T>>, std::forward<Args>(args)...) . Exceptions Any exception thrown by the selected constructor of T . Example using my_result = Result < std :: tuple < int , int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , 1 , 1 ); // same as `my_result(Ok(std::tuple{1,1}))` Result() [12/14] template < class T , class E > template < class ... Args > explicit mitama :: Result < T , E >:: Result ( in_place_err_t , Args && ... args ) constructor for ok value Initializes the contained variant as if in-place-initializing an object of type with expression (std::in_place_type<Err<E>>, std::forward<Args>(args)...) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = Result < int , std :: string > ; auto res = my_result ( mitama :: in_place_err , 'a' , 5 ); // Err(\"aaaaa\") Result() [13/14] template < class T , class E > template < class U , class ... Args > explicit mitama :: Result < T , E >:: Result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) constructor for ok value. Initializes the contained variant as if in-place-initializing an object of type with expression (std::in_place_type<Ok<T>>, il, std::forward<Args>(args)...) . Exceptions Any exception thrown by the selected constructor of T. Example using my_result = Result < std :: vector < int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , { 1 , 2 , 3 , 4 }, std :: allocator < int > ()); // Ok([1,2,3,4]) Result() [14/14] template < class T , class E > template < class U , class ... Args > explicit mitama :: Result < T , E >:: Result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) constructor for err value. Initializes the contained variant as if in-place-initializing an object of type with expression (std::in_place_type<Err<E>>, il, std::forward<Args>(args)...) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = Result < std :: string , std :: vector < int >> ; auto res = my_result ( mitama :: in_place_err , { 1 , 2 , 3 , 4 }); // Err([1,2,3,4])","title":"constructors"},{"location":"Result101/Result/constructors/#constructors","text":"","title":"Constructors"},{"location":"Result101/Result/constructors/#resultresult-const-114","text":"template < class T , class E > constexpr mitama :: Result < T , E >:: Result ( const Result < T , E >& rhs ) Copy constructor. Initializes the contained variant as. Exceptions Any exception thrown by the selected constructor of T or E . Remarks This constructor shall be defined as deleted unless is_copy_constructible_v<T> && is_copy_constructible_v<E> is true. If is_trivially_copy_constructible_v<T> && is_trivially_copy_constructible_v<E> is true, this constructor shall be a constexpr constructor.","title":"Result(Result const&amp;) [1/14]"},{"location":"Result101/Result/constructors/#resultresult-214","text":"template < class T , class E > constexpr mitama :: Result < T , E >:: Result ( Result < T , E > && rhs ) Move constructor. Initializes the contained variant. Exceptions Any exception thrown by the selected constructor of T or E . Remarks The expression inside noexcept is equivalent to is_nothrow_move_constructible_v<T> && is_nothrow_move_constructible_v<E> . This constructor shall not participate in overload resolution unless is_move_constructible_v<T> && is_move_constructible_v<E> is true. If is_trivially_move_constructible_v<T> && is_trivially_move_constructible_v<T> is true, this constructor shall be a constexpr constructor.","title":"Result(Result&amp;&amp;) [2/14]"},{"location":"Result101/Result/constructors/#result-314","text":"template < class T , class E > template < class U > mitama :: Result < T , E >:: Result ( Ok < U > const & ok ) constructor from Ok const& . Initializes the contained variant as if in-place-initializing an object of type Ok<T> const& . Exceptions Any exception thrown by the selected constructor of T. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true.","title":"Result() [3/14]"},{"location":"Result101/Result/constructors/#result-414","text":"template < class T , class E > template < class U > explicit mitama :: Result < T , E >:: Result ( Ok < U > const & ok ) constructor for Ok const& Initializes the contained variant as if in-place-initializing an object of type Ok const&. Exceptions Any exception thrown by the selected constructor of T . Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true.","title":"Result() [4/14]"},{"location":"Result101/Result/constructors/#result-514","text":"template < class T , class E > template < class U > mitama :: Result < T , E >:: Result ( Ok < U >&& ok ) constructor for Ok&& . Initializes the contained variant as if in-place-initializing an object of type Ok<T>&& . Exceptions Any exception thrown by the selected constructor of T. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true.","title":"Result() [5/14]"},{"location":"Result101/Result/constructors/#result-614","text":"template < class T , class E > template < class U > explicit mitama :: Result < T , E >:: Result ( Ok < U > && ok ) constructor for Ok&& . Initializes the contained variant as if in-place-initializing an object of type Ok<T>&& . Exceptions Any exception thrown by the selected constructor of T. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true.","title":"Result() [6/14]"},{"location":"Result101/Result/constructors/#result-714","text":"template < class T , class E > template < class U > mitama :: Result < T , E >:: Result ( Err < U > const & err ) constructor for Err const& . Initializes the contained variant as if in-place-initializing an object of type Err<E> const& . Exceptions Any exception thrown by the selected constructor of E . Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && is_convertible_v<U, E> is true.","title":"Result() [7/14]"},{"location":"Result101/Result/constructors/#result-814","text":"template < class T , class E > template < class U > explicit mitama :: Result < T , E >:: Result ( Err < U > const & err ) constructor for Err const& . Initializes the contained variant as if in-place-initializing an object of type Err<E> const& . Exceptions Any exception thrown by the selected constructor of E . Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && !is_convertible_v<U, E> is true.","title":"Result() [8/14]"},{"location":"Result101/Result/constructors/#result-914","text":"template < class T , class E > template < class U > mitama :: Result < T , E >:: Result ( Err < U > && err ) constructor for Err&& . Initializes the contained variant as if in-place-initializing an object of type Err<E>&& . Exceptions Any exception thrown by the selected constructor of E. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && is_convertible_v<U, E> is true.","title":"Result() [9/14]"},{"location":"Result101/Result/constructors/#result-1014","text":"template < class T , class E > template < class U > explicit mitama :: Result < T , E >:: Result ( Err < U > && err ) constructor for Err&& . Initializes the contained variant as if in-place-initializing an object of type Err<E>&& . Exceptions Any exception thrown by the selected constructor of E . Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && !is_convertible_v<U, E> is true.","title":"Result() [10/14]"},{"location":"Result101/Result/constructors/#result-1114","text":"template < class T , class E > template < class ... Args > explicit mitama :: Result < T , E >:: Result ( in_place_ok_t , Args && ... args ) constructor for ok value. Initializes the contained variant as if in-place-initializing an object of type with expression (std::in_place_type<Ok<T>>, std::forward<Args>(args)...) . Exceptions Any exception thrown by the selected constructor of T . Example using my_result = Result < std :: tuple < int , int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , 1 , 1 ); // same as `my_result(Ok(std::tuple{1,1}))`","title":"Result() [11/14]"},{"location":"Result101/Result/constructors/#result-1214","text":"template < class T , class E > template < class ... Args > explicit mitama :: Result < T , E >:: Result ( in_place_err_t , Args && ... args ) constructor for ok value Initializes the contained variant as if in-place-initializing an object of type with expression (std::in_place_type<Err<E>>, std::forward<Args>(args)...) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = Result < int , std :: string > ; auto res = my_result ( mitama :: in_place_err , 'a' , 5 ); // Err(\"aaaaa\")","title":"Result() [12/14]"},{"location":"Result101/Result/constructors/#result-1314","text":"template < class T , class E > template < class U , class ... Args > explicit mitama :: Result < T , E >:: Result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) constructor for ok value. Initializes the contained variant as if in-place-initializing an object of type with expression (std::in_place_type<Ok<T>>, il, std::forward<Args>(args)...) . Exceptions Any exception thrown by the selected constructor of T. Example using my_result = Result < std :: vector < int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , { 1 , 2 , 3 , 4 }, std :: allocator < int > ()); // Ok([1,2,3,4])","title":"Result() [13/14]"},{"location":"Result101/Result/constructors/#result-1414","text":"template < class T , class E > template < class U , class ... Args > explicit mitama :: Result < T , E >:: Result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) constructor for err value. Initializes the contained variant as if in-place-initializing an object of type with expression (std::in_place_type<Err<E>>, il, std::forward<Args>(args)...) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = Result < std :: string , std :: vector < int >> ; auto res = my_result ( mitama :: in_place_err , { 1 , 2 , 3 , 4 }); // Err([1,2,3,4])","title":"Result() [14/14]"},{"location":"api/","text":"Result user reference CHANGELOG v1.2.0 enhancement new API: transpose new API: map_or_else v1.1.2 bug fix Result ::and_then(O&& op) do not perticipate in overload resolution if unless op returns Result<U, E> . std::invoke_result_t<O&&, T> must be returns Result<U, E> . It means op must only maps T -> U , never changes E . Result ::or_else(O&& op) do not perticipate in overload resolution if unless op returns Result<T, F> . std::invoke_result_t<O&&, E> must be returns Result<T, F> . It means op must only maps E -> F , never changes T . v1.1.1 bug fix Result ::unwrap_or_default() is now explicitly deleted if and only if std::is_default_constructible_v<T> || std::is_aggregate_v<T> is false.","title":"CHANGELOG"},{"location":"api/#result-user-reference","text":"","title":"Result user reference"},{"location":"api/#changelog","text":"","title":"CHANGELOG"},{"location":"api/#v120","text":"","title":"v1.2.0"},{"location":"api/#enhancement","text":"new API: transpose new API: map_or_else","title":"enhancement"},{"location":"api/#v112","text":"","title":"v1.1.2"},{"location":"api/#bug-fix","text":"Result ::and_then(O&& op) do not perticipate in overload resolution if unless op returns Result<U, E> . std::invoke_result_t<O&&, T> must be returns Result<U, E> . It means op must only maps T -> U , never changes E . Result ::or_else(O&& op) do not perticipate in overload resolution if unless op returns Result<T, F> . std::invoke_result_t<O&&, E> must be returns Result<T, F> . It means op must only maps E -> F , never changes T .","title":"bug fix"},{"location":"api/#v111","text":"","title":"v1.1.1"},{"location":"api/#bug-fix_1","text":"Result ::unwrap_or_default() is now explicitly deleted if and only if std::is_default_constructible_v<T> || std::is_aggregate_v<T> is false.","title":"bug fix"},{"location":"api/and/","text":"operator &&() template < class T , class E > template < class U > constexpr auto mitama :: Result < T , E >:: operator && ( Result < U , E > const & res ) const & -> Result < U , E > Returns res if the result is Ok , otherwise returns the Err value of self. Example { Result < unsigned , std :: string > x = Ok ( 2 ); Result < std :: string , std :: string > y = Err ( \"late error\" s ); assert_eq ( x && y , Err ( \"late error\" s )); } { Result < unsigned , std :: string > x = Err ( \"early error\" s ); Result < std :: string , std :: string > y = Ok ( \"foo\" s ); assert_eq ( x && y , Err ( \"early error\" s )); } { Result < unsigned , std :: string > x = Err ( \"not a 2\" s ); Result < std :: string , std :: string > y = Err ( \"late error\" s ); assert_eq ( x && y , Err ( \"not a 2\" s )); } { Result < unsigned , std :: string > x = Ok ( 2 ); Result < std :: string , std :: string > y = Ok ( \"different result type\" s ); assert_eq ( x && y , Ok ( \"different result type\" s )); }","title":"and"},{"location":"api/and/#operator","text":"template < class T , class E > template < class U > constexpr auto mitama :: Result < T , E >:: operator && ( Result < U , E > const & res ) const & -> Result < U , E > Returns res if the result is Ok , otherwise returns the Err value of self. Example { Result < unsigned , std :: string > x = Ok ( 2 ); Result < std :: string , std :: string > y = Err ( \"late error\" s ); assert_eq ( x && y , Err ( \"late error\" s )); } { Result < unsigned , std :: string > x = Err ( \"early error\" s ); Result < std :: string , std :: string > y = Ok ( \"foo\" s ); assert_eq ( x && y , Err ( \"early error\" s )); } { Result < unsigned , std :: string > x = Err ( \"not a 2\" s ); Result < std :: string , std :: string > y = Err ( \"late error\" s ); assert_eq ( x && y , Err ( \"not a 2\" s )); } { Result < unsigned , std :: string > x = Ok ( 2 ); Result < std :: string , std :: string > y = Ok ( \"different result type\" s ); assert_eq ( x && y , Ok ( \"different result type\" s )); }","title":"operator &amp;&amp;()"},{"location":"api/and_then/","text":"and_then() template < class T , class E > template < class O > constexpr auto mitama :: Result < T , E >:: and_then ( O && op ) const & Calls op if the result is Ok, otherwise returns the Err value of self. This function can be used for control flow based on Result values. Condition // for all type U: std :: invoke_result_t < O , T > => Result < U , E > Remarks This constructor shall not participate in overload resolution unless is_result_with_v<std::invoke_result_t<O, T>, Err<E>> is true. Example auto sq = []( unsigned x ) -> Result < unsigned , unsigned > { return Ok ( x * x ); }; auto err = []( unsigned x ) -> Result < unsigned , unsigned > { return Err ( x ); }; assert_eq ( Ok ( 2u ). and_then ( sq ). and_then ( sq ), Ok ( 16u )); assert_eq ( Ok ( 2u ). and_then ( sq ). and_then ( err ), Err ( 4u )); assert_eq ( Ok ( 2u ). and_then ( err ). and_then ( sq ), Err ( 2u )); assert_eq ( Err ( 3u ). and_then ( sq ). and_then ( sq ), Err ( 3u ));","title":"and_then"},{"location":"api/and_then/#and_then","text":"template < class T , class E > template < class O > constexpr auto mitama :: Result < T , E >:: and_then ( O && op ) const & Calls op if the result is Ok, otherwise returns the Err value of self. This function can be used for control flow based on Result values. Condition // for all type U: std :: invoke_result_t < O , T > => Result < U , E > Remarks This constructor shall not participate in overload resolution unless is_result_with_v<std::invoke_result_t<O, T>, Err<E>> is true. Example auto sq = []( unsigned x ) -> Result < unsigned , unsigned > { return Ok ( x * x ); }; auto err = []( unsigned x ) -> Result < unsigned , unsigned > { return Err ( x ); }; assert_eq ( Ok ( 2u ). and_then ( sq ). and_then ( sq ), Ok ( 16u )); assert_eq ( Ok ( 2u ). and_then ( sq ). and_then ( err ), Err ( 4u )); assert_eq ( Ok ( 2u ). and_then ( err ). and_then ( sq ), Err ( 2u )); assert_eq ( Err ( 3u ). and_then ( sq ). and_then ( sq ), Err ( 3u ));","title":"and_then()"},{"location":"api/equality/","text":"operator==() [1/3] template < class T , class E > template < class U , class F > bool mitama :: Result < T , E >:: operator == ( Result < U , F > const & rhs ) const & Operator== for Result<T, E> and Result<U, F> . Remarks This operator shall be defined as deleted unless std::declval<T const&>() == std::declval<U const&>() is valid expression and std::declval<E const&>() == std::declval<F const&>() is valid expression. operator==() [2/3] template < class T , class E > template < class U > bool mitama :: Result < T , E >:: operator == ( Ok < U > const & rhs ) const Operator== for Result<T, E> and Ok<U> . Returns true if this has Ok value this->unwrap() equals rhs value, otherwise false . Remarks This operator shall be defined as deleted unless std::declval<T const&>() == std::declval<U const&>() is valid expression. operator==() [3/3] template < class T , class E > template < class F > bool mitama :: Result < T , E >:: operator == ( Err < F > const & rhs ) const Operator== for Result<T, E> and Err<F> . Returns true if this has Err value this->unwrap_err() equals rhs value, otherwise false . Remarks This operator shall be defined as deleted unless std::declval<E const&>() == std::declval<F const&>() is valid expression.","title":"operator=="},{"location":"api/equality/#operator-13","text":"template < class T , class E > template < class U , class F > bool mitama :: Result < T , E >:: operator == ( Result < U , F > const & rhs ) const & Operator== for Result<T, E> and Result<U, F> . Remarks This operator shall be defined as deleted unless std::declval<T const&>() == std::declval<U const&>() is valid expression and std::declval<E const&>() == std::declval<F const&>() is valid expression.","title":"operator==() [1/3]"},{"location":"api/equality/#operator-23","text":"template < class T , class E > template < class U > bool mitama :: Result < T , E >:: operator == ( Ok < U > const & rhs ) const Operator== for Result<T, E> and Ok<U> . Returns true if this has Ok value this->unwrap() equals rhs value, otherwise false . Remarks This operator shall be defined as deleted unless std::declval<T const&>() == std::declval<U const&>() is valid expression.","title":"operator==() [2/3]"},{"location":"api/equality/#operator-33","text":"template < class T , class E > template < class F > bool mitama :: Result < T , E >:: operator == ( Err < F > const & rhs ) const Operator== for Result<T, E> and Err<F> . Returns true if this has Err value this->unwrap_err() equals rhs value, otherwise false . Remarks This operator shall be defined as deleted unless std::declval<E const&>() == std::declval<F const&>() is valid expression.","title":"operator==() [3/3]"},{"location":"api/err/","text":"err() [1/2] template < class T , class E > constexpr std :: optional < E > mitama :: Result < T , E >:: err () const & Converts from Result<T, E> to std::optional<E> . Converts self into an std::optional<E> , copying self, and discarding the success value, if any. Example Result < unsigned , std :: string > x = Ok ( 2 ); assert_eq ( x . err (), None ); Result < unsigned , std :: string > y = Err ( \"Nothing here\" ); assert_eq ( y . err (), Some ( \"Nothing here\" )); err() [2/2] template < class T , class E > constexpr std :: optional < E > mitama :: Result < T , E >:: err () && Converts from Result<T, E> to std::optional<E> . Converts self into an std::optional<E> , consuming self, and discarding the success value, if any.","title":"err"},{"location":"api/err/#err-12","text":"template < class T , class E > constexpr std :: optional < E > mitama :: Result < T , E >:: err () const & Converts from Result<T, E> to std::optional<E> . Converts self into an std::optional<E> , copying self, and discarding the success value, if any. Example Result < unsigned , std :: string > x = Ok ( 2 ); assert_eq ( x . err (), None ); Result < unsigned , std :: string > y = Err ( \"Nothing here\" ); assert_eq ( y . err (), Some ( \"Nothing here\" ));","title":"err() [1/2]"},{"location":"api/err/#err-22","text":"template < class T , class E > constexpr std :: optional < E > mitama :: Result < T , E >:: err () && Converts from Result<T, E> to std::optional<E> . Converts self into an std::optional<E> , consuming self, and discarding the success value, if any.","title":"err() [2/2]"},{"location":"api/is_err/","text":"is_err() template < class T , class E > constexpr bool mitama :: Result < T , E >:: is_err () const noexcept Returns true if the result is Err. Example Result < uint32_t , std :: string > x = Ok ( - 3 ); assert_eq ( x . is_err (), false ); Result < uint32_t , std :: string > y = Err ( \"Some error message\" ); assert_eq ( y . is_err (), true );","title":"is_err"},{"location":"api/is_err/#is_err","text":"template < class T , class E > constexpr bool mitama :: Result < T , E >:: is_err () const noexcept Returns true if the result is Err. Example Result < uint32_t , std :: string > x = Ok ( - 3 ); assert_eq ( x . is_err (), false ); Result < uint32_t , std :: string > y = Err ( \"Some error message\" ); assert_eq ( y . is_err (), true );","title":"is_err()"},{"location":"api/is_ok/","text":"is_ok() template < class T , class E > constexpr bool mitama :: Result < T , E >:: is_ok () const noexcept Returns true if the result is Ok . Example Result < uint32_t , std :: string > x = Ok ( - 3 ); assert ( x . is_ok (), true ); Result < uint32_t , std :: string > y = Err ( \"Some error message\" ); assert ( y . is_ok (), false );","title":"is_ok"},{"location":"api/is_ok/#is_ok","text":"template < class T , class E > constexpr bool mitama :: Result < T , E >:: is_ok () const noexcept Returns true if the result is Ok . Example Result < uint32_t , std :: string > x = Ok ( - 3 ); assert ( x . is_ok (), true ); Result < uint32_t , std :: string > y = Err ( \"Some error message\" ); assert ( y . is_ok (), false );","title":"is_ok()"},{"location":"api/map/","text":"map() template < class T , class E > template < class O > constexpr auto mitama :: Result < T , E >:: map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , Result < std :: invoke_result_t < O , T > , E >> Maps a Result<T, E> to Result<U, E> by applying a function to a contained Ok value, leaving an Err value untouched. This function can be used to compose the results of two functions. Example std :: string line = \"1,3,5,7\" ; for ( auto num : split ( line , \",\" )) { if ( auto res = parse < int > ( num ). map ( _1 * 2 ); res . is_ok ()) { assert_true ( res . ok (). value () % 2 == 0 ); } }","title":"map"},{"location":"api/map/#map","text":"template < class T , class E > template < class O > constexpr auto mitama :: Result < T , E >:: map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , Result < std :: invoke_result_t < O , T > , E >> Maps a Result<T, E> to Result<U, E> by applying a function to a contained Ok value, leaving an Err value untouched. This function can be used to compose the results of two functions. Example std :: string line = \"1,3,5,7\" ; for ( auto num : split ( line , \",\" )) { if ( auto res = parse < int > ( num ). map ( _1 * 2 ); res . is_ok ()) { assert_true ( res . ok (). value () % 2 == 0 ); } }","title":"map()"},{"location":"api/map_err/","text":"map_err() template < class T , class E > template < class O > constexpr auto mitama :: Result < T , E >:: map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , Result < T , std :: invoke_result_t < O , E >>> Maps a Result<T, E> to Result<T, F> by applying a function to a contained Err value, leaving an Ok value untouched. This function can be used to pass through a successful result while handling an error. Example auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; Result < unsigned , unsigned > x = Ok ( 2 ); assert_eq ( x . map_err ( stringify ), Ok ( 2u )); Result < unsigned , unsigned > y = Err ( 13 ); assert_eq ( y . map_err ( stringify ), Err ( \"error code: 13\" s ));","title":"map_err"},{"location":"api/map_err/#map_err","text":"template < class T , class E > template < class O > constexpr auto mitama :: Result < T , E >:: map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , Result < T , std :: invoke_result_t < O , E >>> Maps a Result<T, E> to Result<T, F> by applying a function to a contained Err value, leaving an Ok value untouched. This function can be used to pass through a successful result while handling an error. Example auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; Result < unsigned , unsigned > x = Ok ( 2 ); assert_eq ( x . map_err ( stringify ), Ok ( 2u )); Result < unsigned , unsigned > y = Err ( 13 ); assert_eq ( y . map_err ( stringify ), Err ( \"error code: 13\" s ));","title":"map_err()"},{"location":"api/map_or_else/","text":"map_or_else() [since 1.2.0] template < class Map , class Fallback , class U = T , class F = E > constexpr auto map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> Maps a Result<T, E> to U by applying a function to a contained Ok value, or a fallback function to a contained Err value. This function can be used to unpack a successful result while handling an error. Examples Basic usage: auto k = 21 ; { Result < std :: string , std :: string > x = Ok ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { Result < std :: string , std :: string > x = Err ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); }","title":"map_or_else"},{"location":"api/map_or_else/#map_or_else-since-120","text":"template < class Map , class Fallback , class U = T , class F = E > constexpr auto map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> Maps a Result<T, E> to U by applying a function to a contained Ok value, or a fallback function to a contained Err value. This function can be used to unpack a successful result while handling an error. Examples Basic usage: auto k = 21 ; { Result < std :: string , std :: string > x = Ok ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { Result < std :: string , std :: string > x = Err ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); }","title":"map_or_else() [since 1.2.0]"},{"location":"api/ok/","text":"ok() [1/2] template < class T , class E > constexpr std :: optional < T > mitama :: Result < T , E >:: ok () const & Converts from Result<T, E> to std::optional<T> . Converts self into an std::optional<T> , copying self, and discarding the error, if any. Example Result < unsigned , std :: string > x = Ok ( 2 ); assert_eq ( x . err (), None ); Result < int , std :: string > y = Err ( \"Nothing here\" ); assert_eq ( y . err (), Some ( \"Nothing here\" )); ok() [2/2] template < class T , class E > constexpr std :: optional < T > mitama :: Result < T , E >:: ok () && Converts from Result<T, E> to std::optional<T> . Converts self into an std::optional<T> , comsuming self, and discarding the error, if any.","title":"ok"},{"location":"api/ok/#ok-12","text":"template < class T , class E > constexpr std :: optional < T > mitama :: Result < T , E >:: ok () const & Converts from Result<T, E> to std::optional<T> . Converts self into an std::optional<T> , copying self, and discarding the error, if any. Example Result < unsigned , std :: string > x = Ok ( 2 ); assert_eq ( x . err (), None ); Result < int , std :: string > y = Err ( \"Nothing here\" ); assert_eq ( y . err (), Some ( \"Nothing here\" ));","title":"ok() [1/2]"},{"location":"api/ok/#ok-22","text":"template < class T , class E > constexpr std :: optional < T > mitama :: Result < T , E >:: ok () && Converts from Result<T, E> to std::optional<T> . Converts self into an std::optional<T> , comsuming self, and discarding the error, if any.","title":"ok() [2/2]"},{"location":"api/or/","text":"operator||() template < class T , class E > template < class F > constexpr auto mitama :: Result < T , E >:: operator || ( Result < T , F > const & res ) const & -> Result < T , F > Returns res if the result is Err , otherwise returns the Ok value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. Example { Result < unsigned , std :: string > x = Ok ( 2 ); Result < unsigned , std :: string > y = Err ( \"late error\" s ); assert_eq ( x || y , Ok ( 2u )); } { Result < unsigned , std :: string > x = Err ( \"early error\" s ); Result < unsigned , std :: string > y = Ok ( 2 ); assert_eq ( x || y , Ok ( 2u )); } { Result < unsigned , std :: string > x = Err ( \"not a 2\" s ); Result < unsigned , std :: string > y = Err ( \"late error\" s ); assert_eq ( x || y , Err ( \"late error\" s )); } { Result < unsigned , std :: string > x = Ok ( 2 ); Result < unsigned , std :: string > y = Ok ( 100 ); assert_eq ( x || y , Ok ( 2u )); }","title":"or"},{"location":"api/or/#operator","text":"template < class T , class E > template < class F > constexpr auto mitama :: Result < T , E >:: operator || ( Result < T , F > const & res ) const & -> Result < T , F > Returns res if the result is Err , otherwise returns the Ok value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. Example { Result < unsigned , std :: string > x = Ok ( 2 ); Result < unsigned , std :: string > y = Err ( \"late error\" s ); assert_eq ( x || y , Ok ( 2u )); } { Result < unsigned , std :: string > x = Err ( \"early error\" s ); Result < unsigned , std :: string > y = Ok ( 2 ); assert_eq ( x || y , Ok ( 2u )); } { Result < unsigned , std :: string > x = Err ( \"not a 2\" s ); Result < unsigned , std :: string > y = Err ( \"late error\" s ); assert_eq ( x || y , Err ( \"late error\" s )); } { Result < unsigned , std :: string > x = Ok ( 2 ); Result < unsigned , std :: string > y = Ok ( 100 ); assert_eq ( x || y , Ok ( 2u )); }","title":"operator||()"},{"location":"api/or_else/","text":"or_else() template < class T , class E > template < class O > constexpr auto mitama :: Result < T , E >:: or_else ( O && op ) const & Calls op if the result is Err , otherwise returns the Ok value of self. This function can be used for control flow based on result values. Condition // for all type F: std :: invoke_result_t < O , T > => Result < T , F > Remarks This constructor shall not participate in overload resolution unless is_result_with_v<std::invoke_result_t<O, T>, Ok<T>> is true. Example auto sq = []( unsigned x ) -> Result < unsigned , unsigned > { return Ok ( x * x ); }; auto err = []( unsigned x ) -> Result < unsigned , unsigned > { return Err ( x ); }; assert_eq ( Ok ( 2 ). or_else ( sq ). or_else ( sq ), Ok ( 2u )); assert_eq ( Ok ( 2 ). or_else ( err ). or_else ( sq ), Ok ( 2u )); assert_eq ( Err ( 3 ). or_else ( sq ). or_else ( err ), Ok ( 9u )); assert_eq ( Err ( 3 ). or_else ( err ). or_else ( err ), Err ( 3u ));","title":"or_else"},{"location":"api/or_else/#or_else","text":"template < class T , class E > template < class O > constexpr auto mitama :: Result < T , E >:: or_else ( O && op ) const & Calls op if the result is Err , otherwise returns the Ok value of self. This function can be used for control flow based on result values. Condition // for all type F: std :: invoke_result_t < O , T > => Result < T , F > Remarks This constructor shall not participate in overload resolution unless is_result_with_v<std::invoke_result_t<O, T>, Ok<T>> is true. Example auto sq = []( unsigned x ) -> Result < unsigned , unsigned > { return Ok ( x * x ); }; auto err = []( unsigned x ) -> Result < unsigned , unsigned > { return Err ( x ); }; assert_eq ( Ok ( 2 ). or_else ( sq ). or_else ( sq ), Ok ( 2u )); assert_eq ( Ok ( 2 ). or_else ( err ). or_else ( sq ), Ok ( 2u )); assert_eq ( Err ( 3 ). or_else ( sq ). or_else ( err ), Ok ( 9u )); assert_eq ( Err ( 3 ). or_else ( err ). or_else ( err ), Err ( 3u ));","title":"or_else()"},{"location":"api/transpose/","text":"transpose() [since 1.2.0] template < class T , class E > auto mitama :: Result < T , E >:: transpose () -> std :: optional < mitama :: Result < T , E >> Transposes a Result of an optional into an optional of a Result . Ok(nullopt) will be mapped to nullopt . Ok(optional(v)) and Err(v) will be mapped to optional(Ok(v)) and optional(Err(v)) . Examples struct SomeErr {}; Result < std :: optional < int > , SomeErr > x = Ok ( std :: optional ( 5 )); std :: optional < Result < int , SomeErr >> y = std :: optional ( Result < int , SomeErr > ( Ok ( 5 ))); assert_eq ! ( x . transpose (), y );","title":"transpose"},{"location":"api/transpose/#transpose-since-120","text":"template < class T , class E > auto mitama :: Result < T , E >:: transpose () -> std :: optional < mitama :: Result < T , E >> Transposes a Result of an optional into an optional of a Result . Ok(nullopt) will be mapped to nullopt . Ok(optional(v)) and Err(v) will be mapped to optional(Ok(v)) and optional(Err(v)) . Examples struct SomeErr {}; Result < std :: optional < int > , SomeErr > x = Ok ( std :: optional ( 5 )); std :: optional < Result < int , SomeErr >> y = std :: optional ( Result < int , SomeErr > ( Ok ( 5 ))); assert_eq ! ( x . transpose (), y );","title":"transpose() [since 1.2.0]"},{"location":"api/unwrap/","text":"unwrap() template < class T , class E > T mitama :: Result < T , E >:: unwrap () const Unwraps a result, yielding the content of an Ok . Exception Raise mitama::runtime_panic if a result is containing Err value. Example { Result < unsigned , std :: string > x = Ok ( 2 ); assert_eq ( x . unwrap (), 2 ); } try { Result < unsigned , std :: string > x = Err ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic cosnt & panic ) { std :: err << panic . what () << std :: endl ; // `emergency failure` }","title":"unwrap"},{"location":"api/unwrap/#unwrap","text":"template < class T , class E > T mitama :: Result < T , E >:: unwrap () const Unwraps a result, yielding the content of an Ok . Exception Raise mitama::runtime_panic if a result is containing Err value. Example { Result < unsigned , std :: string > x = Ok ( 2 ); assert_eq ( x . unwrap (), 2 ); } try { Result < unsigned , std :: string > x = Err ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic cosnt & panic ) { std :: err << panic . what () << std :: endl ; // `emergency failure` }","title":"unwrap()"},{"location":"api/unwrap_err/","text":"unwrap_err() template < class T , class E > E mitama :: Result < T , E >:: unwrap_err () const Unwraps a result, yielding the content of an Err . Exception Raise mitama::runtime_panic if a result is containing Ok value. Example try { Result < unsigned , std :: string > x = Ok ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: err << panic . what () << std :: endl ; // 2 } { Result < unsigned , std :: string > x = Err ( \"emergency failure\" s ); assert_eq ( x . unwrap_err (), \"emergency failure\" s ); }","title":"unwrap_err"},{"location":"api/unwrap_err/#unwrap_err","text":"template < class T , class E > E mitama :: Result < T , E >:: unwrap_err () const Unwraps a result, yielding the content of an Err . Exception Raise mitama::runtime_panic if a result is containing Ok value. Example try { Result < unsigned , std :: string > x = Ok ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: err << panic . what () << std :: endl ; // 2 } { Result < unsigned , std :: string > x = Err ( \"emergency failure\" s ); assert_eq ( x . unwrap_err (), \"emergency failure\" s ); }","title":"unwrap_err()"},{"location":"api/unwrap_or/","text":"unwrap_or() template < class T , class E > T mitama :: Result < T , E >:: unwrap_or ( T const & optb ) const noexcept Unwraps a result, yielding the content of an Ok . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example Result < unsigned , unsigned > err = Err ( 2 ); Result < unsigned , unsigned > ok = Ok ( 2 ); assert_eq ( ok . unwrap_or ( 1u ), 2u ); assert_eq ( err . unwrap_or ( 1u ), 1u );","title":"unwrap_or"},{"location":"api/unwrap_or/#unwrap_or","text":"template < class T , class E > T mitama :: Result < T , E >:: unwrap_or ( T const & optb ) const noexcept Unwraps a result, yielding the content of an Ok . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. Example Result < unsigned , unsigned > err = Err ( 2 ); Result < unsigned , unsigned > ok = Ok ( 2 ); assert_eq ( ok . unwrap_or ( 1u ), 2u ); assert_eq ( err . unwrap_or ( 1u ), 1u );","title":"unwrap_or()"},{"location":"api/unwrap_or_default/","text":"unwrap_or_default() template < class T , class E > T mitama :: Result < T , E >:: unwrap_or_default () const & Returns the contained value or a default. If Ok , returns the contained value, otherwise if Err , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v<T> is true. Example auto good_year_from_input = \"1909\" s ; auto bad_year_from_input = \"190blarg\" s ; auto good_year = parse < int > ( good_year_from_input ). unwrap_or_default (); auto bad_year = parse < int > ( bad_year_from_input ). unwrap_or_default (); assert_eq ( 1909 , good_year ); assert_eq ( 0 , bad_year ); *","title":"unwrap_or_default"},{"location":"api/unwrap_or_default/#unwrap_or_default","text":"template < class T , class E > T mitama :: Result < T , E >:: unwrap_or_default () const & Returns the contained value or a default. If Ok , returns the contained value, otherwise if Err , returns the default value for that type. Remarks This operator shall be defined as deleted unless is_default_constructible_v<T> is true. Example auto good_year_from_input = \"1909\" s ; auto bad_year_from_input = \"190blarg\" s ; auto good_year = parse < int > ( good_year_from_input ). unwrap_or_default (); auto bad_year = parse < int > ( bad_year_from_input ). unwrap_or_default (); assert_eq ( 1909 , good_year ); assert_eq ( 0 , bad_year ); *","title":"unwrap_or_default()"},{"location":"api/unwrap_or_else/","text":"unwrap_or_else() template < class T , class E > template < class O > auto mitama :: Result < T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > Unwraps a result, yielding the content of an Ok . If the value is an Err then it calls op with its value. Example auto count = []( std :: stringx ) -> size_t { return x . size (); }; assert_eq ( Ok ( 2 ). unwrap_or_else ( count ), 2 ); assert_eq ( Err ( \"foo\" s ). unwrap_or_else ( count ), 3 );","title":"unwrap_or_else"},{"location":"api/unwrap_or_else/#unwrap_or_else","text":"template < class T , class E > template < class O > auto mitama :: Result < T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > Unwraps a result, yielding the content of an Ok . If the value is an Err then it calls op with its value. Example auto count = []( std :: stringx ) -> size_t { return x . size (); }; assert_eq ( Ok ( 2 ). unwrap_or_else ( count ), 2 ); assert_eq ( Err ( \"foo\" s ). unwrap_or_else ( count ), 3 );","title":"unwrap_or_else()"},{"location":"meta/is_result/","text":"is_result template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < Result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":"is_result"},{"location":"meta/is_result/#is_result","text":"template < class > struct is_result : std :: false_type { }; template < class T , class E > struct is_result < Result < T , E >> : std :: true_type { }; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":"is_result"},{"location":"meta/is_result_with/","text":"is_result_with template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < Result < T , E > , Ok < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < Result < T , E > , Err < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < Result < T , E > , Ok < T > , Err < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"is_result_with"},{"location":"meta/is_result_with/#is_result_with","text":"template < class , class ... > struct is_result_with : std :: false_type { }; template < class T , class E > struct is_result_with < Result < T , E > , Ok < T >> : std :: true_type { }; template < class T , class E > struct is_result_with < Result < T , E > , Err < E >> : std :: true_type { }; template < class T , class E > struct is_result_with < Result < T , E > , Ok < T > , Err < E >> : std :: true_type { }; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"is_result_with"}]}